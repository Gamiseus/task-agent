import { ipcMain as yr, dialog as XO, app as yc, BrowserWindow as $b } from "electron";
import Rb from "fs";
import QO from "constants";
import eI from "stream";
import tI from "util";
import nI from "assert";
import yn from "path";
import * as rI from "node:path";
import tt from "node:path";
import wn, { randomFillSync as sI, randomUUID as iI } from "node:crypto";
import * as Cr from "node:fs";
import { randomFillSync as aI, randomUUID as oI } from "crypto";
import { fileURLToPath as uI } from "node:url";
var sd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Zr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var id = {}, Jo = {}, Sg;
function Ot() {
  return Sg || (Sg = 1, Jo.fromCallback = function(e) {
    return Object.defineProperty(function(...t) {
      if (typeof t[t.length - 1] == "function") e.apply(this, t);
      else
        return new Promise((n, r) => {
          t.push((s, i) => s != null ? r(s) : n(i)), e.apply(this, t);
        });
    }, "name", { value: e.name });
  }, Jo.fromPromise = function(e) {
    return Object.defineProperty(function(...t) {
      const n = t[t.length - 1];
      if (typeof n != "function") return e.apply(this, t);
      t.pop(), e.apply(this, t).then((r) => n(null, r), n);
    }, "name", { value: e.name });
  }), Jo;
}
var ad, Tg;
function cI() {
  if (Tg) return ad;
  Tg = 1;
  var e = QO, t = process.cwd, n = null, r = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return n || (n = t.call(process)), n;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var s = process.chdir;
    process.chdir = function(a) {
      n = null, s.call(process, a);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, s);
  }
  ad = i;
  function i(a) {
    e.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && o(a), a.lutimes || u(a), a.chown = d(a.chown), a.fchown = d(a.fchown), a.lchown = d(a.lchown), a.chmod = c(a.chmod), a.fchmod = c(a.fchmod), a.lchmod = c(a.lchmod), a.chownSync = f(a.chownSync), a.fchownSync = f(a.fchownSync), a.lchownSync = f(a.lchownSync), a.chmodSync = l(a.chmodSync), a.fchmodSync = l(a.fchmodSync), a.lchmodSync = l(a.lchmodSync), a.stat = h(a.stat), a.fstat = h(a.fstat), a.lstat = h(a.lstat), a.statSync = p(a.statSync), a.fstatSync = p(a.fstatSync), a.lstatSync = p(a.lstatSync), a.chmod && !a.lchmod && (a.lchmod = function(m, _, y) {
      y && process.nextTick(y);
    }, a.lchmodSync = function() {
    }), a.chown && !a.lchown && (a.lchown = function(m, _, y, b) {
      b && process.nextTick(b);
    }, a.lchownSync = function() {
    }), r === "win32" && (a.rename = typeof a.rename != "function" ? a.rename : (function(m) {
      function _(y, b, T) {
        var x = Date.now(), k = 0;
        m(y, b, function O(S) {
          if (S && (S.code === "EACCES" || S.code === "EPERM" || S.code === "EBUSY") && Date.now() - x < 6e4) {
            setTimeout(function() {
              a.stat(b, function(j, U) {
                j && j.code === "ENOENT" ? m(y, b, O) : T(S);
              });
            }, k), k < 100 && (k += 10);
            return;
          }
          T && T(S);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(_, m), _;
    })(a.rename)), a.read = typeof a.read != "function" ? a.read : (function(m) {
      function _(y, b, T, x, k, O) {
        var S;
        if (O && typeof O == "function") {
          var j = 0;
          S = function(U, G, He) {
            if (U && U.code === "EAGAIN" && j < 10)
              return j++, m.call(a, y, b, T, x, k, S);
            O.apply(this, arguments);
          };
        }
        return m.call(a, y, b, T, x, k, S);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(_, m), _;
    })(a.read), a.readSync = typeof a.readSync != "function" ? a.readSync : /* @__PURE__ */ (function(m) {
      return function(_, y, b, T, x) {
        for (var k = 0; ; )
          try {
            return m.call(a, _, y, b, T, x);
          } catch (O) {
            if (O.code === "EAGAIN" && k < 10) {
              k++;
              continue;
            }
            throw O;
          }
      };
    })(a.readSync);
    function o(m) {
      m.lchmod = function(_, y, b) {
        m.open(
          _,
          e.O_WRONLY | e.O_SYMLINK,
          y,
          function(T, x) {
            if (T) {
              b && b(T);
              return;
            }
            m.fchmod(x, y, function(k) {
              m.close(x, function(O) {
                b && b(k || O);
              });
            });
          }
        );
      }, m.lchmodSync = function(_, y) {
        var b = m.openSync(_, e.O_WRONLY | e.O_SYMLINK, y), T = !0, x;
        try {
          x = m.fchmodSync(b, y), T = !1;
        } finally {
          if (T)
            try {
              m.closeSync(b);
            } catch {
            }
          else
            m.closeSync(b);
        }
        return x;
      };
    }
    function u(m) {
      e.hasOwnProperty("O_SYMLINK") && m.futimes ? (m.lutimes = function(_, y, b, T) {
        m.open(_, e.O_SYMLINK, function(x, k) {
          if (x) {
            T && T(x);
            return;
          }
          m.futimes(k, y, b, function(O) {
            m.close(k, function(S) {
              T && T(O || S);
            });
          });
        });
      }, m.lutimesSync = function(_, y, b) {
        var T = m.openSync(_, e.O_SYMLINK), x, k = !0;
        try {
          x = m.futimesSync(T, y, b), k = !1;
        } finally {
          if (k)
            try {
              m.closeSync(T);
            } catch {
            }
          else
            m.closeSync(T);
        }
        return x;
      }) : m.futimes && (m.lutimes = function(_, y, b, T) {
        T && process.nextTick(T);
      }, m.lutimesSync = function() {
      });
    }
    function c(m) {
      return m && function(_, y, b) {
        return m.call(a, _, y, function(T) {
          g(T) && (T = null), b && b.apply(this, arguments);
        });
      };
    }
    function l(m) {
      return m && function(_, y) {
        try {
          return m.call(a, _, y);
        } catch (b) {
          if (!g(b)) throw b;
        }
      };
    }
    function d(m) {
      return m && function(_, y, b, T) {
        return m.call(a, _, y, b, function(x) {
          g(x) && (x = null), T && T.apply(this, arguments);
        });
      };
    }
    function f(m) {
      return m && function(_, y, b) {
        try {
          return m.call(a, _, y, b);
        } catch (T) {
          if (!g(T)) throw T;
        }
      };
    }
    function h(m) {
      return m && function(_, y, b) {
        typeof y == "function" && (b = y, y = null);
        function T(x, k) {
          k && (k.uid < 0 && (k.uid += 4294967296), k.gid < 0 && (k.gid += 4294967296)), b && b.apply(this, arguments);
        }
        return y ? m.call(a, _, y, T) : m.call(a, _, T);
      };
    }
    function p(m) {
      return m && function(_, y) {
        var b = y ? m.call(a, _, y) : m.call(a, _);
        return b && (b.uid < 0 && (b.uid += 4294967296), b.gid < 0 && (b.gid += 4294967296)), b;
      };
    }
    function g(m) {
      if (!m || m.code === "ENOSYS")
        return !0;
      var _ = !process.getuid || process.getuid() !== 0;
      return !!(_ && (m.code === "EINVAL" || m.code === "EPERM"));
    }
  }
  return ad;
}
var od, xg;
function lI() {
  if (xg) return od;
  xg = 1;
  var e = eI.Stream;
  od = t;
  function t(n) {
    return {
      ReadStream: r,
      WriteStream: s
    };
    function r(i, a) {
      if (!(this instanceof r)) return new r(i, a);
      e.call(this);
      var o = this;
      this.path = i, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, a = a || {};
      for (var u = Object.keys(a), c = 0, l = u.length; c < l; c++) {
        var d = u[c];
        this[d] = a[d];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          o._read();
        });
        return;
      }
      n.open(this.path, this.flags, this.mode, function(f, h) {
        if (f) {
          o.emit("error", f), o.readable = !1;
          return;
        }
        o.fd = h, o.emit("open", h), o._read();
      });
    }
    function s(i, a) {
      if (!(this instanceof s)) return new s(i, a);
      e.call(this), this.path = i, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, a = a || {};
      for (var o = Object.keys(a), u = 0, c = o.length; u < c; u++) {
        var l = o[u];
        this[l] = a[l];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = n.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return od;
}
var ud, Eg;
function dI() {
  if (Eg) return ud;
  Eg = 1, ud = t;
  var e = Object.getPrototypeOf || function(n) {
    return n.__proto__;
  };
  function t(n) {
    if (n === null || typeof n != "object")
      return n;
    if (n instanceof Object)
      var r = { __proto__: e(n) };
    else
      var r = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(n).forEach(function(s) {
      Object.defineProperty(r, s, Object.getOwnPropertyDescriptor(n, s));
    }), r;
  }
  return ud;
}
var Ko, kg;
function ko() {
  if (kg) return Ko;
  kg = 1;
  var e = Rb, t = cI(), n = lI(), r = dI(), s = tI, i, a;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (i = /* @__PURE__ */ Symbol.for("graceful-fs.queue"), a = /* @__PURE__ */ Symbol.for("graceful-fs.previous")) : (i = "___graceful-fs.queue", a = "___graceful-fs.previous");
  function o() {
  }
  function u(m, _) {
    Object.defineProperty(m, i, {
      get: function() {
        return _;
      }
    });
  }
  var c = o;
  if (s.debuglog ? c = s.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (c = function() {
    var m = s.format.apply(s, arguments);
    m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
  }), !e[i]) {
    var l = sd[i] || [];
    u(e, l), e.close = (function(m) {
      function _(y, b) {
        return m.call(e, y, function(T) {
          T || p(), typeof b == "function" && b.apply(this, arguments);
        });
      }
      return Object.defineProperty(_, a, {
        value: m
      }), _;
    })(e.close), e.closeSync = (function(m) {
      function _(y) {
        m.apply(e, arguments), p();
      }
      return Object.defineProperty(_, a, {
        value: m
      }), _;
    })(e.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      c(e[i]), nI.equal(e[i].length, 0);
    });
  }
  sd[i] || u(sd, e[i]), Ko = d(r(e)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !e.__patched && (Ko = d(e), e.__patched = !0);
  function d(m) {
    t(m), m.gracefulify = d, m.createReadStream = Te, m.createWriteStream = me;
    var _ = m.readFile;
    m.readFile = y;
    function y(z, v, w) {
      return typeof v == "function" && (w = v, v = null), C(z, v, w);
      function C(E, ae, ce, le) {
        return _(E, ae, function(fe) {
          fe && (fe.code === "EMFILE" || fe.code === "ENFILE") ? f([C, [E, ae, ce], fe, le || Date.now(), Date.now()]) : typeof ce == "function" && ce.apply(this, arguments);
        });
      }
    }
    var b = m.writeFile;
    m.writeFile = T;
    function T(z, v, w, C) {
      return typeof w == "function" && (C = w, w = null), E(z, v, w, C);
      function E(ae, ce, le, fe, Ae) {
        return b(ae, ce, le, function(Oe) {
          Oe && (Oe.code === "EMFILE" || Oe.code === "ENFILE") ? f([E, [ae, ce, le, fe], Oe, Ae || Date.now(), Date.now()]) : typeof fe == "function" && fe.apply(this, arguments);
        });
      }
    }
    var x = m.appendFile;
    x && (m.appendFile = k);
    function k(z, v, w, C) {
      return typeof w == "function" && (C = w, w = null), E(z, v, w, C);
      function E(ae, ce, le, fe, Ae) {
        return x(ae, ce, le, function(Oe) {
          Oe && (Oe.code === "EMFILE" || Oe.code === "ENFILE") ? f([E, [ae, ce, le, fe], Oe, Ae || Date.now(), Date.now()]) : typeof fe == "function" && fe.apply(this, arguments);
        });
      }
    }
    var O = m.copyFile;
    O && (m.copyFile = S);
    function S(z, v, w, C) {
      return typeof w == "function" && (C = w, w = 0), E(z, v, w, C);
      function E(ae, ce, le, fe, Ae) {
        return O(ae, ce, le, function(Oe) {
          Oe && (Oe.code === "EMFILE" || Oe.code === "ENFILE") ? f([E, [ae, ce, le, fe], Oe, Ae || Date.now(), Date.now()]) : typeof fe == "function" && fe.apply(this, arguments);
        });
      }
    }
    var j = m.readdir;
    m.readdir = G;
    var U = /^v[0-5]\./;
    function G(z, v, w) {
      typeof v == "function" && (w = v, v = null);
      var C = U.test(process.version) ? function(ce, le, fe, Ae) {
        return j(ce, E(
          ce,
          le,
          fe,
          Ae
        ));
      } : function(ce, le, fe, Ae) {
        return j(ce, le, E(
          ce,
          le,
          fe,
          Ae
        ));
      };
      return C(z, v, w);
      function E(ae, ce, le, fe) {
        return function(Ae, Oe) {
          Ae && (Ae.code === "EMFILE" || Ae.code === "ENFILE") ? f([
            C,
            [ae, ce, le],
            Ae,
            fe || Date.now(),
            Date.now()
          ]) : (Oe && Oe.sort && Oe.sort(), typeof le == "function" && le.call(this, Ae, Oe));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var He = n(m);
      Z = He.ReadStream, q = He.WriteStream;
    }
    var yt = m.ReadStream;
    yt && (Z.prototype = Object.create(yt.prototype), Z.prototype.open = ee);
    var D = m.WriteStream;
    D && (q.prototype = Object.create(D.prototype), q.prototype.open = ie), Object.defineProperty(m, "ReadStream", {
      get: function() {
        return Z;
      },
      set: function(z) {
        Z = z;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(m, "WriteStream", {
      get: function() {
        return q;
      },
      set: function(z) {
        q = z;
      },
      enumerable: !0,
      configurable: !0
    });
    var N = Z;
    Object.defineProperty(m, "FileReadStream", {
      get: function() {
        return N;
      },
      set: function(z) {
        N = z;
      },
      enumerable: !0,
      configurable: !0
    });
    var L = q;
    Object.defineProperty(m, "FileWriteStream", {
      get: function() {
        return L;
      },
      set: function(z) {
        L = z;
      },
      enumerable: !0,
      configurable: !0
    });
    function Z(z, v) {
      return this instanceof Z ? (yt.apply(this, arguments), this) : Z.apply(Object.create(Z.prototype), arguments);
    }
    function ee() {
      var z = this;
      Be(z.path, z.flags, z.mode, function(v, w) {
        v ? (z.autoClose && z.destroy(), z.emit("error", v)) : (z.fd = w, z.emit("open", w), z.read());
      });
    }
    function q(z, v) {
      return this instanceof q ? (D.apply(this, arguments), this) : q.apply(Object.create(q.prototype), arguments);
    }
    function ie() {
      var z = this;
      Be(z.path, z.flags, z.mode, function(v, w) {
        v ? (z.destroy(), z.emit("error", v)) : (z.fd = w, z.emit("open", w));
      });
    }
    function Te(z, v) {
      return new m.ReadStream(z, v);
    }
    function me(z, v) {
      return new m.WriteStream(z, v);
    }
    var Re = m.open;
    m.open = Be;
    function Be(z, v, w, C) {
      return typeof w == "function" && (C = w, w = null), E(z, v, w, C);
      function E(ae, ce, le, fe, Ae) {
        return Re(ae, ce, le, function(Oe, Xe) {
          Oe && (Oe.code === "EMFILE" || Oe.code === "ENFILE") ? f([E, [ae, ce, le, fe], Oe, Ae || Date.now(), Date.now()]) : typeof fe == "function" && fe.apply(this, arguments);
        });
      }
    }
    return m;
  }
  function f(m) {
    c("ENQUEUE", m[0].name, m[1]), e[i].push(m), g();
  }
  var h;
  function p() {
    for (var m = Date.now(), _ = 0; _ < e[i].length; ++_)
      e[i][_].length > 2 && (e[i][_][3] = m, e[i][_][4] = m);
    g();
  }
  function g() {
    if (clearTimeout(h), h = void 0, e[i].length !== 0) {
      var m = e[i].shift(), _ = m[0], y = m[1], b = m[2], T = m[3], x = m[4];
      if (T === void 0)
        c("RETRY", _.name, y), _.apply(null, y);
      else if (Date.now() - T >= 6e4) {
        c("TIMEOUT", _.name, y);
        var k = y.pop();
        typeof k == "function" && k.call(null, b);
      } else {
        var O = Date.now() - x, S = Math.max(x - T, 1), j = Math.min(S * 1.2, 100);
        O >= j ? (c("RETRY", _.name, y), _.apply(null, y.concat([T]))) : e[i].push(m);
      }
      h === void 0 && (h = setTimeout(g, 0));
    }
  }
  return Ko;
}
var Og;
function Gt() {
  return Og || (Og = 1, (function(e) {
    const t = Ot().fromCallback, n = ko(), r = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "glob",
      "lchmod",
      "lchown",
      "lutimes",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((s) => typeof n[s] == "function");
    Object.assign(e, n), r.forEach((s) => {
      e[s] = t(n[s]);
    }), e.exists = function(s, i) {
      return typeof i == "function" ? n.exists(s, i) : new Promise((a) => n.exists(s, a));
    }, e.read = function(s, i, a, o, u, c) {
      return typeof c == "function" ? n.read(s, i, a, o, u, c) : new Promise((l, d) => {
        n.read(s, i, a, o, u, (f, h, p) => {
          if (f) return d(f);
          l({ bytesRead: h, buffer: p });
        });
      });
    }, e.write = function(s, i, ...a) {
      return typeof a[a.length - 1] == "function" ? n.write(s, i, ...a) : new Promise((o, u) => {
        n.write(s, i, ...a, (c, l, d) => {
          if (c) return u(c);
          o({ bytesWritten: l, buffer: d });
        });
      });
    }, e.readv = function(s, i, ...a) {
      return typeof a[a.length - 1] == "function" ? n.readv(s, i, ...a) : new Promise((o, u) => {
        n.readv(s, i, ...a, (c, l, d) => {
          if (c) return u(c);
          o({ bytesRead: l, buffers: d });
        });
      });
    }, e.writev = function(s, i, ...a) {
      return typeof a[a.length - 1] == "function" ? n.writev(s, i, ...a) : new Promise((o, u) => {
        n.writev(s, i, ...a, (c, l, d) => {
          if (c) return u(c);
          o({ bytesWritten: l, buffers: d });
        });
      });
    }, typeof n.realpath.native == "function" ? e.realpath.native = t(n.realpath.native) : process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  })(id)), id;
}
var Yo = {}, cd = {}, Ig;
function fI() {
  if (Ig) return cd;
  Ig = 1;
  const e = yn;
  return cd.checkPath = function(n) {
    if (process.platform === "win32" && /[<>:"|?*]/.test(n.replace(e.parse(n).root, ""))) {
      const s = new Error(`Path contains invalid characters: ${n}`);
      throw s.code = "EINVAL", s;
    }
  }, cd;
}
var Ag;
function hI() {
  if (Ag) return Yo;
  Ag = 1;
  const e = /* @__PURE__ */ Gt(), { checkPath: t } = /* @__PURE__ */ fI(), n = (r) => {
    const s = { mode: 511 };
    return typeof r == "number" ? r : { ...s, ...r }.mode;
  };
  return Yo.makeDir = async (r, s) => (t(r), e.mkdir(r, {
    mode: n(s),
    recursive: !0
  })), Yo.makeDirSync = (r, s) => (t(r), e.mkdirSync(r, {
    mode: n(s),
    recursive: !0
  })), Yo;
}
var ld, Cg;
function er() {
  if (Cg) return ld;
  Cg = 1;
  const e = Ot().fromPromise, { makeDir: t, makeDirSync: n } = /* @__PURE__ */ hI(), r = e(t);
  return ld = {
    mkdirs: r,
    mkdirsSync: n,
    // alias
    mkdirp: r,
    mkdirpSync: n,
    ensureDir: r,
    ensureDirSync: n
  }, ld;
}
var dd, $g;
function ks() {
  if ($g) return dd;
  $g = 1;
  const e = Ot().fromPromise, t = /* @__PURE__ */ Gt();
  function n(r) {
    return t.access(r).then(() => !0).catch(() => !1);
  }
  return dd = {
    pathExists: e(n),
    pathExistsSync: t.existsSync
  }, dd;
}
var fd, Rg;
function Pb() {
  if (Rg) return fd;
  Rg = 1;
  const e = /* @__PURE__ */ Gt(), t = Ot().fromPromise;
  async function n(s, i, a) {
    const o = await e.open(s, "r+");
    let u = null;
    try {
      await e.futimes(o, i, a);
    } finally {
      try {
        await e.close(o);
      } catch (c) {
        u = c;
      }
    }
    if (u)
      throw u;
  }
  function r(s, i, a) {
    const o = e.openSync(s, "r+");
    return e.futimesSync(o, i, a), e.closeSync(o);
  }
  return fd = {
    utimesMillis: t(n),
    utimesMillisSync: r
  }, fd;
}
var hd, Pg;
function hi() {
  if (Pg) return hd;
  Pg = 1;
  const e = /* @__PURE__ */ Gt(), t = yn, n = Ot().fromPromise;
  function r(f, h, p) {
    const g = p.dereference ? (m) => e.stat(m, { bigint: !0 }) : (m) => e.lstat(m, { bigint: !0 });
    return Promise.all([
      g(f),
      g(h).catch((m) => {
        if (m.code === "ENOENT") return null;
        throw m;
      })
    ]).then(([m, _]) => ({ srcStat: m, destStat: _ }));
  }
  function s(f, h, p) {
    let g;
    const m = p.dereference ? (y) => e.statSync(y, { bigint: !0 }) : (y) => e.lstatSync(y, { bigint: !0 }), _ = m(f);
    try {
      g = m(h);
    } catch (y) {
      if (y.code === "ENOENT") return { srcStat: _, destStat: null };
      throw y;
    }
    return { srcStat: _, destStat: g };
  }
  async function i(f, h, p, g) {
    const { srcStat: m, destStat: _ } = await r(f, h, g);
    if (_) {
      if (c(m, _)) {
        const y = t.basename(f), b = t.basename(h);
        if (p === "move" && y !== b && y.toLowerCase() === b.toLowerCase())
          return { srcStat: m, destStat: _, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (m.isDirectory() && !_.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${h}' with directory '${f}'.`);
      if (!m.isDirectory() && _.isDirectory())
        throw new Error(`Cannot overwrite directory '${h}' with non-directory '${f}'.`);
    }
    if (m.isDirectory() && l(f, h))
      throw new Error(d(f, h, p));
    return { srcStat: m, destStat: _ };
  }
  function a(f, h, p, g) {
    const { srcStat: m, destStat: _ } = s(f, h, g);
    if (_) {
      if (c(m, _)) {
        const y = t.basename(f), b = t.basename(h);
        if (p === "move" && y !== b && y.toLowerCase() === b.toLowerCase())
          return { srcStat: m, destStat: _, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (m.isDirectory() && !_.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${h}' with directory '${f}'.`);
      if (!m.isDirectory() && _.isDirectory())
        throw new Error(`Cannot overwrite directory '${h}' with non-directory '${f}'.`);
    }
    if (m.isDirectory() && l(f, h))
      throw new Error(d(f, h, p));
    return { srcStat: m, destStat: _ };
  }
  async function o(f, h, p, g) {
    const m = t.resolve(t.dirname(f)), _ = t.resolve(t.dirname(p));
    if (_ === m || _ === t.parse(_).root) return;
    let y;
    try {
      y = await e.stat(_, { bigint: !0 });
    } catch (b) {
      if (b.code === "ENOENT") return;
      throw b;
    }
    if (c(h, y))
      throw new Error(d(f, p, g));
    return o(f, h, _, g);
  }
  function u(f, h, p, g) {
    const m = t.resolve(t.dirname(f)), _ = t.resolve(t.dirname(p));
    if (_ === m || _ === t.parse(_).root) return;
    let y;
    try {
      y = e.statSync(_, { bigint: !0 });
    } catch (b) {
      if (b.code === "ENOENT") return;
      throw b;
    }
    if (c(h, y))
      throw new Error(d(f, p, g));
    return u(f, h, _, g);
  }
  function c(f, h) {
    return h.ino !== void 0 && h.dev !== void 0 && h.ino === f.ino && h.dev === f.dev;
  }
  function l(f, h) {
    const p = t.resolve(f).split(t.sep).filter((m) => m), g = t.resolve(h).split(t.sep).filter((m) => m);
    return p.every((m, _) => g[_] === m);
  }
  function d(f, h, p) {
    return `Cannot ${p} '${f}' to a subdirectory of itself, '${h}'.`;
  }
  return hd = {
    // checkPaths
    checkPaths: n(i),
    checkPathsSync: a,
    // checkParent
    checkParentPaths: n(o),
    checkParentPathsSync: u,
    // Misc
    isSrcSubdir: l,
    areIdentical: c
  }, hd;
}
var pd, Ng;
function pI() {
  if (Ng) return pd;
  Ng = 1;
  async function e(t, n) {
    const r = [];
    for await (const s of t)
      r.push(
        n(s).then(
          () => null,
          (i) => i ?? new Error("unknown error")
        )
      );
    await Promise.all(
      r.map(
        (s) => s.then((i) => {
          if (i !== null) throw i;
        })
      )
    );
  }
  return pd = {
    asyncIteratorConcurrentProcess: e
  }, pd;
}
var md, Mg;
function mI() {
  if (Mg) return md;
  Mg = 1;
  const e = /* @__PURE__ */ Gt(), t = yn, { mkdirs: n } = /* @__PURE__ */ er(), { pathExists: r } = /* @__PURE__ */ ks(), { utimesMillis: s } = /* @__PURE__ */ Pb(), i = /* @__PURE__ */ hi(), { asyncIteratorConcurrentProcess: a } = /* @__PURE__ */ pI();
  async function o(m, _, y = {}) {
    typeof y == "function" && (y = { filter: y }), y.clobber = "clobber" in y ? !!y.clobber : !0, y.overwrite = "overwrite" in y ? !!y.overwrite : y.clobber, y.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0001"
    );
    const { srcStat: b, destStat: T } = await i.checkPaths(m, _, "copy", y);
    if (await i.checkParentPaths(m, b, _, "copy"), !await u(m, _, y)) return;
    const k = t.dirname(_);
    await r(k) || await n(k), await c(T, m, _, y);
  }
  async function u(m, _, y) {
    return y.filter ? y.filter(m, _) : !0;
  }
  async function c(m, _, y, b) {
    const x = await (b.dereference ? e.stat : e.lstat)(_);
    if (x.isDirectory()) return p(x, m, _, y, b);
    if (x.isFile() || x.isCharacterDevice() || x.isBlockDevice()) return l(x, m, _, y, b);
    if (x.isSymbolicLink()) return g(m, _, y, b);
    throw x.isSocket() ? new Error(`Cannot copy a socket file: ${_}`) : x.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${_}`) : new Error(`Unknown file: ${_}`);
  }
  async function l(m, _, y, b, T) {
    if (!_) return d(m, y, b, T);
    if (T.overwrite)
      return await e.unlink(b), d(m, y, b, T);
    if (T.errorOnExist)
      throw new Error(`'${b}' already exists`);
  }
  async function d(m, _, y, b) {
    if (await e.copyFile(_, y), b.preserveTimestamps) {
      f(m.mode) && await h(y, m.mode);
      const T = await e.stat(_);
      await s(y, T.atime, T.mtime);
    }
    return e.chmod(y, m.mode);
  }
  function f(m) {
    return (m & 128) === 0;
  }
  function h(m, _) {
    return e.chmod(m, _ | 128);
  }
  async function p(m, _, y, b, T) {
    _ || await e.mkdir(b), await a(await e.opendir(y), async (x) => {
      const k = t.join(y, x.name), O = t.join(b, x.name);
      if (await u(k, O, T)) {
        const { destStat: j } = await i.checkPaths(k, O, "copy", T);
        await c(j, k, O, T);
      }
    }), _ || await e.chmod(b, m.mode);
  }
  async function g(m, _, y, b) {
    let T = await e.readlink(_);
    if (b.dereference && (T = t.resolve(process.cwd(), T)), !m)
      return e.symlink(T, y);
    let x = null;
    try {
      x = await e.readlink(y);
    } catch (k) {
      if (k.code === "EINVAL" || k.code === "UNKNOWN") return e.symlink(T, y);
      throw k;
    }
    if (b.dereference && (x = t.resolve(process.cwd(), x)), T !== x) {
      if (i.isSrcSubdir(T, x))
        throw new Error(`Cannot copy '${T}' to a subdirectory of itself, '${x}'.`);
      if (i.isSrcSubdir(x, T))
        throw new Error(`Cannot overwrite '${x}' with '${T}'.`);
    }
    return await e.unlink(y), e.symlink(T, y);
  }
  return md = o, md;
}
var gd, jg;
function gI() {
  if (jg) return gd;
  jg = 1;
  const e = ko(), t = yn, n = er().mkdirsSync, r = Pb().utimesMillisSync, s = /* @__PURE__ */ hi();
  function i(x, k, O) {
    typeof O == "function" && (O = { filter: O }), O = O || {}, O.clobber = "clobber" in O ? !!O.clobber : !0, O.overwrite = "overwrite" in O ? !!O.overwrite : O.clobber, O.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0002"
    );
    const { srcStat: S, destStat: j } = s.checkPathsSync(x, k, "copy", O);
    if (s.checkParentPathsSync(x, S, k, "copy"), O.filter && !O.filter(x, k)) return;
    const U = t.dirname(k);
    return e.existsSync(U) || n(U), a(j, x, k, O);
  }
  function a(x, k, O, S) {
    const U = (S.dereference ? e.statSync : e.lstatSync)(k);
    if (U.isDirectory()) return g(U, x, k, O, S);
    if (U.isFile() || U.isCharacterDevice() || U.isBlockDevice()) return o(U, x, k, O, S);
    if (U.isSymbolicLink()) return b(x, k, O, S);
    throw U.isSocket() ? new Error(`Cannot copy a socket file: ${k}`) : U.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${k}`) : new Error(`Unknown file: ${k}`);
  }
  function o(x, k, O, S, j) {
    return k ? u(x, O, S, j) : c(x, O, S, j);
  }
  function u(x, k, O, S) {
    if (S.overwrite)
      return e.unlinkSync(O), c(x, k, O, S);
    if (S.errorOnExist)
      throw new Error(`'${O}' already exists`);
  }
  function c(x, k, O, S) {
    return e.copyFileSync(k, O), S.preserveTimestamps && l(x.mode, k, O), h(O, x.mode);
  }
  function l(x, k, O) {
    return d(x) && f(O, x), p(k, O);
  }
  function d(x) {
    return (x & 128) === 0;
  }
  function f(x, k) {
    return h(x, k | 128);
  }
  function h(x, k) {
    return e.chmodSync(x, k);
  }
  function p(x, k) {
    const O = e.statSync(x);
    return r(k, O.atime, O.mtime);
  }
  function g(x, k, O, S, j) {
    return k ? _(O, S, j) : m(x.mode, O, S, j);
  }
  function m(x, k, O, S) {
    return e.mkdirSync(O), _(k, O, S), h(O, x);
  }
  function _(x, k, O) {
    const S = e.opendirSync(x);
    try {
      let j;
      for (; (j = S.readSync()) !== null; )
        y(j.name, x, k, O);
    } finally {
      S.closeSync();
    }
  }
  function y(x, k, O, S) {
    const j = t.join(k, x), U = t.join(O, x);
    if (S.filter && !S.filter(j, U)) return;
    const { destStat: G } = s.checkPathsSync(j, U, "copy", S);
    return a(G, j, U, S);
  }
  function b(x, k, O, S) {
    let j = e.readlinkSync(k);
    if (S.dereference && (j = t.resolve(process.cwd(), j)), x) {
      let U;
      try {
        U = e.readlinkSync(O);
      } catch (G) {
        if (G.code === "EINVAL" || G.code === "UNKNOWN") return e.symlinkSync(j, O);
        throw G;
      }
      if (S.dereference && (U = t.resolve(process.cwd(), U)), j !== U) {
        if (s.isSrcSubdir(j, U))
          throw new Error(`Cannot copy '${j}' to a subdirectory of itself, '${U}'.`);
        if (s.isSrcSubdir(U, j))
          throw new Error(`Cannot overwrite '${U}' with '${j}'.`);
      }
      return T(j, O);
    } else
      return e.symlinkSync(j, O);
  }
  function T(x, k) {
    return e.unlinkSync(k), e.symlinkSync(x, k);
  }
  return gd = i, gd;
}
var _d, Lg;
function jp() {
  if (Lg) return _d;
  Lg = 1;
  const e = Ot().fromPromise;
  return _d = {
    copy: e(/* @__PURE__ */ mI()),
    copySync: /* @__PURE__ */ gI()
  }, _d;
}
var yd, Dg;
function al() {
  if (Dg) return yd;
  Dg = 1;
  const e = ko(), t = Ot().fromCallback;
  function n(s, i) {
    e.rm(s, { recursive: !0, force: !0 }, i);
  }
  function r(s) {
    e.rmSync(s, { recursive: !0, force: !0 });
  }
  return yd = {
    remove: t(n),
    removeSync: r
  }, yd;
}
var wd, Ug;
function _I() {
  if (Ug) return wd;
  Ug = 1;
  const e = Ot().fromPromise, t = /* @__PURE__ */ Gt(), n = yn, r = /* @__PURE__ */ er(), s = /* @__PURE__ */ al(), i = e(async function(u) {
    let c;
    try {
      c = await t.readdir(u);
    } catch {
      return r.mkdirs(u);
    }
    return Promise.all(c.map((l) => s.remove(n.join(u, l))));
  });
  function a(o) {
    let u;
    try {
      u = t.readdirSync(o);
    } catch {
      return r.mkdirsSync(o);
    }
    u.forEach((c) => {
      c = n.join(o, c), s.removeSync(c);
    });
  }
  return wd = {
    emptyDirSync: a,
    emptydirSync: a,
    emptyDir: i,
    emptydir: i
  }, wd;
}
var vd, Fg;
function yI() {
  if (Fg) return vd;
  Fg = 1;
  const e = Ot().fromPromise, t = yn, n = /* @__PURE__ */ Gt(), r = /* @__PURE__ */ er();
  async function s(a) {
    let o;
    try {
      o = await n.stat(a);
    } catch {
    }
    if (o && o.isFile()) return;
    const u = t.dirname(a);
    let c = null;
    try {
      c = await n.stat(u);
    } catch (l) {
      if (l.code === "ENOENT") {
        await r.mkdirs(u), await n.writeFile(a, "");
        return;
      } else
        throw l;
    }
    c.isDirectory() ? await n.writeFile(a, "") : await n.readdir(u);
  }
  function i(a) {
    let o;
    try {
      o = n.statSync(a);
    } catch {
    }
    if (o && o.isFile()) return;
    const u = t.dirname(a);
    try {
      n.statSync(u).isDirectory() || n.readdirSync(u);
    } catch (c) {
      if (c && c.code === "ENOENT") r.mkdirsSync(u);
      else throw c;
    }
    n.writeFileSync(a, "");
  }
  return vd = {
    createFile: e(s),
    createFileSync: i
  }, vd;
}
var bd, zg;
function wI() {
  if (zg) return bd;
  zg = 1;
  const e = Ot().fromPromise, t = yn, n = /* @__PURE__ */ Gt(), r = /* @__PURE__ */ er(), { pathExists: s } = /* @__PURE__ */ ks(), { areIdentical: i } = /* @__PURE__ */ hi();
  async function a(u, c) {
    let l;
    try {
      l = await n.lstat(c);
    } catch {
    }
    let d;
    try {
      d = await n.lstat(u);
    } catch (p) {
      throw p.message = p.message.replace("lstat", "ensureLink"), p;
    }
    if (l && i(d, l)) return;
    const f = t.dirname(c);
    await s(f) || await r.mkdirs(f), await n.link(u, c);
  }
  function o(u, c) {
    let l;
    try {
      l = n.lstatSync(c);
    } catch {
    }
    try {
      const h = n.lstatSync(u);
      if (l && i(h, l)) return;
    } catch (h) {
      throw h.message = h.message.replace("lstat", "ensureLink"), h;
    }
    const d = t.dirname(c);
    return n.existsSync(d) || r.mkdirsSync(d), n.linkSync(u, c);
  }
  return bd = {
    createLink: e(a),
    createLinkSync: o
  }, bd;
}
var Sd, qg;
function vI() {
  if (qg) return Sd;
  qg = 1;
  const e = yn, t = /* @__PURE__ */ Gt(), { pathExists: n } = /* @__PURE__ */ ks(), r = Ot().fromPromise;
  async function s(a, o) {
    if (e.isAbsolute(a)) {
      try {
        await t.lstat(a);
      } catch (d) {
        throw d.message = d.message.replace("lstat", "ensureSymlink"), d;
      }
      return {
        toCwd: a,
        toDst: a
      };
    }
    const u = e.dirname(o), c = e.join(u, a);
    if (await n(c))
      return {
        toCwd: c,
        toDst: a
      };
    try {
      await t.lstat(a);
    } catch (d) {
      throw d.message = d.message.replace("lstat", "ensureSymlink"), d;
    }
    return {
      toCwd: a,
      toDst: e.relative(u, a)
    };
  }
  function i(a, o) {
    if (e.isAbsolute(a)) {
      if (!t.existsSync(a)) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: a,
        toDst: a
      };
    }
    const u = e.dirname(o), c = e.join(u, a);
    if (t.existsSync(c))
      return {
        toCwd: c,
        toDst: a
      };
    if (!t.existsSync(a)) throw new Error("relative srcpath does not exist");
    return {
      toCwd: a,
      toDst: e.relative(u, a)
    };
  }
  return Sd = {
    symlinkPaths: r(s),
    symlinkPathsSync: i
  }, Sd;
}
var Td, Bg;
function bI() {
  if (Bg) return Td;
  Bg = 1;
  const e = /* @__PURE__ */ Gt(), t = Ot().fromPromise;
  async function n(s, i) {
    if (i) return i;
    let a;
    try {
      a = await e.lstat(s);
    } catch {
      return "file";
    }
    return a && a.isDirectory() ? "dir" : "file";
  }
  function r(s, i) {
    if (i) return i;
    let a;
    try {
      a = e.lstatSync(s);
    } catch {
      return "file";
    }
    return a && a.isDirectory() ? "dir" : "file";
  }
  return Td = {
    symlinkType: t(n),
    symlinkTypeSync: r
  }, Td;
}
var xd, Zg;
function SI() {
  if (Zg) return xd;
  Zg = 1;
  const e = Ot().fromPromise, t = yn, n = /* @__PURE__ */ Gt(), { mkdirs: r, mkdirsSync: s } = /* @__PURE__ */ er(), { symlinkPaths: i, symlinkPathsSync: a } = /* @__PURE__ */ vI(), { symlinkType: o, symlinkTypeSync: u } = /* @__PURE__ */ bI(), { pathExists: c } = /* @__PURE__ */ ks(), { areIdentical: l } = /* @__PURE__ */ hi();
  async function d(h, p, g) {
    let m;
    try {
      m = await n.lstat(p);
    } catch {
    }
    if (m && m.isSymbolicLink()) {
      const [T, x] = await Promise.all([
        n.stat(h),
        n.stat(p)
      ]);
      if (l(T, x)) return;
    }
    const _ = await i(h, p);
    h = _.toDst;
    const y = await o(_.toCwd, g), b = t.dirname(p);
    return await c(b) || await r(b), n.symlink(h, p, y);
  }
  function f(h, p, g) {
    let m;
    try {
      m = n.lstatSync(p);
    } catch {
    }
    if (m && m.isSymbolicLink()) {
      const T = n.statSync(h), x = n.statSync(p);
      if (l(T, x)) return;
    }
    const _ = a(h, p);
    h = _.toDst, g = u(_.toCwd, g);
    const y = t.dirname(p);
    return n.existsSync(y) || s(y), n.symlinkSync(h, p, g);
  }
  return xd = {
    createSymlink: e(d),
    createSymlinkSync: f
  }, xd;
}
var Ed, Vg;
function TI() {
  if (Vg) return Ed;
  Vg = 1;
  const { createFile: e, createFileSync: t } = /* @__PURE__ */ yI(), { createLink: n, createLinkSync: r } = /* @__PURE__ */ wI(), { createSymlink: s, createSymlinkSync: i } = /* @__PURE__ */ SI();
  return Ed = {
    // file
    createFile: e,
    createFileSync: t,
    ensureFile: e,
    ensureFileSync: t,
    // link
    createLink: n,
    createLinkSync: r,
    ensureLink: n,
    ensureLinkSync: r,
    // symlink
    createSymlink: s,
    createSymlinkSync: i,
    ensureSymlink: s,
    ensureSymlinkSync: i
  }, Ed;
}
var kd, Hg;
function Lp() {
  if (Hg) return kd;
  Hg = 1;
  function e(n, { EOL: r = `
`, finalEOL: s = !0, replacer: i = null, spaces: a } = {}) {
    const o = s ? r : "";
    return JSON.stringify(n, i, a).replace(/\n/g, r) + o;
  }
  function t(n) {
    return Buffer.isBuffer(n) && (n = n.toString("utf8")), n.replace(/^\uFEFF/, "");
  }
  return kd = { stringify: e, stripBom: t }, kd;
}
var Od, Gg;
function xI() {
  if (Gg) return Od;
  Gg = 1;
  let e;
  try {
    e = ko();
  } catch {
    e = Rb;
  }
  const t = Ot(), { stringify: n, stripBom: r } = Lp();
  async function s(l, d = {}) {
    typeof d == "string" && (d = { encoding: d });
    const f = d.fs || e, h = "throws" in d ? d.throws : !0;
    let p = await t.fromCallback(f.readFile)(l, d);
    p = r(p);
    let g;
    try {
      g = JSON.parse(p, d ? d.reviver : null);
    } catch (m) {
      if (h)
        throw m.message = `${l}: ${m.message}`, m;
      return null;
    }
    return g;
  }
  const i = t.fromPromise(s);
  function a(l, d = {}) {
    typeof d == "string" && (d = { encoding: d });
    const f = d.fs || e, h = "throws" in d ? d.throws : !0;
    try {
      let p = f.readFileSync(l, d);
      return p = r(p), JSON.parse(p, d.reviver);
    } catch (p) {
      if (h)
        throw p.message = `${l}: ${p.message}`, p;
      return null;
    }
  }
  async function o(l, d, f = {}) {
    const h = f.fs || e, p = n(d, f);
    await t.fromCallback(h.writeFile)(l, p, f);
  }
  const u = t.fromPromise(o);
  function c(l, d, f = {}) {
    const h = f.fs || e, p = n(d, f);
    return h.writeFileSync(l, p, f);
  }
  return Od = {
    readFile: i,
    readFileSync: a,
    writeFile: u,
    writeFileSync: c
  }, Od;
}
var Id, Wg;
function EI() {
  if (Wg) return Id;
  Wg = 1;
  const e = xI();
  return Id = {
    // jsonfile exports
    readJson: e.readFile,
    readJsonSync: e.readFileSync,
    writeJson: e.writeFile,
    writeJsonSync: e.writeFileSync
  }, Id;
}
var Ad, Jg;
function Dp() {
  if (Jg) return Ad;
  Jg = 1;
  const e = Ot().fromPromise, t = /* @__PURE__ */ Gt(), n = yn, r = /* @__PURE__ */ er(), s = ks().pathExists;
  async function i(o, u, c = "utf-8") {
    const l = n.dirname(o);
    return await s(l) || await r.mkdirs(l), t.writeFile(o, u, c);
  }
  function a(o, ...u) {
    const c = n.dirname(o);
    t.existsSync(c) || r.mkdirsSync(c), t.writeFileSync(o, ...u);
  }
  return Ad = {
    outputFile: e(i),
    outputFileSync: a
  }, Ad;
}
var Cd, Kg;
function kI() {
  if (Kg) return Cd;
  Kg = 1;
  const { stringify: e } = Lp(), { outputFile: t } = /* @__PURE__ */ Dp();
  async function n(r, s, i = {}) {
    const a = e(s, i);
    await t(r, a, i);
  }
  return Cd = n, Cd;
}
var $d, Yg;
function OI() {
  if (Yg) return $d;
  Yg = 1;
  const { stringify: e } = Lp(), { outputFileSync: t } = /* @__PURE__ */ Dp();
  function n(r, s, i) {
    const a = e(s, i);
    t(r, a, i);
  }
  return $d = n, $d;
}
var Rd, Xg;
function II() {
  if (Xg) return Rd;
  Xg = 1;
  const e = Ot().fromPromise, t = /* @__PURE__ */ EI();
  return t.outputJson = e(/* @__PURE__ */ kI()), t.outputJsonSync = /* @__PURE__ */ OI(), t.outputJSON = t.outputJson, t.outputJSONSync = t.outputJsonSync, t.writeJSON = t.writeJson, t.writeJSONSync = t.writeJsonSync, t.readJSON = t.readJson, t.readJSONSync = t.readJsonSync, Rd = t, Rd;
}
var Pd, Qg;
function AI() {
  if (Qg) return Pd;
  Qg = 1;
  const e = /* @__PURE__ */ Gt(), t = yn, { copy: n } = /* @__PURE__ */ jp(), { remove: r } = /* @__PURE__ */ al(), { mkdirp: s } = /* @__PURE__ */ er(), { pathExists: i } = /* @__PURE__ */ ks(), a = /* @__PURE__ */ hi();
  async function o(l, d, f = {}) {
    const h = f.overwrite || f.clobber || !1, { srcStat: p, isChangingCase: g = !1 } = await a.checkPaths(l, d, "move", f);
    await a.checkParentPaths(l, p, d, "move");
    const m = t.dirname(d);
    return t.parse(m).root !== m && await s(m), u(l, d, h, g);
  }
  async function u(l, d, f, h) {
    if (!h) {
      if (f)
        await r(d);
      else if (await i(d))
        throw new Error("dest already exists.");
    }
    try {
      await e.rename(l, d);
    } catch (p) {
      if (p.code !== "EXDEV")
        throw p;
      await c(l, d, f);
    }
  }
  async function c(l, d, f) {
    return await n(l, d, {
      overwrite: f,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), r(l);
  }
  return Pd = o, Pd;
}
var Nd, e_;
function CI() {
  if (e_) return Nd;
  e_ = 1;
  const e = ko(), t = yn, n = jp().copySync, r = al().removeSync, s = er().mkdirpSync, i = /* @__PURE__ */ hi();
  function a(d, f, h) {
    h = h || {};
    const p = h.overwrite || h.clobber || !1, { srcStat: g, isChangingCase: m = !1 } = i.checkPathsSync(d, f, "move", h);
    return i.checkParentPathsSync(d, g, f, "move"), o(f) || s(t.dirname(f)), u(d, f, p, m);
  }
  function o(d) {
    const f = t.dirname(d);
    return t.parse(f).root === f;
  }
  function u(d, f, h, p) {
    if (p) return c(d, f, h);
    if (h)
      return r(f), c(d, f, h);
    if (e.existsSync(f)) throw new Error("dest already exists.");
    return c(d, f, h);
  }
  function c(d, f, h) {
    try {
      e.renameSync(d, f);
    } catch (p) {
      if (p.code !== "EXDEV") throw p;
      return l(d, f, h);
    }
  }
  function l(d, f, h) {
    return n(d, f, {
      overwrite: h,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), r(d);
  }
  return Nd = a, Nd;
}
var Md, t_;
function $I() {
  if (t_) return Md;
  t_ = 1;
  const e = Ot().fromPromise;
  return Md = {
    move: e(/* @__PURE__ */ AI()),
    moveSync: /* @__PURE__ */ CI()
  }, Md;
}
var jd, n_;
function RI() {
  return n_ || (n_ = 1, jd = {
    // Export promiseified graceful-fs:
    .../* @__PURE__ */ Gt(),
    // Export extra methods:
    .../* @__PURE__ */ jp(),
    .../* @__PURE__ */ _I(),
    .../* @__PURE__ */ TI(),
    .../* @__PURE__ */ II(),
    .../* @__PURE__ */ er(),
    .../* @__PURE__ */ $I(),
    .../* @__PURE__ */ Dp(),
    .../* @__PURE__ */ ks(),
    .../* @__PURE__ */ al()
  }), jd;
}
var PI = /* @__PURE__ */ RI();
const Tt = /* @__PURE__ */ Zr(PI), wt = [];
for (let e = 0; e < 256; ++e)
  wt.push((e + 256).toString(16).slice(1));
function NI(e, t = 0) {
  return (wt[e[t + 0]] + wt[e[t + 1]] + wt[e[t + 2]] + wt[e[t + 3]] + "-" + wt[e[t + 4]] + wt[e[t + 5]] + "-" + wt[e[t + 6]] + wt[e[t + 7]] + "-" + wt[e[t + 8]] + wt[e[t + 9]] + "-" + wt[e[t + 10]] + wt[e[t + 11]] + wt[e[t + 12]] + wt[e[t + 13]] + wt[e[t + 14]] + wt[e[t + 15]]).toLowerCase();
}
const Qu = new Uint8Array(256);
let Xo = Qu.length;
function MI() {
  return Xo > Qu.length - 16 && (sI(Qu), Xo = 0), Qu.slice(Xo, Xo += 16);
}
const r_ = { randomUUID: iI };
function jI(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? MI();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, NI(r);
}
function LI(e, t, n) {
  return r_.randomUUID && !e ? r_.randomUUID() : jI(e);
}
class DI {
  projectRoot;
  backupDir;
  constructor(t) {
    this.projectRoot = t, this.backupDir = tt.join(t, ".agent_workspace", "backups");
  }
  async initialize() {
    await Tt.ensureDir(this.backupDir);
  }
  /**
   * Writes content to a file, creating a backup of the original if it exists.
   */
  async writeSafe(t, n) {
    const r = tt.join(this.projectRoot, t);
    if (await Tt.pathExists(r)) {
      const s = tt.basename(t), a = `${Date.now()}_${LI()}_${s}`;
      await Tt.copy(r, tt.join(this.backupDir, a));
    } else
      await Tt.ensureDir(tt.dirname(r));
    return await Tt.writeFile(r, n, "utf-8"), r;
  }
  async readFile(t) {
    return Tt.readFile(tt.join(this.projectRoot, t), "utf-8");
  }
  async listFiles(t) {
    const n = tt.join(this.projectRoot, t);
    return await Tt.pathExists(n) ? Tt.readdir(n) : [];
  }
}
function Qo(e, t) {
  return e.lc_error_code = t, e.message = `${e.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${t}/
`, e;
}
function de(e, t, n, r, s) {
  if (typeof t == "function" ? e !== t || !0 : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
}
function I(e, t, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}
let Nb = function() {
  const { crypto: e } = globalThis;
  if (e?.randomUUID)
    return Nb = e.randomUUID.bind(e), e.randomUUID();
  const t = new Uint8Array(1), n = e ? () => e.getRandomValues(t)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (r) => (+r ^ n() & 15 >> +r / 4).toString(16));
};
function kh(e) {
  return typeof e == "object" && e !== null && // Spec-compliant fetch implementations
  ("name" in e && e.name === "AbortError" || // Expo fetch
  "message" in e && String(e.message).includes("FetchRequestCanceledException"));
}
const Oh = (e) => {
  if (e instanceof Error)
    return e;
  if (typeof e == "object" && e !== null) {
    try {
      if (Object.prototype.toString.call(e) === "[object Error]") {
        const t = new Error(e.message, e.cause ? { cause: e.cause } : {});
        return e.stack && (t.stack = e.stack), e.cause && !t.cause && (t.cause = e.cause), e.name && (t.name = e.name), t;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(e));
    } catch {
    }
  }
  return new Error(e);
};
class ue extends Error {
}
let Ht = class Ih extends ue {
  constructor(t, n, r, s) {
    super(`${Ih.makeMessage(t, n, r)}`), this.status = t, this.headers = s, this.requestID = s?.get("x-request-id"), this.error = n;
    const i = n;
    this.code = i?.code, this.param = i?.param, this.type = i?.type;
  }
  static makeMessage(t, n, r) {
    const s = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : r;
    return t && s ? `${t} ${s}` : t ? `${t} status code (no body)` : s || "(no status code or body)";
  }
  static generate(t, n, r, s) {
    if (!t || !s)
      return new ol({ message: r, cause: Oh(n) });
    const i = n?.error;
    return t === 400 ? new Mb(t, i, r, s) : t === 401 ? new jb(t, i, r, s) : t === 403 ? new Lb(t, i, r, s) : t === 404 ? new Db(t, i, r, s) : t === 409 ? new Ub(t, i, r, s) : t === 422 ? new Fb(t, i, r, s) : t === 429 ? new zb(t, i, r, s) : t >= 500 ? new qb(t, i, r, s) : new Ih(t, i, r, s);
  }
}, an = class extends Ht {
  constructor({ message: t } = {}) {
    super(void 0, void 0, t || "Request was aborted.", void 0);
  }
}, ol = class extends Ht {
  constructor({ message: t, cause: n }) {
    super(void 0, void 0, t || "Connection error.", void 0), n && (this.cause = n);
  }
}, ul = class extends ol {
  constructor({ message: t } = {}) {
    super({ message: t ?? "Request timed out." });
  }
}, Mb = class extends Ht {
}, jb = class extends Ht {
}, Lb = class extends Ht {
}, Db = class extends Ht {
}, Ub = class extends Ht {
}, Fb = class extends Ht {
}, zb = class extends Ht {
}, qb = class extends Ht {
};
class Bb extends ue {
  constructor() {
    super("Could not parse response content as the length limit was reached");
  }
}
class Zb extends ue {
  constructor() {
    super("Could not parse response content as the request was rejected by the content filter");
  }
}
class Ra extends Error {
  constructor(t) {
    super(t);
  }
}
const UI = /^[a-z][a-z0-9+.-]*:/i, FI = (e) => UI.test(e);
let qt = (e) => (qt = Array.isArray, qt(e)), s_ = qt;
function Vb(e) {
  return typeof e != "object" ? {} : e ?? {};
}
function zI(e) {
  if (!e)
    return !0;
  for (const t in e)
    return !1;
  return !0;
}
function qI(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Ld(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
const BI = (e, t) => {
  if (typeof t != "number" || !Number.isInteger(t))
    throw new ue(`${e} must be an integer`);
  if (t < 0)
    throw new ue(`${e} must be a positive integer`);
  return t;
}, ZI = (e) => {
  try {
    return JSON.parse(e);
  } catch {
    return;
  }
}, Oo = (e) => new Promise((t) => setTimeout(t, e)), qs = "6.16.0", VI = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function HI() {
  return typeof Deno < "u" && Deno.build != null ? "deno" : typeof EdgeRuntime < "u" ? "edge" : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]" ? "node" : "unknown";
}
const GI = () => {
  const e = HI();
  if (e === "deno")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": qs,
      "X-Stainless-OS": a_(Deno.build.os),
      "X-Stainless-Arch": i_(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": qs,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  if (e === "node")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": qs,
      "X-Stainless-OS": a_(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": i_(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  const t = WI();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": qs,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": qs,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function WI() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const e = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: t, pattern: n } of e) {
    const r = n.exec(navigator.userAgent);
    if (r) {
      const s = r[1] || 0, i = r[2] || 0, a = r[3] || 0;
      return { browser: t, version: `${s}.${i}.${a}` };
    }
  }
  return null;
}
const i_ = (e) => e === "x32" ? "x32" : e === "x86_64" || e === "x64" ? "x64" : e === "arm" ? "arm" : e === "aarch64" || e === "arm64" ? "arm64" : e ? `other:${e}` : "unknown", a_ = (e) => (e = e.toLowerCase(), e.includes("ios") ? "iOS" : e === "android" ? "Android" : e === "darwin" ? "MacOS" : e === "win32" ? "Windows" : e === "freebsd" ? "FreeBSD" : e === "openbsd" ? "OpenBSD" : e === "linux" ? "Linux" : e ? `Other:${e}` : "Unknown");
let o_;
const JI = () => o_ ?? (o_ = GI());
function KI() {
  if (typeof fetch < "u")
    return fetch;
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function Hb(...e) {
  const t = globalThis.ReadableStream;
  if (typeof t > "u")
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  return new t(...e);
}
function Gb(e) {
  let t = Symbol.asyncIterator in e ? e[Symbol.asyncIterator]() : e[Symbol.iterator]();
  return Hb({
    start() {
    },
    async pull(n) {
      const { done: r, value: s } = await t.next();
      r ? n.close() : n.enqueue(s);
    },
    async cancel() {
      await t.return?.();
    }
  });
}
function Wb(e) {
  if (e[Symbol.asyncIterator])
    return e;
  const t = e.getReader();
  return {
    async next() {
      try {
        const n = await t.read();
        return n?.done && t.releaseLock(), n;
      } catch (n) {
        throw t.releaseLock(), n;
      }
    },
    async return() {
      const n = t.cancel();
      return t.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function YI(e) {
  if (e === null || typeof e != "object")
    return;
  if (e[Symbol.asyncIterator]) {
    await e[Symbol.asyncIterator]().return?.();
    return;
  }
  const t = e.getReader(), n = t.cancel();
  t.releaseLock(), await n;
}
const XI = ({ headers: e, body: t }) => ({
  bodyHeaders: {
    "content-type": "application/json"
  },
  body: JSON.stringify(t)
}), Jb = "RFC3986", Kb = (e) => String(e), u_ = {
  RFC1738: (e) => String(e).replace(/%20/g, "+"),
  RFC3986: Kb
}, QI = "RFC1738";
let Ah = (e, t) => (Ah = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), Ah(e, t));
const qn = /* @__PURE__ */ (() => {
  const e = [];
  for (let t = 0; t < 256; ++t)
    e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
  return e;
})(), Dd = 1024, e1 = (e, t, n, r, s) => {
  if (e.length === 0)
    return e;
  let i = e;
  if (typeof e == "symbol" ? i = Symbol.prototype.toString.call(e) : typeof e != "string" && (i = String(e)), n === "iso-8859-1")
    return escape(i).replace(/%u[0-9a-f]{4}/gi, function(o) {
      return "%26%23" + parseInt(o.slice(2), 16) + "%3B";
    });
  let a = "";
  for (let o = 0; o < i.length; o += Dd) {
    const u = i.length >= Dd ? i.slice(o, o + Dd) : i, c = [];
    for (let l = 0; l < u.length; ++l) {
      let d = u.charCodeAt(l);
      if (d === 45 || // -
      d === 46 || // .
      d === 95 || // _
      d === 126 || // ~
      d >= 48 && d <= 57 || // 0-9
      d >= 65 && d <= 90 || // a-z
      d >= 97 && d <= 122 || // A-Z
      s === QI && (d === 40 || d === 41)) {
        c[c.length] = u.charAt(l);
        continue;
      }
      if (d < 128) {
        c[c.length] = qn[d];
        continue;
      }
      if (d < 2048) {
        c[c.length] = qn[192 | d >> 6] + qn[128 | d & 63];
        continue;
      }
      if (d < 55296 || d >= 57344) {
        c[c.length] = qn[224 | d >> 12] + qn[128 | d >> 6 & 63] + qn[128 | d & 63];
        continue;
      }
      l += 1, d = 65536 + ((d & 1023) << 10 | u.charCodeAt(l) & 1023), c[c.length] = qn[240 | d >> 18] + qn[128 | d >> 12 & 63] + qn[128 | d >> 6 & 63] + qn[128 | d & 63];
    }
    a += c.join("");
  }
  return a;
};
function t1(e) {
  return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}
function c_(e, t) {
  if (qt(e)) {
    const n = [];
    for (let r = 0; r < e.length; r += 1)
      n.push(t(e[r]));
    return n;
  }
  return t(e);
}
const Yb = {
  brackets(e) {
    return String(e) + "[]";
  },
  comma: "comma",
  indices(e, t) {
    return String(e) + "[" + t + "]";
  },
  repeat(e) {
    return String(e);
  }
}, Xb = function(e, t) {
  Array.prototype.push.apply(e, qt(t) ? t : [t]);
};
let l_;
const dt = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: e1,
  encodeValuesOnly: !1,
  format: Jb,
  formatter: Kb,
  /** @deprecated */
  indices: !1,
  serializeDate(e) {
    return (l_ ?? (l_ = Function.prototype.call.bind(Date.prototype.toISOString)))(e);
  },
  skipNulls: !1,
  strictNullHandling: !1
};
function n1(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
}
const Ud = {};
function Qb(e, t, n, r, s, i, a, o, u, c, l, d, f, h, p, g, m, _) {
  let y = e, b = _, T = 0, x = !1;
  for (; (b = b.get(Ud)) !== void 0 && !x; ) {
    const U = b.get(e);
    if (T += 1, typeof U < "u") {
      if (U === T)
        throw new RangeError("Cyclic object value");
      x = !0;
    }
    typeof b.get(Ud) > "u" && (T = 0);
  }
  if (typeof c == "function" ? y = c(t, y) : y instanceof Date ? y = f?.(y) : n === "comma" && qt(y) && (y = c_(y, function(U) {
    return U instanceof Date ? f?.(U) : U;
  })), y === null) {
    if (i)
      return u && !g ? (
        // @ts-expect-error
        u(t, dt.encoder, m, "key", h)
      ) : t;
    y = "";
  }
  if (n1(y) || t1(y)) {
    if (u) {
      const U = g ? t : u(t, dt.encoder, m, "key", h);
      return [
        p?.(U) + "=" + // @ts-expect-error
        p?.(u(y, dt.encoder, m, "value", h))
      ];
    }
    return [p?.(t) + "=" + p?.(String(y))];
  }
  const k = [];
  if (typeof y > "u")
    return k;
  let O;
  if (n === "comma" && qt(y))
    g && u && (y = c_(y, u)), O = [{ value: y.length > 0 ? y.join(",") || null : void 0 }];
  else if (qt(c))
    O = c;
  else {
    const U = Object.keys(y);
    O = l ? U.sort(l) : U;
  }
  const S = o ? String(t).replace(/\./g, "%2E") : String(t), j = r && qt(y) && y.length === 1 ? S + "[]" : S;
  if (s && qt(y) && y.length === 0)
    return j + "[]";
  for (let U = 0; U < O.length; ++U) {
    const G = O[U], He = (
      // @ts-ignore
      typeof G == "object" && typeof G.value < "u" ? G.value : y[G]
    );
    if (a && He === null)
      continue;
    const yt = d && o ? G.replace(/\./g, "%2E") : G, D = qt(y) ? typeof n == "function" ? n(j, yt) : j : j + (d ? "." + yt : "[" + yt + "]");
    _.set(e, T);
    const N = /* @__PURE__ */ new WeakMap();
    N.set(Ud, _), Xb(k, Qb(
      He,
      D,
      n,
      r,
      s,
      i,
      a,
      o,
      // @ts-ignore
      n === "comma" && g && qt(y) ? null : u,
      c,
      l,
      d,
      f,
      h,
      p,
      g,
      m,
      N
    ));
  }
  return k;
}
function r1(e = dt) {
  if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  const t = e.charset || dt.charset;
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  let n = Jb;
  if (typeof e.format < "u") {
    if (!Ah(u_, e.format))
      throw new TypeError("Unknown format option provided.");
    n = e.format;
  }
  const r = u_[n];
  let s = dt.filter;
  (typeof e.filter == "function" || qt(e.filter)) && (s = e.filter);
  let i;
  if (e.arrayFormat && e.arrayFormat in Yb ? i = e.arrayFormat : "indices" in e ? i = e.indices ? "indices" : "repeat" : i = dt.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  const a = typeof e.allowDots > "u" ? e.encodeDotInKeys ? !0 : dt.allowDots : !!e.allowDots;
  return {
    addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : dt.addQueryPrefix,
    // @ts-ignore
    allowDots: a,
    allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : dt.allowEmptyArrays,
    arrayFormat: i,
    charset: t,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : dt.charsetSentinel,
    commaRoundTrip: !!e.commaRoundTrip,
    delimiter: typeof e.delimiter > "u" ? dt.delimiter : e.delimiter,
    encode: typeof e.encode == "boolean" ? e.encode : dt.encode,
    encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : dt.encodeDotInKeys,
    encoder: typeof e.encoder == "function" ? e.encoder : dt.encoder,
    encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : dt.encodeValuesOnly,
    filter: s,
    format: n,
    formatter: r,
    serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : dt.serializeDate,
    skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : dt.skipNulls,
    // @ts-ignore
    sort: typeof e.sort == "function" ? e.sort : null,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : dt.strictNullHandling
  };
}
function s1(e, t = {}) {
  let n = e;
  const r = r1(t);
  let s, i;
  typeof r.filter == "function" ? (i = r.filter, n = i("", n)) : qt(r.filter) && (i = r.filter, s = i);
  const a = [];
  if (typeof n != "object" || n === null)
    return "";
  const o = Yb[r.arrayFormat], u = o === "comma" && r.commaRoundTrip;
  s || (s = Object.keys(n)), r.sort && s.sort(r.sort);
  const c = /* @__PURE__ */ new WeakMap();
  for (let f = 0; f < s.length; ++f) {
    const h = s[f];
    r.skipNulls && n[h] === null || Xb(a, Qb(
      n[h],
      h,
      // @ts-expect-error
      o,
      u,
      r.allowEmptyArrays,
      r.strictNullHandling,
      r.skipNulls,
      r.encodeDotInKeys,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      c
    ));
  }
  const l = a.join(r.delimiter);
  let d = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? d += "utf8=%26%2310003%3B&" : d += "utf8=%E2%9C%93&"), l.length > 0 ? d + l : "";
}
function i1(e) {
  let t = 0;
  for (const s of e)
    t += s.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const s of e)
    n.set(s, r), r += s.length;
  return n;
}
let d_;
function Up(e) {
  let t;
  return (d_ ?? (t = new globalThis.TextEncoder(), d_ = t.encode.bind(t)))(e);
}
let f_;
function h_(e) {
  let t;
  return (f_ ?? (t = new globalThis.TextDecoder(), f_ = t.decode.bind(t)))(e);
}
var Qt, en;
let cl = class {
  constructor() {
    Qt.set(this, void 0), en.set(this, void 0), de(this, Qt, new Uint8Array()), de(this, en, null);
  }
  decode(t) {
    if (t == null)
      return [];
    const n = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? Up(t) : t;
    de(this, Qt, i1([I(this, Qt, "f"), n]));
    const r = [];
    let s;
    for (; (s = a1(I(this, Qt, "f"), I(this, en, "f"))) != null; ) {
      if (s.carriage && I(this, en, "f") == null) {
        de(this, en, s.index);
        continue;
      }
      if (I(this, en, "f") != null && (s.index !== I(this, en, "f") + 1 || s.carriage)) {
        r.push(h_(I(this, Qt, "f").subarray(0, I(this, en, "f") - 1))), de(this, Qt, I(this, Qt, "f").subarray(I(this, en, "f"))), de(this, en, null);
        continue;
      }
      const i = I(this, en, "f") !== null ? s.preceding - 1 : s.preceding, a = h_(I(this, Qt, "f").subarray(0, i));
      r.push(a), de(this, Qt, I(this, Qt, "f").subarray(s.index)), de(this, en, null);
    }
    return r;
  }
  flush() {
    return I(this, Qt, "f").length ? this.decode(`
`) : [];
  }
};
Qt = /* @__PURE__ */ new WeakMap(), en = /* @__PURE__ */ new WeakMap();
cl.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
cl.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function a1(e, t) {
  for (let s = t ?? 0; s < e.length; s++) {
    if (e[s] === 10)
      return { preceding: s, index: s + 1, carriage: !1 };
    if (e[s] === 13)
      return { preceding: s, index: s + 1, carriage: !0 };
  }
  return null;
}
function o1(e) {
  for (let r = 0; r < e.length - 1; r++) {
    if (e[r] === 10 && e[r + 1] === 10 || e[r] === 13 && e[r + 1] === 13)
      return r + 2;
    if (e[r] === 13 && e[r + 1] === 10 && r + 3 < e.length && e[r + 2] === 13 && e[r + 3] === 10)
      return r + 4;
  }
  return -1;
}
const wc = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
}, p_ = (e, t, n) => {
  if (e) {
    if (qI(wc, e))
      return e;
    bt(n).warn(`${t} was set to ${JSON.stringify(e)}, expected one of ${JSON.stringify(Object.keys(wc))}`);
  }
};
function Pa() {
}
function eu(e, t, n) {
  return !t || wc[e] > wc[n] ? Pa : t[e].bind(t);
}
const u1 = {
  error: Pa,
  warn: Pa,
  info: Pa,
  debug: Pa
};
let m_ = /* @__PURE__ */ new WeakMap();
function bt(e) {
  const t = e.logger, n = e.logLevel ?? "off";
  if (!t)
    return u1;
  const r = m_.get(t);
  if (r && r[0] === n)
    return r[1];
  const s = {
    error: eu("error", t, n),
    warn: eu("warn", t, n),
    info: eu("info", t, n),
    debug: eu("debug", t, n)
  };
  return m_.set(t, [n, s]), s;
}
const rs = (e) => (e.options && (e.options = { ...e.options }, delete e.options.headers), e.headers && (e.headers = Object.fromEntries((e.headers instanceof Headers ? [...e.headers] : Object.entries(e.headers)).map(([t, n]) => [
  t,
  t.toLowerCase() === "authorization" || t.toLowerCase() === "cookie" || t.toLowerCase() === "set-cookie" ? "***" : n
]))), "retryOfRequestLogID" in e && (e.retryOfRequestLogID && (e.retryOf = e.retryOfRequestLogID), delete e.retryOfRequestLogID), e);
var xi;
let oo = class Na {
  constructor(t, n, r) {
    this.iterator = t, xi.set(this, void 0), this.controller = n, de(this, xi, r);
  }
  static fromSSEResponse(t, n, r) {
    let s = !1;
    const i = r ? bt(r) : console;
    async function* a() {
      if (s)
        throw new ue("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const u of c1(t, n))
          if (!o) {
            if (u.data.startsWith("[DONE]")) {
              o = !0;
              continue;
            }
            if (u.event === null || !u.event.startsWith("thread.")) {
              let c;
              try {
                c = JSON.parse(u.data);
              } catch (l) {
                throw i.error("Could not parse message into JSON:", u.data), i.error("From chunk:", u.raw), l;
              }
              if (c && c.error)
                throw new Ht(void 0, c.error, void 0, t.headers);
              yield c;
            } else {
              let c;
              try {
                c = JSON.parse(u.data);
              } catch (l) {
                throw console.error("Could not parse message into JSON:", u.data), console.error("From chunk:", u.raw), l;
              }
              if (u.event == "error")
                throw new Ht(void 0, c.error, c.message, void 0);
              yield { event: u.event, data: c };
            }
          }
        o = !0;
      } catch (u) {
        if (kh(u))
          return;
        throw u;
      } finally {
        o || n.abort();
      }
    }
    return new Na(a, n, r);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(t, n, r) {
    let s = !1;
    async function* i() {
      const o = new cl(), u = Wb(t);
      for await (const c of u)
        for (const l of o.decode(c))
          yield l;
      for (const c of o.flush())
        yield c;
    }
    async function* a() {
      if (s)
        throw new ue("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const u of i())
          o || u && (yield JSON.parse(u));
        o = !0;
      } catch (u) {
        if (kh(u))
          return;
        throw u;
      } finally {
        o || n.abort();
      }
    }
    return new Na(a, n, r);
  }
  [(xi = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const t = [], n = [], r = this.iterator(), s = (i) => ({
      next: () => {
        if (i.length === 0) {
          const a = r.next();
          t.push(a), n.push(a);
        }
        return i.shift();
      }
    });
    return [
      new Na(() => s(t), this.controller, I(this, xi, "f")),
      new Na(() => s(n), this.controller, I(this, xi, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const t = this;
    let n;
    return Hb({
      async start() {
        n = t[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: s, done: i } = await n.next();
          if (i)
            return r.close();
          const a = Up(JSON.stringify(s) + `
`);
          r.enqueue(a);
        } catch (s) {
          r.error(s);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
};
async function* c1(e, t) {
  if (!e.body)
    throw t.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new ue("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new ue("Attempted to iterate over a response with no body");
  const n = new d1(), r = new cl(), s = Wb(e.body);
  for await (const i of l1(s))
    for (const a of r.decode(i)) {
      const o = n.decode(a);
      o && (yield o);
    }
  for (const i of r.flush()) {
    const a = n.decode(i);
    a && (yield a);
  }
}
async function* l1(e) {
  let t = new Uint8Array();
  for await (const n of e) {
    if (n == null)
      continue;
    const r = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? Up(n) : n;
    let s = new Uint8Array(t.length + r.length);
    s.set(t), s.set(r, t.length), t = s;
    let i;
    for (; (i = o1(t)) !== -1; )
      yield t.slice(0, i), t = t.slice(i);
  }
  t.length > 0 && (yield t);
}
let d1 = class {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(t) {
    if (t.endsWith("\r") && (t = t.substring(0, t.length - 1)), !t) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(t), t.startsWith(":"))
      return null;
    let [n, r, s] = f1(t, ":");
    return s.startsWith(" ") && (s = s.substring(1)), n === "event" ? this.event = s : n === "data" && this.data.push(s), null;
  }
};
function f1(e, t) {
  const n = e.indexOf(t);
  return n !== -1 ? [e.substring(0, n), t, e.substring(n + t.length)] : [e, "", ""];
}
async function eS(e, t) {
  const { response: n, requestLogID: r, retryOfRequestLogID: s, startTime: i } = t, a = await (async () => {
    if (t.options.stream)
      return bt(e).debug("response", n.status, n.url, n.headers, n.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(n, t.controller, e) : oo.fromSSEResponse(n, t.controller, e);
    if (n.status === 204)
      return null;
    if (t.options.__binaryResponse)
      return n;
    const u = n.headers.get("content-type")?.split(";")[0]?.trim();
    if (u?.includes("application/json") || u?.endsWith("+json")) {
      const d = await n.json();
      return tS(d, n);
    }
    return await n.text();
  })();
  return bt(e).debug(`[${r}] response parsed`, rs({
    retryOfRequestLogID: s,
    url: n.url,
    status: n.status,
    body: a,
    durationMs: Date.now() - i
  })), a;
}
function tS(e, t) {
  return !e || typeof e != "object" || Array.isArray(e) ? e : Object.defineProperty(e, "_request_id", {
    value: t.headers.get("x-request-id"),
    enumerable: !1
  });
}
var Ma;
let nS = class rS extends Promise {
  constructor(t, n, r = eS) {
    super((s) => {
      s(null);
    }), this.responsePromise = n, this.parseResponse = r, Ma.set(this, void 0), de(this, Ma, t);
  }
  _thenUnwrap(t) {
    return new rS(I(this, Ma, "f"), this.responsePromise, async (n, r) => tS(t(await this.parseResponse(n, r), r), r.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((t) => t.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [t, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: t, response: n, request_id: n.headers.get("x-request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then((t) => this.parseResponse(I(this, Ma, "f"), t))), this.parsedPromise;
  }
  then(t, n) {
    return this.parse().then(t, n);
  }
  catch(t) {
    return this.parse().catch(t);
  }
  finally(t) {
    return this.parse().finally(t);
  }
};
Ma = /* @__PURE__ */ new WeakMap();
var tu;
let Fp = class {
  constructor(t, n, r, s) {
    tu.set(this, void 0), de(this, tu, t), this.options = s, this.response = n, this.body = r;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageRequestOptions() != null : !1;
  }
  async getNextPage() {
    const t = this.nextPageRequestOptions();
    if (!t)
      throw new ue("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    return await I(this, tu, "f").requestAPIList(this.constructor, t);
  }
  async *iterPages() {
    let t = this;
    for (yield t; t.hasNextPage(); )
      t = await t.getNextPage(), yield t;
  }
  async *[(tu = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const t of this.iterPages())
      for (const n of t.getPaginatedItems())
        yield n;
  }
}, h1 = class extends nS {
  constructor(t, n, r) {
    super(t, n, async (s, i) => new r(s, i.response, await eS(s, i), i.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const t = await this;
    for await (const n of t)
      yield n;
  }
}, ll = class extends Fp {
  constructor(t, n, r, s) {
    super(t, n, r, s), this.data = r.data || [], this.object = r.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
};
class at extends Fp {
  constructor(t, n, r, s) {
    super(t, n, r, s), this.data = r.data || [], this.has_more = r.has_more || !1;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    const t = this.getPaginatedItems(), n = t[t.length - 1]?.id;
    return n ? {
      ...this.options,
      query: {
        ...Vb(this.options.query),
        after: n
      }
    } : null;
  }
}
class vc extends Fp {
  constructor(t, n, r, s) {
    super(t, n, r, s), this.data = r.data || [], this.has_more = r.has_more || !1, this.last_id = r.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    const t = this.last_id;
    return t ? {
      ...this.options,
      query: {
        ...Vb(this.options.query),
        after: t
      }
    } : null;
  }
}
const sS = () => {
  if (typeof File > "u") {
    const { process: e } = globalThis, t = typeof e?.versions?.node == "string" && parseInt(e.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (t ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function Xa(e, t, n) {
  return sS(), new File(e, t ?? "unknown_file", n);
}
function ec(e) {
  return (typeof e == "object" && e !== null && ("name" in e && e.name && String(e.name) || "url" in e && e.url && String(e.url) || "filename" in e && e.filename && String(e.filename) || "path" in e && e.path && String(e.path)) || "").split(/[\\/]/).pop() || void 0;
}
const zp = (e) => e != null && typeof e == "object" && typeof e[Symbol.asyncIterator] == "function", g_ = async (e, t) => Ch(e.body) ? { ...e, body: await iS(e.body, t) } : e, ws = async (e, t) => ({ ...e, body: await iS(e.body, t) }), __ = /* @__PURE__ */ new WeakMap();
function p1(e) {
  const t = typeof e == "function" ? e : e.fetch, n = __.get(t);
  if (n)
    return n;
  const r = (async () => {
    try {
      const s = "Response" in t ? t.Response : (await t("data:,")).constructor, i = new FormData();
      return i.toString() !== await new s(i).text();
    } catch {
      return !0;
    }
  })();
  return __.set(t, r), r;
}
const iS = async (e, t) => {
  if (!await p1(t))
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  const n = new FormData();
  return await Promise.all(Object.entries(e || {}).map(([r, s]) => $h(n, r, s))), n;
}, aS = (e) => e instanceof Blob && "name" in e, m1 = (e) => typeof e == "object" && e !== null && (e instanceof Response || zp(e) || aS(e)), Ch = (e) => {
  if (m1(e))
    return !0;
  if (Array.isArray(e))
    return e.some(Ch);
  if (e && typeof e == "object") {
    for (const t in e)
      if (Ch(e[t]))
        return !0;
  }
  return !1;
}, $h = async (e, t, n) => {
  if (n !== void 0) {
    if (n == null)
      throw new TypeError(`Received null for "${t}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof n == "string" || typeof n == "number" || typeof n == "boolean")
      e.append(t, String(n));
    else if (n instanceof Response)
      e.append(t, Xa([await n.blob()], ec(n)));
    else if (zp(n))
      e.append(t, Xa([await new Response(Gb(n)).blob()], ec(n)));
    else if (aS(n))
      e.append(t, n, ec(n));
    else if (Array.isArray(n))
      await Promise.all(n.map((r) => $h(e, t + "[]", r)));
    else if (typeof n == "object")
      await Promise.all(Object.entries(n).map(([r, s]) => $h(e, `${t}[${r}]`, s)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`);
  }
}, oS = (e) => e != null && typeof e == "object" && typeof e.size == "number" && typeof e.type == "string" && typeof e.text == "function" && typeof e.slice == "function" && typeof e.arrayBuffer == "function", g1 = (e) => e != null && typeof e == "object" && typeof e.name == "string" && typeof e.lastModified == "number" && oS(e), _1 = (e) => e != null && typeof e == "object" && typeof e.url == "string" && typeof e.blob == "function";
async function y1(e, t, n) {
  if (sS(), e = await e, g1(e))
    return e instanceof File ? e : Xa([await e.arrayBuffer()], e.name);
  if (_1(e)) {
    const s = await e.blob();
    return t || (t = new URL(e.url).pathname.split(/[\\/]/).pop()), Xa(await Rh(s), t, n);
  }
  const r = await Rh(e);
  if (t || (t = ec(e)), !n?.type) {
    const s = r.find((i) => typeof i == "object" && "type" in i && i.type);
    typeof s == "string" && (n = { ...n, type: s });
  }
  return Xa(r, t, n);
}
async function Rh(e) {
  let t = [];
  if (typeof e == "string" || ArrayBuffer.isView(e) || // includes Uint8Array, Buffer, etc.
  e instanceof ArrayBuffer)
    t.push(e);
  else if (oS(e))
    t.push(e instanceof Blob ? e : await e.arrayBuffer());
  else if (zp(e))
    for await (const n of e)
      t.push(...await Rh(n));
  else {
    const n = e?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof e}${n ? `; constructor: ${n}` : ""}${w1(e)}`);
  }
  return t;
}
function w1(e) {
  return typeof e != "object" || e === null ? "" : `; props: [${Object.getOwnPropertyNames(e).map((n) => `"${n}"`).join(", ")}]`;
}
let se = class {
  constructor(t) {
    this._client = t;
  }
};
function uS(e) {
  return e.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const y_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null)), v1 = (e = uS) => function(n, ...r) {
  if (n.length === 1)
    return n[0];
  let s = !1;
  const i = [], a = n.reduce((l, d, f) => {
    /[?#]/.test(d) && (s = !0);
    const h = r[f];
    let p = (s ? encodeURIComponent : e)("" + h);
    return f !== r.length && (h == null || typeof h == "object" && // handle values from other realms
    h.toString === Object.getPrototypeOf(Object.getPrototypeOf(h.hasOwnProperty ?? y_) ?? y_)?.toString) && (p = h + "", i.push({
      start: l.length + d.length,
      length: p.length,
      error: `Value of type ${Object.prototype.toString.call(h).slice(8, -1)} is not a valid path parameter`
    })), l + d + (f === r.length ? "" : p);
  }, ""), o = a.split(/[?#]/, 1)[0], u = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let c;
  for (; (c = u.exec(o)) !== null; )
    i.push({
      start: c.index,
      length: c[0].length,
      error: `Value "${c[0]}" can't be safely passed as a path parameter`
    });
  if (i.sort((l, d) => l.start - d.start), i.length > 0) {
    let l = 0;
    const d = i.reduce((f, h) => {
      const p = " ".repeat(h.start - l), g = "^".repeat(h.length);
      return l = h.start + h.length, f + p + g;
    }, "");
    throw new ue(`Path parameters result in path with invalid segments:
${i.map((f) => f.error).join(`
`)}
${a}
${d}`);
  }
  return a;
}, P = /* @__PURE__ */ v1(uS);
let cS = class extends se {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/chat/completions/${t}/messages`, at, { query: n, ...r });
  }
};
function bc(e) {
  return e !== void 0 && "function" in e && e.function !== void 0;
}
function b1(e, t) {
  const n = { ...e };
  return Object.defineProperties(n, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: t,
      enumerable: !1
    }
  }), n;
}
function qp(e) {
  return e?.$brand === "auto-parseable-response-format";
}
function Io(e) {
  return e?.$brand === "auto-parseable-tool";
}
function S1(e, t) {
  return !t || !lS(t) ? {
    ...e,
    choices: e.choices.map((n) => (dS(n.message.tool_calls), {
      ...n,
      message: {
        ...n.message,
        parsed: null,
        ...n.message.tool_calls ? {
          tool_calls: n.message.tool_calls
        } : void 0
      }
    }))
  } : Bp(e, t);
}
function Bp(e, t) {
  const n = e.choices.map((r) => {
    if (r.finish_reason === "length")
      throw new Bb();
    if (r.finish_reason === "content_filter")
      throw new Zb();
    return dS(r.message.tool_calls), {
      ...r,
      message: {
        ...r.message,
        ...r.message.tool_calls ? {
          tool_calls: r.message.tool_calls?.map((s) => x1(t, s)) ?? void 0
        } : void 0,
        parsed: r.message.content && !r.message.refusal ? T1(t, r.message.content) : null
      }
    };
  });
  return { ...e, choices: n };
}
function T1(e, t) {
  return e.response_format?.type !== "json_schema" ? null : e.response_format?.type === "json_schema" ? "$parseRaw" in e.response_format ? e.response_format.$parseRaw(t) : JSON.parse(t) : null;
}
function x1(e, t) {
  const n = e.tools?.find((r) => bc(r) && r.function?.name === t.function.name);
  return {
    ...t,
    function: {
      ...t.function,
      parsed_arguments: Io(n) ? n.$parseRaw(t.function.arguments) : n?.function.strict ? JSON.parse(t.function.arguments) : null
    }
  };
}
function E1(e, t) {
  if (!e || !("tools" in e) || !e.tools)
    return !1;
  const n = e.tools?.find((r) => bc(r) && r.function?.name === t.function.name);
  return bc(n) && (Io(n) || n?.function.strict || !1);
}
function lS(e) {
  return qp(e.response_format) ? !0 : e.tools?.some((t) => Io(t) || t.type === "function" && t.function.strict === !0) ?? !1;
}
function dS(e) {
  for (const t of e || [])
    if (t.type !== "function")
      throw new ue(`Currently only \`function\` tool calls are supported; Received \`${t.type}\``);
}
function k1(e) {
  for (const t of e ?? []) {
    if (t.type !== "function")
      throw new ue(`Currently only \`function\` tool types support auto-parsing; Received \`${t.type}\``);
    if (t.function.strict !== !0)
      throw new ue(`The \`${t.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
  }
}
const Sc = (e) => e?.role === "assistant", fS = (e) => e?.role === "tool";
var Ph, tc, nc, ja, La, rc, Da, sr, Ua, Tc, xc, Bs, hS;
class Zp {
  constructor() {
    Ph.add(this), this.controller = new AbortController(), tc.set(this, void 0), nc.set(this, () => {
    }), ja.set(this, () => {
    }), La.set(this, void 0), rc.set(this, () => {
    }), Da.set(this, () => {
    }), sr.set(this, {}), Ua.set(this, !1), Tc.set(this, !1), xc.set(this, !1), Bs.set(this, !1), de(this, tc, new Promise((t, n) => {
      de(this, nc, t, "f"), de(this, ja, n, "f");
    })), de(this, La, new Promise((t, n) => {
      de(this, rc, t, "f"), de(this, Da, n, "f");
    })), I(this, tc, "f").catch(() => {
    }), I(this, La, "f").catch(() => {
    });
  }
  _run(t) {
    setTimeout(() => {
      t().then(() => {
        this._emitFinal(), this._emit("end");
      }, I(this, Ph, "m", hS).bind(this));
    }, 0);
  }
  _connected() {
    this.ended || (I(this, nc, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return I(this, Ua, "f");
  }
  get errored() {
    return I(this, Tc, "f");
  }
  get aborted() {
    return I(this, xc, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(t, n) {
    return (I(this, sr, "f")[t] || (I(this, sr, "f")[t] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(t, n) {
    const r = I(this, sr, "f")[t];
    if (!r)
      return this;
    const s = r.findIndex((i) => i.listener === n);
    return s >= 0 && r.splice(s, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(t, n) {
    return (I(this, sr, "f")[t] || (I(this, sr, "f")[t] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(t) {
    return new Promise((n, r) => {
      de(this, Bs, !0), t !== "error" && this.once("error", r), this.once(t, n);
    });
  }
  async done() {
    de(this, Bs, !0), await I(this, La, "f");
  }
  _emit(t, ...n) {
    if (I(this, Ua, "f"))
      return;
    t === "end" && (de(this, Ua, !0), I(this, rc, "f").call(this));
    const r = I(this, sr, "f")[t];
    if (r && (I(this, sr, "f")[t] = r.filter((s) => !s.once), r.forEach(({ listener: s }) => s(...n))), t === "abort") {
      const s = n[0];
      !I(this, Bs, "f") && !r?.length && Promise.reject(s), I(this, ja, "f").call(this, s), I(this, Da, "f").call(this, s), this._emit("end");
      return;
    }
    if (t === "error") {
      const s = n[0];
      !I(this, Bs, "f") && !r?.length && Promise.reject(s), I(this, ja, "f").call(this, s), I(this, Da, "f").call(this, s), this._emit("end");
    }
  }
  _emitFinal() {
  }
}
tc = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap(), La = /* @__PURE__ */ new WeakMap(), rc = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), sr = /* @__PURE__ */ new WeakMap(), Ua = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakMap(), xc = /* @__PURE__ */ new WeakMap(), Bs = /* @__PURE__ */ new WeakMap(), Ph = /* @__PURE__ */ new WeakSet(), hS = function(t) {
  if (de(this, Tc, !0), t instanceof Error && t.name === "AbortError" && (t = new an()), t instanceof an)
    return de(this, xc, !0), this._emit("abort", t);
  if (t instanceof ue)
    return this._emit("error", t);
  if (t instanceof Error) {
    const n = new ue(t.message);
    return n.cause = t, this._emit("error", n);
  }
  return this._emit("error", new ue(String(t)));
};
function O1(e) {
  return typeof e.parse == "function";
}
var Nt, Nh, Ec, Mh, jh, Lh, pS, mS;
const I1 = 10;
class gS extends Zp {
  constructor() {
    super(...arguments), Nt.add(this), this._chatCompletions = [], this.messages = [];
  }
  _addChatCompletion(t) {
    this._chatCompletions.push(t), this._emit("chatCompletion", t);
    const n = t.choices[0]?.message;
    return n && this._addMessage(n), t;
  }
  _addMessage(t, n = !0) {
    if ("content" in t || (t.content = null), this.messages.push(t), n) {
      if (this._emit("message", t), fS(t) && t.content)
        this._emit("functionToolCallResult", t.content);
      else if (Sc(t) && t.tool_calls)
        for (const r of t.tool_calls)
          r.type === "function" && this._emit("functionToolCall", r.function);
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const t = this._chatCompletions[this._chatCompletions.length - 1];
    if (!t)
      throw new ue("stream ended without producing a ChatCompletion");
    return t;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), I(this, Nt, "m", Nh).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), I(this, Nt, "m", Ec).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    return await this.done(), I(this, Nt, "m", Mh).call(this);
  }
  async finalFunctionToolCallResult() {
    return await this.done(), I(this, Nt, "m", jh).call(this);
  }
  async totalUsage() {
    return await this.done(), I(this, Nt, "m", Lh).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const t = this._chatCompletions[this._chatCompletions.length - 1];
    t && this._emit("finalChatCompletion", t);
    const n = I(this, Nt, "m", Ec).call(this);
    n && this._emit("finalMessage", n);
    const r = I(this, Nt, "m", Nh).call(this);
    r && this._emit("finalContent", r);
    const s = I(this, Nt, "m", Mh).call(this);
    s && this._emit("finalFunctionToolCall", s);
    const i = I(this, Nt, "m", jh).call(this);
    i != null && this._emit("finalFunctionToolCallResult", i), this._chatCompletions.some((a) => a.usage) && this._emit("totalUsage", I(this, Nt, "m", Lh).call(this));
  }
  async _createChatCompletion(t, n, r) {
    const s = r?.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), I(this, Nt, "m", pS).call(this, n);
    const i = await t.chat.completions.create({ ...n, stream: !1 }, { ...r, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(Bp(i, n));
  }
  async _runChatCompletion(t, n, r) {
    for (const s of n.messages)
      this._addMessage(s, !1);
    return await this._createChatCompletion(t, n, r);
  }
  async _runTools(t, n, r) {
    const s = "tool", { tool_choice: i = "auto", stream: a, ...o } = n, u = typeof i != "string" && i.type === "function" && i?.function?.name, { maxChatCompletions: c = I1 } = r || {}, l = n.tools.map((h) => {
      if (Io(h)) {
        if (!h.$callback)
          throw new ue("Tool given to `.runTools()` that does not have an associated function");
        return {
          type: "function",
          function: {
            function: h.$callback,
            name: h.function.name,
            description: h.function.description || "",
            parameters: h.function.parameters,
            parse: h.$parseRaw,
            strict: !0
          }
        };
      }
      return h;
    }), d = {};
    for (const h of l)
      h.type === "function" && (d[h.function.name || h.function.function.name] = h.function);
    const f = "tools" in n ? l.map((h) => h.type === "function" ? {
      type: "function",
      function: {
        name: h.function.name || h.function.function.name,
        parameters: h.function.parameters,
        description: h.function.description,
        strict: h.function.strict
      }
    } : h) : void 0;
    for (const h of n.messages)
      this._addMessage(h, !1);
    for (let h = 0; h < c; ++h) {
      const g = (await this._createChatCompletion(t, {
        ...o,
        tool_choice: i,
        tools: f,
        messages: [...this.messages]
      }, r)).choices[0]?.message;
      if (!g)
        throw new ue("missing message in ChatCompletion response");
      if (!g.tool_calls?.length)
        return;
      for (const m of g.tool_calls) {
        if (m.type !== "function")
          continue;
        const _ = m.id, { name: y, arguments: b } = m.function, T = d[y];
        if (T) {
          if (u && u !== y) {
            const S = `Invalid tool_call: ${JSON.stringify(y)}. ${JSON.stringify(u)} requested. Please try again`;
            this._addMessage({ role: s, tool_call_id: _, content: S });
            continue;
          }
        } else {
          const S = `Invalid tool_call: ${JSON.stringify(y)}. Available options are: ${Object.keys(d).map((j) => JSON.stringify(j)).join(", ")}. Please try again`;
          this._addMessage({ role: s, tool_call_id: _, content: S });
          continue;
        }
        let x;
        try {
          x = O1(T) ? await T.parse(b) : b;
        } catch (S) {
          const j = S instanceof Error ? S.message : String(S);
          this._addMessage({ role: s, tool_call_id: _, content: j });
          continue;
        }
        const k = await T.function(x, this), O = I(this, Nt, "m", mS).call(this, k);
        if (this._addMessage({ role: s, tool_call_id: _, content: O }), u)
          return;
      }
    }
  }
}
Nt = /* @__PURE__ */ new WeakSet(), Nh = function() {
  return I(this, Nt, "m", Ec).call(this).content ?? null;
}, Ec = function() {
  let t = this.messages.length;
  for (; t-- > 0; ) {
    const n = this.messages[t];
    if (Sc(n))
      return {
        ...n,
        content: n.content ?? null,
        refusal: n.refusal ?? null
      };
  }
  throw new ue("stream ended without producing a ChatCompletionMessage with role=assistant");
}, Mh = function() {
  for (let t = this.messages.length - 1; t >= 0; t--) {
    const n = this.messages[t];
    if (Sc(n) && n?.tool_calls?.length)
      return n.tool_calls.filter((r) => r.type === "function").at(-1)?.function;
  }
}, jh = function() {
  for (let t = this.messages.length - 1; t >= 0; t--) {
    const n = this.messages[t];
    if (fS(n) && n.content != null && typeof n.content == "string" && this.messages.some((r) => r.role === "assistant" && r.tool_calls?.some((s) => s.type === "function" && s.id === n.tool_call_id)))
      return n.content;
  }
}, Lh = function() {
  const t = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: n } of this._chatCompletions)
    n && (t.completion_tokens += n.completion_tokens, t.prompt_tokens += n.prompt_tokens, t.total_tokens += n.total_tokens);
  return t;
}, pS = function(t) {
  if (t.n != null && t.n > 1)
    throw new ue("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, mS = function(t) {
  return typeof t == "string" ? t : t === void 0 ? "undefined" : JSON.stringify(t);
};
class Vp extends gS {
  static runTools(t, n, r) {
    const s = new Vp(), i = {
      ...r,
      headers: { ...r?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return s._run(() => s._runTools(t, n, i)), s;
  }
  _addMessage(t, n = !0) {
    super._addMessage(t, n), Sc(t) && t.content && this._emit("content", t.content);
  }
}
const _S = 1, yS = 2, wS = 4, vS = 8, bS = 16, SS = 32, TS = 64, xS = 128, ES = 256, kS = xS | ES, OS = bS | SS | kS | TS, IS = _S | yS | OS, AS = wS | vS, A1 = IS | AS, mt = {
  STR: _S,
  NUM: yS,
  ARR: wS,
  OBJ: vS,
  NULL: bS,
  BOOL: SS,
  NAN: TS,
  INFINITY: xS,
  MINUS_INFINITY: ES,
  INF: kS,
  SPECIAL: OS,
  ATOM: IS,
  COLLECTION: AS,
  ALL: A1
};
class C1 extends Error {
}
class $1 extends Error {
}
function R1(e, t = mt.ALL) {
  if (typeof e != "string")
    throw new TypeError(`expecting str, got ${typeof e}`);
  if (!e.trim())
    throw new Error(`${e} is empty`);
  return P1(e.trim(), t);
}
const P1 = (e, t) => {
  const n = e.length;
  let r = 0;
  const s = (f) => {
    throw new C1(`${f} at position ${r}`);
  }, i = (f) => {
    throw new $1(`${f} at position ${r}`);
  }, a = () => (d(), r >= n && s("Unexpected end of input"), e[r] === '"' ? o() : e[r] === "{" ? u() : e[r] === "[" ? c() : e.substring(r, r + 4) === "null" || mt.NULL & t && n - r < 4 && "null".startsWith(e.substring(r)) ? (r += 4, null) : e.substring(r, r + 4) === "true" || mt.BOOL & t && n - r < 4 && "true".startsWith(e.substring(r)) ? (r += 4, !0) : e.substring(r, r + 5) === "false" || mt.BOOL & t && n - r < 5 && "false".startsWith(e.substring(r)) ? (r += 5, !1) : e.substring(r, r + 8) === "Infinity" || mt.INFINITY & t && n - r < 8 && "Infinity".startsWith(e.substring(r)) ? (r += 8, 1 / 0) : e.substring(r, r + 9) === "-Infinity" || mt.MINUS_INFINITY & t && 1 < n - r && n - r < 9 && "-Infinity".startsWith(e.substring(r)) ? (r += 9, -1 / 0) : e.substring(r, r + 3) === "NaN" || mt.NAN & t && n - r < 3 && "NaN".startsWith(e.substring(r)) ? (r += 3, NaN) : l()), o = () => {
    const f = r;
    let h = !1;
    for (r++; r < n && (e[r] !== '"' || h && e[r - 1] === "\\"); )
      h = e[r] === "\\" ? !h : !1, r++;
    if (e.charAt(r) == '"')
      try {
        return JSON.parse(e.substring(f, ++r - Number(h)));
      } catch (p) {
        i(String(p));
      }
    else if (mt.STR & t)
      try {
        return JSON.parse(e.substring(f, r - Number(h)) + '"');
      } catch {
        return JSON.parse(e.substring(f, e.lastIndexOf("\\")) + '"');
      }
    s("Unterminated string literal");
  }, u = () => {
    r++, d();
    const f = {};
    try {
      for (; e[r] !== "}"; ) {
        if (d(), r >= n && mt.OBJ & t)
          return f;
        const h = o();
        d(), r++;
        try {
          const p = a();
          Object.defineProperty(f, h, { value: p, writable: !0, enumerable: !0, configurable: !0 });
        } catch (p) {
          if (mt.OBJ & t)
            return f;
          throw p;
        }
        d(), e[r] === "," && r++;
      }
    } catch {
      if (mt.OBJ & t)
        return f;
      s("Expected '}' at end of object");
    }
    return r++, f;
  }, c = () => {
    r++;
    const f = [];
    try {
      for (; e[r] !== "]"; )
        f.push(a()), d(), e[r] === "," && r++;
    } catch {
      if (mt.ARR & t)
        return f;
      s("Expected ']' at end of array");
    }
    return r++, f;
  }, l = () => {
    if (r === 0) {
      e === "-" && mt.NUM & t && s("Not sure what '-' is");
      try {
        return JSON.parse(e);
      } catch (h) {
        if (mt.NUM & t)
          try {
            return e[e.length - 1] === "." ? JSON.parse(e.substring(0, e.lastIndexOf("."))) : JSON.parse(e.substring(0, e.lastIndexOf("e")));
          } catch {
          }
        i(String(h));
      }
    }
    const f = r;
    for (e[r] === "-" && r++; e[r] && !",]}".includes(e[r]); )
      r++;
    r == n && !(mt.NUM & t) && s("Unterminated number literal");
    try {
      return JSON.parse(e.substring(f, r));
    } catch {
      e.substring(f, r) === "-" && mt.NUM & t && s("Not sure what '-' is");
      try {
        return JSON.parse(e.substring(f, e.lastIndexOf("e")));
      } catch (p) {
        i(String(p));
      }
    }
  }, d = () => {
    for (; r < n && ` 
\r	`.includes(e[r]); )
      r++;
  };
  return a();
}, w_ = (e) => R1(e, mt.ALL ^ mt.NUM);
var ct, tr, $s, wr, Fd, nu, zd, qd, Bd, ru, Zd, v_;
class uo extends gS {
  constructor(t) {
    super(), ct.add(this), tr.set(this, void 0), $s.set(this, void 0), wr.set(this, void 0), de(this, tr, t), de(this, $s, []);
  }
  get currentChatCompletionSnapshot() {
    return I(this, wr, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(t) {
    const n = new uo(null);
    return n._run(() => n._fromReadableStream(t)), n;
  }
  static createChatCompletion(t, n, r) {
    const s = new uo(n);
    return s._run(() => s._runChatCompletion(t, { ...n, stream: !0 }, { ...r, headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" } })), s;
  }
  async _createChatCompletion(t, n, r) {
    super._createChatCompletion;
    const s = r?.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), I(this, ct, "m", Fd).call(this);
    const i = await t.chat.completions.create({ ...n, stream: !0 }, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const a of i)
      I(this, ct, "m", zd).call(this, a);
    if (i.controller.signal?.aborted)
      throw new an();
    return this._addChatCompletion(I(this, ct, "m", ru).call(this));
  }
  async _fromReadableStream(t, n) {
    const r = n?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), I(this, ct, "m", Fd).call(this), this._connected();
    const s = oo.fromReadableStream(t, this.controller);
    let i;
    for await (const a of s)
      i && i !== a.id && this._addChatCompletion(I(this, ct, "m", ru).call(this)), I(this, ct, "m", zd).call(this, a), i = a.id;
    if (s.controller.signal?.aborted)
      throw new an();
    return this._addChatCompletion(I(this, ct, "m", ru).call(this));
  }
  [(tr = /* @__PURE__ */ new WeakMap(), $s = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakSet(), Fd = function() {
    this.ended || de(this, wr, void 0);
  }, nu = function(n) {
    let r = I(this, $s, "f")[n.index];
    return r || (r = {
      content_done: !1,
      refusal_done: !1,
      logprobs_content_done: !1,
      logprobs_refusal_done: !1,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    }, I(this, $s, "f")[n.index] = r, r);
  }, zd = function(n) {
    if (this.ended)
      return;
    const r = I(this, ct, "m", v_).call(this, n);
    this._emit("chunk", n, r);
    for (const s of n.choices) {
      const i = r.choices[s.index];
      s.delta.content != null && i.message?.role === "assistant" && i.message?.content && (this._emit("content", s.delta.content, i.message.content), this._emit("content.delta", {
        delta: s.delta.content,
        snapshot: i.message.content,
        parsed: i.message.parsed
      })), s.delta.refusal != null && i.message?.role === "assistant" && i.message?.refusal && this._emit("refusal.delta", {
        delta: s.delta.refusal,
        snapshot: i.message.refusal
      }), s.logprobs?.content != null && i.message?.role === "assistant" && this._emit("logprobs.content.delta", {
        content: s.logprobs?.content,
        snapshot: i.logprobs?.content ?? []
      }), s.logprobs?.refusal != null && i.message?.role === "assistant" && this._emit("logprobs.refusal.delta", {
        refusal: s.logprobs?.refusal,
        snapshot: i.logprobs?.refusal ?? []
      });
      const a = I(this, ct, "m", nu).call(this, i);
      i.finish_reason && (I(this, ct, "m", Bd).call(this, i), a.current_tool_call_index != null && I(this, ct, "m", qd).call(this, i, a.current_tool_call_index));
      for (const o of s.delta.tool_calls ?? [])
        a.current_tool_call_index !== o.index && (I(this, ct, "m", Bd).call(this, i), a.current_tool_call_index != null && I(this, ct, "m", qd).call(this, i, a.current_tool_call_index)), a.current_tool_call_index = o.index;
      for (const o of s.delta.tool_calls ?? []) {
        const u = i.message.tool_calls?.[o.index];
        u?.type && (u?.type === "function" ? this._emit("tool_calls.function.arguments.delta", {
          name: u.function?.name,
          index: o.index,
          arguments: u.function.arguments,
          parsed_arguments: u.function.parsed_arguments,
          arguments_delta: o.function?.arguments ?? ""
        }) : (u?.type, void 0));
      }
    }
  }, qd = function(n, r) {
    if (I(this, ct, "m", nu).call(this, n).done_tool_calls.has(r))
      return;
    const i = n.message.tool_calls?.[r];
    if (!i)
      throw new Error("no tool call snapshot");
    if (!i.type)
      throw new Error("tool call snapshot missing `type`");
    if (i.type === "function") {
      const a = I(this, tr, "f")?.tools?.find((o) => bc(o) && o.function.name === i.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: i.function.name,
        index: r,
        arguments: i.function.arguments,
        parsed_arguments: Io(a) ? a.$parseRaw(i.function.arguments) : a?.function.strict ? JSON.parse(i.function.arguments) : null
      });
    } else
      i.type;
  }, Bd = function(n) {
    const r = I(this, ct, "m", nu).call(this, n);
    if (n.message.content && !r.content_done) {
      r.content_done = !0;
      const s = I(this, ct, "m", Zd).call(this);
      this._emit("content.done", {
        content: n.message.content,
        parsed: s ? s.$parseRaw(n.message.content) : null
      });
    }
    n.message.refusal && !r.refusal_done && (r.refusal_done = !0, this._emit("refusal.done", { refusal: n.message.refusal })), n.logprobs?.content && !r.logprobs_content_done && (r.logprobs_content_done = !0, this._emit("logprobs.content.done", { content: n.logprobs.content })), n.logprobs?.refusal && !r.logprobs_refusal_done && (r.logprobs_refusal_done = !0, this._emit("logprobs.refusal.done", { refusal: n.logprobs.refusal }));
  }, ru = function() {
    if (this.ended)
      throw new ue("stream has ended, this shouldn't happen");
    const n = I(this, wr, "f");
    if (!n)
      throw new ue("request ended without sending any chunks");
    return de(this, wr, void 0), de(this, $s, []), N1(n, I(this, tr, "f"));
  }, Zd = function() {
    const n = I(this, tr, "f")?.response_format;
    return qp(n) ? n : null;
  }, v_ = function(n) {
    var r, s, i, a;
    let o = I(this, wr, "f");
    const { choices: u, ...c } = n;
    o ? Object.assign(o, c) : o = de(this, wr, {
      ...c,
      choices: []
    });
    for (const { delta: l, finish_reason: d, index: f, logprobs: h = null, ...p } of n.choices) {
      let g = o.choices[f];
      if (g || (g = o.choices[f] = { finish_reason: d, index: f, message: {}, logprobs: h, ...p }), h)
        if (!g.logprobs)
          g.logprobs = Object.assign({}, h);
        else {
          const { content: k, refusal: O, ...S } = h;
          Object.assign(g.logprobs, S), k && ((r = g.logprobs).content ?? (r.content = []), g.logprobs.content.push(...k)), O && ((s = g.logprobs).refusal ?? (s.refusal = []), g.logprobs.refusal.push(...O));
        }
      if (d && (g.finish_reason = d, I(this, tr, "f") && lS(I(this, tr, "f")))) {
        if (d === "length")
          throw new Bb();
        if (d === "content_filter")
          throw new Zb();
      }
      if (Object.assign(g, p), !l)
        continue;
      const { content: m, refusal: _, function_call: y, role: b, tool_calls: T, ...x } = l;
      if (Object.assign(g.message, x), _ && (g.message.refusal = (g.message.refusal || "") + _), b && (g.message.role = b), y && (g.message.function_call ? (y.name && (g.message.function_call.name = y.name), y.arguments && ((i = g.message.function_call).arguments ?? (i.arguments = ""), g.message.function_call.arguments += y.arguments)) : g.message.function_call = y), m && (g.message.content = (g.message.content || "") + m, !g.message.refusal && I(this, ct, "m", Zd).call(this) && (g.message.parsed = w_(g.message.content))), T) {
        g.message.tool_calls || (g.message.tool_calls = []);
        for (const { index: k, id: O, type: S, function: j, ...U } of T) {
          const G = (a = g.message.tool_calls)[k] ?? (a[k] = {});
          Object.assign(G, U), O && (G.id = O), S && (G.type = S), j && (G.function ?? (G.function = { name: j.name ?? "", arguments: "" })), j?.name && (G.function.name = j.name), j?.arguments && (G.function.arguments += j.arguments, E1(I(this, tr, "f"), G) && (G.function.parsed_arguments = w_(G.function.arguments)));
        }
      }
    }
    return o;
  }, Symbol.asyncIterator)]() {
    const t = [], n = [];
    let r = !1;
    return this.on("chunk", (s) => {
      const i = n.shift();
      i ? i.resolve(s) : t.push(s);
    }), this.on("end", () => {
      r = !0;
      for (const s of n)
        s.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), this.on("error", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), {
      next: async () => t.length ? { value: t.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((i, a) => n.push({ resolve: i, reject: a })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new oo(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function N1(e, t) {
  const { id: n, choices: r, created: s, model: i, system_fingerprint: a, ...o } = e, u = {
    ...o,
    id: n,
    choices: r.map(({ message: c, finish_reason: l, index: d, logprobs: f, ...h }) => {
      if (!l)
        throw new ue(`missing finish_reason for choice ${d}`);
      const { content: p = null, function_call: g, tool_calls: m, ..._ } = c, y = c.role;
      if (!y)
        throw new ue(`missing role for choice ${d}`);
      if (g) {
        const { arguments: b, name: T } = g;
        if (b == null)
          throw new ue(`missing function_call.arguments for choice ${d}`);
        if (!T)
          throw new ue(`missing function_call.name for choice ${d}`);
        return {
          ...h,
          message: {
            content: p,
            function_call: { arguments: b, name: T },
            role: y,
            refusal: c.refusal ?? null
          },
          finish_reason: l,
          index: d,
          logprobs: f
        };
      }
      return m ? {
        ...h,
        index: d,
        finish_reason: l,
        logprobs: f,
        message: {
          ..._,
          role: y,
          content: p,
          refusal: c.refusal ?? null,
          tool_calls: m.map((b, T) => {
            const { function: x, type: k, id: O, ...S } = b, { arguments: j, name: U, ...G } = x || {};
            if (O == null)
              throw new ue(`missing choices[${d}].tool_calls[${T}].id
${su(e)}`);
            if (k == null)
              throw new ue(`missing choices[${d}].tool_calls[${T}].type
${su(e)}`);
            if (U == null)
              throw new ue(`missing choices[${d}].tool_calls[${T}].function.name
${su(e)}`);
            if (j == null)
              throw new ue(`missing choices[${d}].tool_calls[${T}].function.arguments
${su(e)}`);
            return { ...S, id: O, type: k, function: { ...G, name: U, arguments: j } };
          })
        }
      } : {
        ...h,
        message: { ..._, content: p, role: y, refusal: c.refusal ?? null },
        finish_reason: l,
        index: d,
        logprobs: f
      };
    }),
    created: s,
    model: i,
    object: "chat.completion",
    ...a ? { system_fingerprint: a } : {}
  };
  return S1(u, t);
}
function su(e) {
  return JSON.stringify(e);
}
class kc extends uo {
  static fromReadableStream(t) {
    const n = new kc(null);
    return n._run(() => n._fromReadableStream(t)), n;
  }
  static runTools(t, n, r) {
    const s = new kc(
      // @ts-expect-error TODO these types are incompatible
      n
    ), i = {
      ...r,
      headers: { ...r?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return s._run(() => s._runTools(t, n, i)), s;
  }
}
let Hp = class extends se {
  constructor() {
    super(...arguments), this.messages = new cS(this._client);
  }
  create(t, n) {
    return this._client.post("/chat/completions", { body: t, ...n, stream: t.stream ?? !1 });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(t, n) {
    return this._client.get(P`/chat/completions/${t}`, n);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(t, n, r) {
    return this._client.post(P`/chat/completions/${t}`, { body: n, ...r });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    return this._client.getAPIList("/chat/completions", at, { query: t, ...n });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(t, n) {
    return this._client.delete(P`/chat/completions/${t}`, n);
  }
  parse(t, n) {
    return k1(t.tools), this._client.chat.completions.create(t, {
      ...n,
      headers: {
        ...n?.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((r) => Bp(r, t));
  }
  runTools(t, n) {
    return t.stream ? kc.runTools(this._client, t, n) : Vp.runTools(this._client, t, n);
  }
  /**
   * Creates a chat completion stream
   */
  stream(t, n) {
    return uo.createChatCompletion(this._client, t, n);
  }
};
Hp.Messages = cS;
class Gp extends se {
  constructor() {
    super(...arguments), this.completions = new Hp(this._client);
  }
}
Gp.Completions = Hp;
const CS = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* M1(e) {
  if (!e)
    return;
  if (CS in e) {
    const { values: r, nulls: s } = e;
    yield* r.entries();
    for (const i of s)
      yield [i, null];
    return;
  }
  let t = !1, n;
  e instanceof Headers ? n = e.entries() : s_(e) ? n = e : (t = !0, n = Object.entries(e ?? {}));
  for (let r of n) {
    const s = r[0];
    if (typeof s != "string")
      throw new TypeError("expected header name to be a string");
    const i = s_(r[1]) ? r[1] : [r[1]];
    let a = !1;
    for (const o of i)
      o !== void 0 && (t && !a && (a = !0, yield [s, null]), yield [s, o]);
  }
}
const J = (e) => {
  const t = new Headers(), n = /* @__PURE__ */ new Set();
  for (const r of e) {
    const s = /* @__PURE__ */ new Set();
    for (const [i, a] of M1(r)) {
      const o = i.toLowerCase();
      s.has(o) || (t.delete(i), s.add(o)), a === null ? (t.delete(i), n.add(o)) : (t.append(i, a), n.delete(o));
    }
  }
  return { [CS]: !0, values: t, nulls: n };
};
class $S extends se {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(t, n) {
    return this._client.post("/audio/speech", {
      body: t,
      ...n,
      headers: J([{ Accept: "application/octet-stream" }, n?.headers]),
      __binaryResponse: !0
    });
  }
}
class RS extends se {
  create(t, n) {
    return this._client.post("/audio/transcriptions", ws({
      body: t,
      ...n,
      stream: t.stream ?? !1,
      __metadata: { model: t.model }
    }, this._client));
  }
}
class PS extends se {
  create(t, n) {
    return this._client.post("/audio/translations", ws({ body: t, ...n, __metadata: { model: t.model } }, this._client));
  }
}
class Ao extends se {
  constructor() {
    super(...arguments), this.transcriptions = new RS(this._client), this.translations = new PS(this._client), this.speech = new $S(this._client);
  }
}
Ao.Transcriptions = RS;
Ao.Translations = PS;
Ao.Speech = $S;
let NS = class extends se {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(t, n) {
    return this._client.post("/batches", { body: t, ...n });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(t, n) {
    return this._client.get(P`/batches/${t}`, n);
  }
  /**
   * List your organization's batches.
   */
  list(t = {}, n) {
    return this._client.getAPIList("/batches", at, { query: t, ...n });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(t, n) {
    return this._client.post(P`/batches/${t}/cancel`, n);
  }
};
class MS extends se {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(t, n) {
    return this._client.post("/assistants", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(t, n) {
    return this._client.get(P`/assistants/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(t, n, r) {
    return this._client.post(P`/assistants/${t}`, {
      body: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    return this._client.getAPIList("/assistants", at, {
      query: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(t, n) {
    return this._client.delete(P`/assistants/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
}
let jS = class extends se {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(t, n) {
    return this._client.post("/realtime/sessions", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
};
class LS extends se {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(t, n) {
    return this._client.post("/realtime/transcription_sessions", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
}
let dl = class extends se {
  constructor() {
    super(...arguments), this.sessions = new jS(this._client), this.transcriptionSessions = new LS(this._client);
  }
};
dl.Sessions = jS;
dl.TranscriptionSessions = LS;
class DS extends se {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(t, n) {
    return this._client.post("/chatkit/sessions", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "chatkit_beta=v1" }, n?.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(t, n) {
    return this._client.post(P`/chatkit/sessions/${t}/cancel`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "chatkit_beta=v1" }, n?.headers])
    });
  }
}
let US = class extends se {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(t, n) {
    return this._client.get(P`/chatkit/threads/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "chatkit_beta=v1" }, n?.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    return this._client.getAPIList("/chatkit/threads", vc, {
      query: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "chatkit_beta=v1" }, n?.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(t, n) {
    return this._client.delete(P`/chatkit/threads/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "chatkit_beta=v1" }, n?.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(t, n = {}, r) {
    return this._client.getAPIList(P`/chatkit/threads/${t}/items`, vc, { query: n, ...r, headers: J([{ "OpenAI-Beta": "chatkit_beta=v1" }, r?.headers]) });
  }
};
class fl extends se {
  constructor() {
    super(...arguments), this.sessions = new DS(this._client), this.threads = new US(this._client);
  }
}
fl.Sessions = DS;
fl.Threads = US;
let FS = class extends se {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(t, n, r) {
    return this._client.post(P`/threads/${t}/messages`, {
      body: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(t, n, r) {
    const { thread_id: s } = n;
    return this._client.get(P`/threads/${s}/messages/${t}`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(t, n, r) {
    const { thread_id: s, ...i } = n;
    return this._client.post(P`/threads/${s}/messages/${t}`, {
      body: i,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/threads/${t}/messages`, at, {
      query: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(t, n, r) {
    const { thread_id: s } = n;
    return this._client.delete(P`/threads/${s}/messages/${t}`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
};
class zS extends se {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(t, n, r) {
    const { thread_id: s, run_id: i, ...a } = n;
    return this._client.get(P`/threads/${s}/runs/${i}/steps/${t}`, {
      query: a,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(t, n, r) {
    const { thread_id: s, ...i } = n;
    return this._client.getAPIList(P`/threads/${s}/runs/${t}/steps`, at, {
      query: i,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
}
const j1 = (e) => {
  if (typeof Buffer < "u") {
    const t = Buffer.from(e, "base64");
    return Array.from(new Float32Array(t.buffer, t.byteOffset, t.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const t = atob(e), n = t.length, r = new Uint8Array(n);
    for (let s = 0; s < n; s++)
      r[s] = t.charCodeAt(s);
    return Array.from(new Float32Array(r.buffer));
  }
}, Rs = (e) => {
  if (typeof globalThis.process < "u")
    return globalThis.process.env?.[e]?.trim() ?? void 0;
  if (typeof globalThis.Deno < "u")
    return globalThis.Deno.env?.get?.(e)?.trim();
};
var St, fs, Dh, Vn, sc, An, hs, Ks, ls, Oc, sn, ic, ac, Qa, Fa, za, b_, S_, T_, x_, E_, k_, O_;
class eo extends Zp {
  constructor() {
    super(...arguments), St.add(this), Dh.set(this, []), Vn.set(this, {}), sc.set(this, {}), An.set(this, void 0), hs.set(this, void 0), Ks.set(this, void 0), ls.set(this, void 0), Oc.set(this, void 0), sn.set(this, void 0), ic.set(this, void 0), ac.set(this, void 0), Qa.set(this, void 0);
  }
  [(Dh = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), sc = /* @__PURE__ */ new WeakMap(), An = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ new WeakMap(), Ks = /* @__PURE__ */ new WeakMap(), ls = /* @__PURE__ */ new WeakMap(), Oc = /* @__PURE__ */ new WeakMap(), sn = /* @__PURE__ */ new WeakMap(), ic = /* @__PURE__ */ new WeakMap(), ac = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), St = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const t = [], n = [];
    let r = !1;
    return this.on("event", (s) => {
      const i = n.shift();
      i ? i.resolve(s) : t.push(s);
    }), this.on("end", () => {
      r = !0;
      for (const s of n)
        s.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), this.on("error", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), {
      next: async () => t.length ? { value: t.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((i, a) => n.push({ resolve: i, reject: a })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  static fromReadableStream(t) {
    const n = new fs();
    return n._run(() => n._fromReadableStream(t)), n;
  }
  async _fromReadableStream(t, n) {
    const r = n?.signal;
    r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())), this._connected();
    const s = oo.fromReadableStream(t, this.controller);
    for await (const i of s)
      I(this, St, "m", Fa).call(this, i);
    if (s.controller.signal?.aborted)
      throw new an();
    return this._addRun(I(this, St, "m", za).call(this));
  }
  toReadableStream() {
    return new oo(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(t, n, r, s) {
    const i = new fs();
    return i._run(() => i._runToolAssistantStream(t, n, r, {
      ...s,
      headers: { ...s?.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  async _createToolAssistantStream(t, n, r, s) {
    const i = s?.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const a = { ...r, stream: !0 }, o = await t.submitToolOutputs(n, a, {
      ...s,
      signal: this.controller.signal
    });
    this._connected();
    for await (const u of o)
      I(this, St, "m", Fa).call(this, u);
    if (o.controller.signal?.aborted)
      throw new an();
    return this._addRun(I(this, St, "m", za).call(this));
  }
  static createThreadAssistantStream(t, n, r) {
    const s = new fs();
    return s._run(() => s._threadAssistantStream(t, n, {
      ...r,
      headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  static createAssistantStream(t, n, r, s) {
    const i = new fs();
    return i._run(() => i._runAssistantStream(t, n, r, {
      ...s,
      headers: { ...s?.headers, "X-Stainless-Helper-Method": "stream" }
    })), i;
  }
  currentEvent() {
    return I(this, ic, "f");
  }
  currentRun() {
    return I(this, ac, "f");
  }
  currentMessageSnapshot() {
    return I(this, An, "f");
  }
  currentRunStepSnapshot() {
    return I(this, Qa, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(I(this, Vn, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(I(this, sc, "f"));
  }
  async finalRun() {
    if (await this.done(), !I(this, hs, "f"))
      throw Error("Final run was not received.");
    return I(this, hs, "f");
  }
  async _createThreadAssistantStream(t, n, r) {
    const s = r?.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort()));
    const i = { ...n, stream: !0 }, a = await t.createAndRun(i, { ...r, signal: this.controller.signal });
    this._connected();
    for await (const o of a)
      I(this, St, "m", Fa).call(this, o);
    if (a.controller.signal?.aborted)
      throw new an();
    return this._addRun(I(this, St, "m", za).call(this));
  }
  async _createAssistantStream(t, n, r, s) {
    const i = s?.signal;
    i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
    const a = { ...r, stream: !0 }, o = await t.create(n, a, { ...s, signal: this.controller.signal });
    this._connected();
    for await (const u of o)
      I(this, St, "m", Fa).call(this, u);
    if (o.controller.signal?.aborted)
      throw new an();
    return this._addRun(I(this, St, "m", za).call(this));
  }
  static accumulateDelta(t, n) {
    for (const [r, s] of Object.entries(n)) {
      if (!t.hasOwnProperty(r)) {
        t[r] = s;
        continue;
      }
      let i = t[r];
      if (i == null) {
        t[r] = s;
        continue;
      }
      if (r === "index" || r === "type") {
        t[r] = s;
        continue;
      }
      if (typeof i == "string" && typeof s == "string")
        i += s;
      else if (typeof i == "number" && typeof s == "number")
        i += s;
      else if (Ld(i) && Ld(s))
        i = this.accumulateDelta(i, s);
      else if (Array.isArray(i) && Array.isArray(s)) {
        if (i.every((a) => typeof a == "string" || typeof a == "number")) {
          i.push(...s);
          continue;
        }
        for (const a of s) {
          if (!Ld(a))
            throw new Error(`Expected array delta entry to be an object but got: ${a}`);
          const o = a.index;
          if (o == null)
            throw console.error(a), new Error("Expected array delta entry to have an `index` property");
          if (typeof o != "number")
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${o}`);
          const u = i[o];
          u == null ? i.push(a) : i[o] = this.accumulateDelta(u, a);
        }
        continue;
      } else
        throw Error(`Unhandled record type: ${r}, deltaValue: ${s}, accValue: ${i}`);
      t[r] = i;
    }
    return t;
  }
  _addRun(t) {
    return t;
  }
  async _threadAssistantStream(t, n, r) {
    return await this._createThreadAssistantStream(n, t, r);
  }
  async _runAssistantStream(t, n, r, s) {
    return await this._createAssistantStream(n, t, r, s);
  }
  async _runToolAssistantStream(t, n, r, s) {
    return await this._createToolAssistantStream(n, t, r, s);
  }
}
fs = eo, Fa = function(t) {
  if (!this.ended)
    switch (de(this, ic, t), I(this, St, "m", T_).call(this, t), t.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        I(this, St, "m", O_).call(this, t);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        I(this, St, "m", S_).call(this, t);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        I(this, St, "m", b_).call(this, t);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, za = function() {
  if (this.ended)
    throw new ue("stream has ended, this shouldn't happen");
  if (!I(this, hs, "f"))
    throw Error("Final run has not been received");
  return I(this, hs, "f");
}, b_ = function(t) {
  const [n, r] = I(this, St, "m", E_).call(this, t, I(this, An, "f"));
  de(this, An, n), I(this, sc, "f")[n.id] = n;
  for (const s of r) {
    const i = n.content[s.index];
    i?.type == "text" && this._emit("textCreated", i.text);
  }
  switch (t.event) {
    case "thread.message.created":
      this._emit("messageCreated", t.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", t.data.delta, n), t.data.delta.content)
        for (const s of t.data.delta.content) {
          if (s.type == "text" && s.text) {
            let i = s.text, a = n.content[s.index];
            if (a && a.type == "text")
              this._emit("textDelta", i, a.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (s.index != I(this, Ks, "f")) {
            if (I(this, ls, "f"))
              switch (I(this, ls, "f").type) {
                case "text":
                  this._emit("textDone", I(this, ls, "f").text, I(this, An, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", I(this, ls, "f").image_file, I(this, An, "f"));
                  break;
              }
            de(this, Ks, s.index);
          }
          de(this, ls, n.content[s.index]);
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (I(this, Ks, "f") !== void 0) {
        const s = t.data.content[I(this, Ks, "f")];
        if (s)
          switch (s.type) {
            case "image_file":
              this._emit("imageFileDone", s.image_file, I(this, An, "f"));
              break;
            case "text":
              this._emit("textDone", s.text, I(this, An, "f"));
              break;
          }
      }
      I(this, An, "f") && this._emit("messageDone", t.data), de(this, An, void 0);
  }
}, S_ = function(t) {
  const n = I(this, St, "m", x_).call(this, t);
  switch (de(this, Qa, n), t.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", t.data);
      break;
    case "thread.run.step.delta":
      const r = t.data.delta;
      if (r.step_details && r.step_details.type == "tool_calls" && r.step_details.tool_calls && n.step_details.type == "tool_calls")
        for (const i of r.step_details.tool_calls)
          i.index == I(this, Oc, "f") ? this._emit("toolCallDelta", i, n.step_details.tool_calls[i.index]) : (I(this, sn, "f") && this._emit("toolCallDone", I(this, sn, "f")), de(this, Oc, i.index), de(this, sn, n.step_details.tool_calls[i.index]), I(this, sn, "f") && this._emit("toolCallCreated", I(this, sn, "f")));
      this._emit("runStepDelta", t.data.delta, n);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      de(this, Qa, void 0), t.data.step_details.type == "tool_calls" && I(this, sn, "f") && (this._emit("toolCallDone", I(this, sn, "f")), de(this, sn, void 0)), this._emit("runStepDone", t.data, n);
      break;
  }
}, T_ = function(t) {
  I(this, Dh, "f").push(t), this._emit("event", t);
}, x_ = function(t) {
  switch (t.event) {
    case "thread.run.step.created":
      return I(this, Vn, "f")[t.data.id] = t.data, t.data;
    case "thread.run.step.delta":
      let n = I(this, Vn, "f")[t.data.id];
      if (!n)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let r = t.data;
      if (r.delta) {
        const s = fs.accumulateDelta(n, r.delta);
        I(this, Vn, "f")[t.data.id] = s;
      }
      return I(this, Vn, "f")[t.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      I(this, Vn, "f")[t.data.id] = t.data;
      break;
  }
  if (I(this, Vn, "f")[t.data.id])
    return I(this, Vn, "f")[t.data.id];
  throw new Error("No snapshot available");
}, E_ = function(t, n) {
  let r = [];
  switch (t.event) {
    case "thread.message.created":
      return [t.data, r];
    case "thread.message.delta":
      if (!n)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let s = t.data;
      if (s.delta.content)
        for (const i of s.delta.content)
          if (i.index in n.content) {
            let a = n.content[i.index];
            n.content[i.index] = I(this, St, "m", k_).call(this, i, a);
          } else
            n.content[i.index] = i, r.push(i);
      return [n, r];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (n)
        return [n, r];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, k_ = function(t, n) {
  return fs.accumulateDelta(n, t);
}, O_ = function(t) {
  switch (de(this, ac, t.data), t.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      de(this, hs, t.data), I(this, sn, "f") && (this._emit("toolCallDone", I(this, sn, "f")), de(this, sn, void 0));
      break;
  }
};
let Wp = class extends se {
  constructor() {
    super(...arguments), this.steps = new zS(this._client);
  }
  create(t, n, r) {
    const { include: s, ...i } = n;
    return this._client.post(P`/threads/${t}/runs`, {
      query: { include: s },
      body: i,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers]),
      stream: n.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(t, n, r) {
    const { thread_id: s } = n;
    return this._client.get(P`/threads/${s}/runs/${t}`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(t, n, r) {
    const { thread_id: s, ...i } = n;
    return this._client.post(P`/threads/${s}/runs/${t}`, {
      body: i,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/threads/${t}/runs`, at, {
      query: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(t, n, r) {
    const { thread_id: s } = n;
    return this._client.post(P`/threads/${s}/runs/${t}/cancel`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(t, n, r) {
    const s = await this.create(t, n, r);
    return await this.poll(s.id, { thread_id: t }, r);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(t, n, r) {
    return eo.createAssistantStream(t, this._client.beta.threads.runs, n, r);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(t, n, r) {
    const s = J([
      r?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": r?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: i, response: a } = await this.retrieve(t, n, {
        ...r,
        headers: { ...r?.headers, ...s }
      }).withResponse();
      switch (i.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let o = 5e3;
          if (r?.pollIntervalMs)
            o = r.pollIntervalMs;
          else {
            const u = a.headers.get("openai-poll-after-ms");
            if (u) {
              const c = parseInt(u);
              isNaN(c) || (o = c);
            }
          }
          await Oo(o);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return i;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(t, n, r) {
    return eo.createAssistantStream(t, this._client.beta.threads.runs, n, r);
  }
  submitToolOutputs(t, n, r) {
    const { thread_id: s, ...i } = n;
    return this._client.post(P`/threads/${s}/runs/${t}/submit_tool_outputs`, {
      body: i,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers]),
      stream: n.stream ?? !1
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(t, n, r) {
    const s = await this.submitToolOutputs(t, n, r);
    return await this.poll(s.id, n, r);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(t, n, r) {
    return eo.createToolAssistantStream(t, this._client.beta.threads.runs, n, r);
  }
};
Wp.Steps = zS;
class hl extends se {
  constructor() {
    super(...arguments), this.runs = new Wp(this._client), this.messages = new FS(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(t = {}, n) {
    return this._client.post("/threads", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(t, n) {
    return this._client.get(P`/threads/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(t, n, r) {
    return this._client.post(P`/threads/${t}`, {
      body: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(t, n) {
    return this._client.delete(P`/threads/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  createAndRun(t, n) {
    return this._client.post("/threads/runs", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
      stream: t.stream ?? !1
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(t, n) {
    const r = await this.createAndRun(t, n);
    return await this.runs.poll(r.id, { thread_id: r.thread_id }, n);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(t, n) {
    return eo.createThreadAssistantStream(t, this._client.beta.threads, n);
  }
}
hl.Runs = Wp;
hl.Messages = FS;
let pi = class extends se {
  constructor() {
    super(...arguments), this.realtime = new dl(this._client), this.chatkit = new fl(this._client), this.assistants = new MS(this._client), this.threads = new hl(this._client);
  }
};
pi.Realtime = dl;
pi.ChatKit = fl;
pi.Assistants = MS;
pi.Threads = hl;
let qS = class extends se {
  create(t, n) {
    return this._client.post("/completions", { body: t, ...n, stream: t.stream ?? !1 });
  }
};
class BS extends se {
  /**
   * Retrieve Container File Content
   */
  retrieve(t, n, r) {
    const { container_id: s } = n;
    return this._client.get(P`/containers/${s}/files/${t}/content`, {
      ...r,
      headers: J([{ Accept: "application/binary" }, r?.headers]),
      __binaryResponse: !0
    });
  }
}
let Jp = class extends se {
  constructor() {
    super(...arguments), this.content = new BS(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(t, n, r) {
    return this._client.post(P`/containers/${t}/files`, ws({ body: n, ...r }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(t, n, r) {
    const { container_id: s } = n;
    return this._client.get(P`/containers/${s}/files/${t}`, r);
  }
  /**
   * List Container files
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/containers/${t}/files`, at, {
      query: n,
      ...r
    });
  }
  /**
   * Delete Container File
   */
  delete(t, n, r) {
    const { container_id: s } = n;
    return this._client.delete(P`/containers/${s}/files/${t}`, {
      ...r,
      headers: J([{ Accept: "*/*" }, r?.headers])
    });
  }
};
Jp.Content = BS;
class Kp extends se {
  constructor() {
    super(...arguments), this.files = new Jp(this._client);
  }
  /**
   * Create Container
   */
  create(t, n) {
    return this._client.post("/containers", { body: t, ...n });
  }
  /**
   * Retrieve Container
   */
  retrieve(t, n) {
    return this._client.get(P`/containers/${t}`, n);
  }
  /**
   * List Containers
   */
  list(t = {}, n) {
    return this._client.getAPIList("/containers", at, { query: t, ...n });
  }
  /**
   * Delete Container
   */
  delete(t, n) {
    return this._client.delete(P`/containers/${t}`, {
      ...n,
      headers: J([{ Accept: "*/*" }, n?.headers])
    });
  }
}
Kp.Files = Jp;
class ZS extends se {
  /**
   * Create items in a conversation with the given ID.
   */
  create(t, n, r) {
    const { include: s, ...i } = n;
    return this._client.post(P`/conversations/${t}/items`, {
      query: { include: s },
      body: i,
      ...r
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(t, n, r) {
    const { conversation_id: s, ...i } = n;
    return this._client.get(P`/conversations/${s}/items/${t}`, { query: i, ...r });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/conversations/${t}/items`, vc, { query: n, ...r });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(t, n, r) {
    const { conversation_id: s } = n;
    return this._client.delete(P`/conversations/${s}/items/${t}`, r);
  }
}
class Yp extends se {
  constructor() {
    super(...arguments), this.items = new ZS(this._client);
  }
  /**
   * Create a conversation.
   */
  create(t = {}, n) {
    return this._client.post("/conversations", { body: t, ...n });
  }
  /**
   * Get a conversation
   */
  retrieve(t, n) {
    return this._client.get(P`/conversations/${t}`, n);
  }
  /**
   * Update a conversation
   */
  update(t, n, r) {
    return this._client.post(P`/conversations/${t}`, { body: n, ...r });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(t, n) {
    return this._client.delete(P`/conversations/${t}`, n);
  }
}
Yp.Items = ZS;
let VS = class extends se {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(t, n) {
    const r = !!t.encoding_format;
    let s = r ? t.encoding_format : "base64";
    r && bt(this._client).debug("embeddings/user defined encoding_format:", t.encoding_format);
    const i = this._client.post("/embeddings", {
      body: {
        ...t,
        encoding_format: s
      },
      ...n
    });
    return r ? i : (bt(this._client).debug("embeddings/decoding base64 embeddings from base64"), i._thenUnwrap((a) => (a && a.data && a.data.forEach((o) => {
      const u = o.embedding;
      o.embedding = j1(u);
    }), a)));
  }
};
class HS extends se {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(t, n, r) {
    const { eval_id: s, run_id: i } = n;
    return this._client.get(P`/evals/${s}/runs/${i}/output_items/${t}`, r);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(t, n, r) {
    const { eval_id: s, ...i } = n;
    return this._client.getAPIList(P`/evals/${s}/runs/${t}/output_items`, at, { query: i, ...r });
  }
}
class Xp extends se {
  constructor() {
    super(...arguments), this.outputItems = new HS(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(t, n, r) {
    return this._client.post(P`/evals/${t}/runs`, { body: n, ...r });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(t, n, r) {
    const { eval_id: s } = n;
    return this._client.get(P`/evals/${s}/runs/${t}`, r);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/evals/${t}/runs`, at, {
      query: n,
      ...r
    });
  }
  /**
   * Delete an eval run.
   */
  delete(t, n, r) {
    const { eval_id: s } = n;
    return this._client.delete(P`/evals/${s}/runs/${t}`, r);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(t, n, r) {
    const { eval_id: s } = n;
    return this._client.post(P`/evals/${s}/runs/${t}`, r);
  }
}
Xp.OutputItems = HS;
class Qp extends se {
  constructor() {
    super(...arguments), this.runs = new Xp(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(t, n) {
    return this._client.post("/evals", { body: t, ...n });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(t, n) {
    return this._client.get(P`/evals/${t}`, n);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(t, n, r) {
    return this._client.post(P`/evals/${t}`, { body: n, ...r });
  }
  /**
   * List evaluations for a project.
   */
  list(t = {}, n) {
    return this._client.getAPIList("/evals", at, { query: t, ...n });
  }
  /**
   * Delete an evaluation.
   */
  delete(t, n) {
    return this._client.delete(P`/evals/${t}`, n);
  }
}
Qp.Runs = Xp;
let GS = class extends se {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(t, n) {
    return this._client.post("/files", ws({ body: t, ...n }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(t, n) {
    return this._client.get(P`/files/${t}`, n);
  }
  /**
   * Returns a list of files.
   */
  list(t = {}, n) {
    return this._client.getAPIList("/files", at, { query: t, ...n });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(t, n) {
    return this._client.delete(P`/files/${t}`, n);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(t, n) {
    return this._client.get(P`/files/${t}/content`, {
      ...n,
      headers: J([{ Accept: "application/binary" }, n?.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(t, { pollInterval: n = 5e3, maxWait: r = 1800 * 1e3 } = {}) {
    const s = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), i = Date.now();
    let a = await this.retrieve(t);
    for (; !a.status || !s.has(a.status); )
      if (await Oo(n), a = await this.retrieve(t), Date.now() - i > r)
        throw new ul({
          message: `Giving up on waiting for file ${t} to finish processing after ${r} milliseconds.`
        });
    return a;
  }
};
class WS extends se {
}
let JS = class extends se {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(t, n) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body: t, ...n });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(t, n) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body: t, ...n });
  }
};
class em extends se {
  constructor() {
    super(...arguments), this.graders = new JS(this._client);
  }
}
em.Graders = JS;
class KS extends se {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(t, n, r) {
    return this._client.getAPIList(P`/fine_tuning/checkpoints/${t}/permissions`, ll, { body: n, method: "post", ...r });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(t, n = {}, r) {
    return this._client.get(P`/fine_tuning/checkpoints/${t}/permissions`, {
      query: n,
      ...r
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(t, n, r) {
    const { fine_tuned_model_checkpoint: s } = n;
    return this._client.delete(P`/fine_tuning/checkpoints/${s}/permissions/${t}`, r);
  }
}
let tm = class extends se {
  constructor() {
    super(...arguments), this.permissions = new KS(this._client);
  }
};
tm.Permissions = KS;
class YS extends se {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/fine_tuning/jobs/${t}/checkpoints`, at, { query: n, ...r });
  }
}
class nm extends se {
  constructor() {
    super(...arguments), this.checkpoints = new YS(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(t, n) {
    return this._client.post("/fine_tuning/jobs", { body: t, ...n });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(t, n) {
    return this._client.get(P`/fine_tuning/jobs/${t}`, n);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    return this._client.getAPIList("/fine_tuning/jobs", at, { query: t, ...n });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(t, n) {
    return this._client.post(P`/fine_tuning/jobs/${t}/cancel`, n);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(t, n = {}, r) {
    return this._client.getAPIList(P`/fine_tuning/jobs/${t}/events`, at, { query: n, ...r });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(t, n) {
    return this._client.post(P`/fine_tuning/jobs/${t}/pause`, n);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(t, n) {
    return this._client.post(P`/fine_tuning/jobs/${t}/resume`, n);
  }
}
nm.Checkpoints = YS;
class mi extends se {
  constructor() {
    super(...arguments), this.methods = new WS(this._client), this.jobs = new nm(this._client), this.checkpoints = new tm(this._client), this.alpha = new em(this._client);
  }
}
mi.Methods = WS;
mi.Jobs = nm;
mi.Checkpoints = tm;
mi.Alpha = em;
class XS extends se {
}
class rm extends se {
  constructor() {
    super(...arguments), this.graderModels = new XS(this._client);
  }
}
rm.GraderModels = XS;
class QS extends se {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(t, n) {
    return this._client.post("/images/variations", ws({ body: t, ...n }, this._client));
  }
  edit(t, n) {
    return this._client.post("/images/edits", ws({ body: t, ...n, stream: t.stream ?? !1 }, this._client));
  }
  generate(t, n) {
    return this._client.post("/images/generations", { body: t, ...n, stream: t.stream ?? !1 });
  }
}
let eT = class extends se {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(t, n) {
    return this._client.get(P`/models/${t}`, n);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(t) {
    return this._client.getAPIList("/models", ll, t);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(t, n) {
    return this._client.delete(P`/models/${t}`, n);
  }
};
class tT extends se {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(t, n) {
    return this._client.post("/moderations", { body: t, ...n });
  }
}
class nT extends se {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(t, n, r) {
    return this._client.post(P`/realtime/calls/${t}/accept`, {
      body: n,
      ...r,
      headers: J([{ Accept: "*/*" }, r?.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(t, n) {
    return this._client.post(P`/realtime/calls/${t}/hangup`, {
      ...n,
      headers: J([{ Accept: "*/*" }, n?.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(t, n, r) {
    return this._client.post(P`/realtime/calls/${t}/refer`, {
      body: n,
      ...r,
      headers: J([{ Accept: "*/*" }, r?.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(t, n = {}, r) {
    return this._client.post(P`/realtime/calls/${t}/reject`, {
      body: n,
      ...r,
      headers: J([{ Accept: "*/*" }, r?.headers])
    });
  }
}
class rT extends se {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(t, n) {
    return this._client.post("/realtime/client_secrets", { body: t, ...n });
  }
}
class pl extends se {
  constructor() {
    super(...arguments), this.clientSecrets = new rT(this._client), this.calls = new nT(this._client);
  }
}
pl.ClientSecrets = rT;
pl.Calls = nT;
function L1(e, t) {
  return !t || !U1(t) ? {
    ...e,
    output_parsed: null,
    output: e.output.map((n) => n.type === "function_call" ? {
      ...n,
      parsed_arguments: null
    } : n.type === "message" ? {
      ...n,
      content: n.content.map((r) => ({
        ...r,
        parsed: null
      }))
    } : n)
  } : sT(e, t);
}
function sT(e, t) {
  const n = e.output.map((s) => {
    if (s.type === "function_call")
      return {
        ...s,
        parsed_arguments: q1(t, s)
      };
    if (s.type === "message") {
      const i = s.content.map((a) => a.type === "output_text" ? {
        ...a,
        parsed: D1(t, a.text)
      } : a);
      return {
        ...s,
        content: i
      };
    }
    return s;
  }), r = Object.assign({}, e, { output: n });
  return Object.getOwnPropertyDescriptor(e, "output_text") || Uh(r), Object.defineProperty(r, "output_parsed", {
    enumerable: !0,
    get() {
      for (const s of r.output)
        if (s.type === "message") {
          for (const i of s.content)
            if (i.type === "output_text" && i.parsed !== null)
              return i.parsed;
        }
      return null;
    }
  }), r;
}
function D1(e, t) {
  return e.text?.format?.type !== "json_schema" ? null : "$parseRaw" in e.text?.format ? (e.text?.format).$parseRaw(t) : JSON.parse(t);
}
function U1(e) {
  return !!qp(e.text?.format);
}
function F1(e) {
  return e?.$brand === "auto-parseable-tool";
}
function z1(e, t) {
  return e.find((n) => n.type === "function" && n.name === t);
}
function q1(e, t) {
  const n = z1(e.tools ?? [], t.name);
  return {
    ...t,
    ...t,
    parsed_arguments: F1(n) ? n.$parseRaw(t.arguments) : n?.strict ? JSON.parse(t.arguments) : null
  };
}
function Uh(e) {
  const t = [];
  for (const n of e.output)
    if (n.type === "message")
      for (const r of n.content)
        r.type === "output_text" && t.push(r.text);
  e.output_text = t.join("");
}
var Ps, iu, vr, au, I_, A_, C_, $_;
class sm extends Zp {
  constructor(t) {
    super(), Ps.add(this), iu.set(this, void 0), vr.set(this, void 0), au.set(this, void 0), de(this, iu, t);
  }
  static createResponse(t, n, r) {
    const s = new sm(n);
    return s._run(() => s._createOrRetrieveResponse(t, n, {
      ...r,
      headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" }
    })), s;
  }
  async _createOrRetrieveResponse(t, n, r) {
    const s = r?.signal;
    s && (s.aborted && this.controller.abort(), s.addEventListener("abort", () => this.controller.abort())), I(this, Ps, "m", I_).call(this);
    let i, a = null;
    "response_id" in n ? (i = await t.responses.retrieve(n.response_id, { stream: !0 }, { ...r, signal: this.controller.signal, stream: !0 }), a = n.starting_after ?? null) : i = await t.responses.create({ ...n, stream: !0 }, { ...r, signal: this.controller.signal }), this._connected();
    for await (const o of i)
      I(this, Ps, "m", A_).call(this, o, a);
    if (i.controller.signal?.aborted)
      throw new an();
    return I(this, Ps, "m", C_).call(this);
  }
  [(iu = /* @__PURE__ */ new WeakMap(), vr = /* @__PURE__ */ new WeakMap(), au = /* @__PURE__ */ new WeakMap(), Ps = /* @__PURE__ */ new WeakSet(), I_ = function() {
    this.ended || de(this, vr, void 0);
  }, A_ = function(n, r) {
    if (this.ended)
      return;
    const s = (a, o) => {
      (r == null || o.sequence_number > r) && this._emit(a, o);
    }, i = I(this, Ps, "m", $_).call(this, n);
    switch (s("event", n), n.type) {
      case "response.output_text.delta": {
        const a = i.output[n.output_index];
        if (!a)
          throw new ue(`missing output at index ${n.output_index}`);
        if (a.type === "message") {
          const o = a.content[n.content_index];
          if (!o)
            throw new ue(`missing content at index ${n.content_index}`);
          if (o.type !== "output_text")
            throw new ue(`expected content to be 'output_text', got ${o.type}`);
          s("response.output_text.delta", {
            ...n,
            snapshot: o.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const a = i.output[n.output_index];
        if (!a)
          throw new ue(`missing output at index ${n.output_index}`);
        a.type === "function_call" && s("response.function_call_arguments.delta", {
          ...n,
          snapshot: a.arguments
        });
        break;
      }
      default:
        s(n.type, n);
        break;
    }
  }, C_ = function() {
    if (this.ended)
      throw new ue("stream has ended, this shouldn't happen");
    const n = I(this, vr, "f");
    if (!n)
      throw new ue("request ended without sending any events");
    de(this, vr, void 0);
    const r = B1(n, I(this, iu, "f"));
    return de(this, au, r), r;
  }, $_ = function(n) {
    let r = I(this, vr, "f");
    if (!r) {
      if (n.type !== "response.created")
        throw new ue(`When snapshot hasn't been set yet, expected 'response.created' event, got ${n.type}`);
      return r = de(this, vr, n.response), r;
    }
    switch (n.type) {
      case "response.output_item.added": {
        r.output.push(n.item);
        break;
      }
      case "response.content_part.added": {
        const s = r.output[n.output_index];
        if (!s)
          throw new ue(`missing output at index ${n.output_index}`);
        const i = s.type, a = n.part;
        i === "message" && a.type !== "reasoning_text" ? s.content.push(a) : i === "reasoning" && a.type === "reasoning_text" && (s.content || (s.content = []), s.content.push(a));
        break;
      }
      case "response.output_text.delta": {
        const s = r.output[n.output_index];
        if (!s)
          throw new ue(`missing output at index ${n.output_index}`);
        if (s.type === "message") {
          const i = s.content[n.content_index];
          if (!i)
            throw new ue(`missing content at index ${n.content_index}`);
          if (i.type !== "output_text")
            throw new ue(`expected content to be 'output_text', got ${i.type}`);
          i.text += n.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const s = r.output[n.output_index];
        if (!s)
          throw new ue(`missing output at index ${n.output_index}`);
        s.type === "function_call" && (s.arguments += n.delta);
        break;
      }
      case "response.reasoning_text.delta": {
        const s = r.output[n.output_index];
        if (!s)
          throw new ue(`missing output at index ${n.output_index}`);
        if (s.type === "reasoning") {
          const i = s.content?.[n.content_index];
          if (!i)
            throw new ue(`missing content at index ${n.content_index}`);
          if (i.type !== "reasoning_text")
            throw new ue(`expected content to be 'reasoning_text', got ${i.type}`);
          i.text += n.delta;
        }
        break;
      }
      case "response.completed": {
        de(this, vr, n.response);
        break;
      }
    }
    return r;
  }, Symbol.asyncIterator)]() {
    const t = [], n = [];
    let r = !1;
    return this.on("event", (s) => {
      const i = n.shift();
      i ? i.resolve(s) : t.push(s);
    }), this.on("end", () => {
      r = !0;
      for (const s of n)
        s.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), this.on("error", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), {
      next: async () => t.length ? { value: t.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((i, a) => n.push({ resolve: i, reject: a })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const t = I(this, au, "f");
    if (!t)
      throw new ue("stream ended without producing a ChatCompletion");
    return t;
  }
}
function B1(e, t) {
  return L1(e, t);
}
class iT extends se {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/responses/${t}/input_items`, at, { query: n, ...r });
  }
}
class aT extends se {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(t = {}, n) {
    return this._client.post("/responses/input_tokens", { body: t, ...n });
  }
}
class ml extends se {
  constructor() {
    super(...arguments), this.inputItems = new iT(this._client), this.inputTokens = new aT(this._client);
  }
  create(t, n) {
    return this._client.post("/responses", { body: t, ...n, stream: t.stream ?? !1 })._thenUnwrap((r) => ("object" in r && r.object === "response" && Uh(r), r));
  }
  retrieve(t, n = {}, r) {
    return this._client.get(P`/responses/${t}`, {
      query: n,
      ...r,
      stream: n?.stream ?? !1
    })._thenUnwrap((s) => ("object" in s && s.object === "response" && Uh(s), s));
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(t, n) {
    return this._client.delete(P`/responses/${t}`, {
      ...n,
      headers: J([{ Accept: "*/*" }, n?.headers])
    });
  }
  parse(t, n) {
    return this._client.responses.create(t, n)._thenUnwrap((r) => sT(r, t));
  }
  /**
   * Creates a model response stream
   */
  stream(t, n) {
    return sm.createResponse(this._client, t, n);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(t, n) {
    return this._client.post(P`/responses/${t}/cancel`, n);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact({
   *   model: 'gpt-5.2',
   * });
   * ```
   */
  compact(t, n) {
    return this._client.post("/responses/compact", { body: t, ...n });
  }
}
ml.InputItems = iT;
ml.InputTokens = aT;
class oT extends se {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(t, n, r) {
    return this._client.post(P`/uploads/${t}/parts`, ws({ body: n, ...r }, this._client));
  }
}
class im extends se {
  constructor() {
    super(...arguments), this.parts = new oT(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(t, n) {
    return this._client.post("/uploads", { body: t, ...n });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(t, n) {
    return this._client.post(P`/uploads/${t}/cancel`, n);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(t, n, r) {
    return this._client.post(P`/uploads/${t}/complete`, { body: n, ...r });
  }
}
im.Parts = oT;
const Z1 = async (e) => {
  const t = await Promise.allSettled(e), n = t.filter((s) => s.status === "rejected");
  if (n.length) {
    for (const s of n)
      console.error(s.reason);
    throw new Error(`${n.length} promise(s) failed - see the above errors`);
  }
  const r = [];
  for (const s of t)
    s.status === "fulfilled" && r.push(s.value);
  return r;
};
class uT extends se {
  /**
   * Create a vector store file batch.
   */
  create(t, n, r) {
    return this._client.post(P`/vector_stores/${t}/file_batches`, {
      body: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(t, n, r) {
    const { vector_store_id: s } = n;
    return this._client.get(P`/vector_stores/${s}/file_batches/${t}`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(t, n, r) {
    const { vector_store_id: s } = n;
    return this._client.post(P`/vector_stores/${s}/file_batches/${t}/cancel`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(t, n, r) {
    const s = await this.create(t, n);
    return await this.poll(t, s.id, r);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(t, n, r) {
    const { vector_store_id: s, ...i } = n;
    return this._client.getAPIList(P`/vector_stores/${s}/file_batches/${t}/files`, at, { query: i, ...r, headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(t, n, r) {
    const s = J([
      r?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": r?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    for (; ; ) {
      const { data: i, response: a } = await this.retrieve(n, { vector_store_id: t }, {
        ...r,
        headers: s
      }).withResponse();
      switch (i.status) {
        case "in_progress":
          let o = 5e3;
          if (r?.pollIntervalMs)
            o = r.pollIntervalMs;
          else {
            const u = a.headers.get("openai-poll-after-ms");
            if (u) {
              const c = parseInt(u);
              isNaN(c) || (o = c);
            }
          }
          await Oo(o);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return i;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(t, { files: n, fileIds: r = [] }, s) {
    if (n == null || n.length == 0)
      throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
    const i = s?.maxConcurrency ?? 5, a = Math.min(i, n.length), o = this._client, u = n.values(), c = [...r];
    async function l(f) {
      for (let h of f) {
        const p = await o.files.create({ file: h, purpose: "assistants" }, s);
        c.push(p.id);
      }
    }
    const d = Array(a).fill(u).map(l);
    return await Z1(d), await this.createAndPoll(t, {
      file_ids: c
    });
  }
}
let cT = class extends se {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(t, n, r) {
    return this._client.post(P`/vector_stores/${t}/files`, {
      body: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(t, n, r) {
    const { vector_store_id: s } = n;
    return this._client.get(P`/vector_stores/${s}/files/${t}`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(t, n, r) {
    const { vector_store_id: s, ...i } = n;
    return this._client.post(P`/vector_stores/${s}/files/${t}`, {
      body: i,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(t, n = {}, r) {
    return this._client.getAPIList(P`/vector_stores/${t}/files`, at, {
      query: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(t, n, r) {
    const { vector_store_id: s } = n;
    return this._client.delete(P`/vector_stores/${s}/files/${t}`, {
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(t, n, r) {
    const s = await this.create(t, n, r);
    return await this.poll(t, s.id, r);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(t, n, r) {
    const s = J([
      r?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": r?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    for (; ; ) {
      const i = await this.retrieve(n, {
        vector_store_id: t
      }, { ...r, headers: s }).withResponse(), a = i.data;
      switch (a.status) {
        case "in_progress":
          let o = 5e3;
          if (r?.pollIntervalMs)
            o = r.pollIntervalMs;
          else {
            const u = i.response.headers.get("openai-poll-after-ms");
            if (u) {
              const c = parseInt(u);
              isNaN(c) || (o = c);
            }
          }
          await Oo(o);
          break;
        case "failed":
        case "completed":
          return a;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(t, n, r) {
    const s = await this._client.files.create({ file: n, purpose: "assistants" }, r);
    return this.create(t, { file_id: s.id }, r);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(t, n, r) {
    const s = await this.upload(t, n, r);
    return await this.poll(t, s.id, r);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(t, n, r) {
    const { vector_store_id: s } = n;
    return this._client.getAPIList(P`/vector_stores/${s}/files/${t}/content`, ll, { ...r, headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers]) });
  }
};
class gl extends se {
  constructor() {
    super(...arguments), this.files = new cT(this._client), this.fileBatches = new uT(this._client);
  }
  /**
   * Create a vector store.
   */
  create(t, n) {
    return this._client.post("/vector_stores", {
      body: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(t, n) {
    return this._client.get(P`/vector_stores/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(t, n, r) {
    return this._client.post(P`/vector_stores/${t}`, {
      body: n,
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(t = {}, n) {
    return this._client.getAPIList("/vector_stores", at, {
      query: t,
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(t, n) {
    return this._client.delete(P`/vector_stores/${t}`, {
      ...n,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, n?.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(t, n, r) {
    return this._client.getAPIList(P`/vector_stores/${t}/search`, ll, {
      body: n,
      method: "post",
      ...r,
      headers: J([{ "OpenAI-Beta": "assistants=v2" }, r?.headers])
    });
  }
}
gl.Files = cT;
gl.FileBatches = uT;
class lT extends se {
  /**
   * Create a video
   */
  create(t, n) {
    return this._client.post("/videos", g_({ body: t, ...n }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(t, n) {
    return this._client.get(P`/videos/${t}`, n);
  }
  /**
   * List videos
   */
  list(t = {}, n) {
    return this._client.getAPIList("/videos", vc, { query: t, ...n });
  }
  /**
   * Delete a video
   */
  delete(t, n) {
    return this._client.delete(P`/videos/${t}`, n);
  }
  /**
   * Download video content
   */
  downloadContent(t, n = {}, r) {
    return this._client.get(P`/videos/${t}/content`, {
      query: n,
      ...r,
      headers: J([{ Accept: "application/binary" }, r?.headers]),
      __binaryResponse: !0
    });
  }
  /**
   * Create a video remix
   */
  remix(t, n, r) {
    return this._client.post(P`/videos/${t}/remix`, g_({ body: n, ...r }, this._client));
  }
}
var Zs, dT, oc;
class fT extends se {
  constructor() {
    super(...arguments), Zs.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(t, n, r = this._client.webhookSecret, s = 300) {
    return await this.verifySignature(t, n, r, s), JSON.parse(t);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(t, n, r = this._client.webhookSecret, s = 300) {
    if (typeof crypto > "u" || typeof crypto.subtle.importKey != "function" || typeof crypto.subtle.verify != "function")
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    I(this, Zs, "m", dT).call(this, r);
    const i = J([n]).values, a = I(this, Zs, "m", oc).call(this, i, "webhook-signature"), o = I(this, Zs, "m", oc).call(this, i, "webhook-timestamp"), u = I(this, Zs, "m", oc).call(this, i, "webhook-id"), c = parseInt(o, 10);
    if (isNaN(c))
      throw new Ra("Invalid webhook timestamp format");
    const l = Math.floor(Date.now() / 1e3);
    if (l - c > s)
      throw new Ra("Webhook timestamp is too old");
    if (c > l + s)
      throw new Ra("Webhook timestamp is too new");
    const d = a.split(" ").map((g) => g.startsWith("v1,") ? g.substring(3) : g), f = r.startsWith("whsec_") ? Buffer.from(r.replace("whsec_", ""), "base64") : Buffer.from(r, "utf-8"), h = u ? `${u}.${o}.${t}` : `${o}.${t}`, p = await crypto.subtle.importKey("raw", f, { name: "HMAC", hash: "SHA-256" }, !1, ["verify"]);
    for (const g of d)
      try {
        const m = Buffer.from(g, "base64");
        if (await crypto.subtle.verify("HMAC", p, m, new TextEncoder().encode(h)))
          return;
      } catch {
        continue;
      }
    throw new Ra("The given webhook signature does not match the expected signature");
  }
}
Zs = /* @__PURE__ */ new WeakSet(), dT = function(t) {
  if (typeof t != "string" || t.length === 0)
    throw new Error("The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function");
}, oc = function(t, n) {
  if (!t)
    throw new Error("Headers are required");
  const r = t.get(n);
  if (r == null)
    throw new Error(`Missing required header: ${n}`);
  return r;
};
var Fh, am, uc, hT;
class xe {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: t = Rs("OPENAI_BASE_URL"), apiKey: n = Rs("OPENAI_API_KEY"), organization: r = Rs("OPENAI_ORG_ID") ?? null, project: s = Rs("OPENAI_PROJECT_ID") ?? null, webhookSecret: i = Rs("OPENAI_WEBHOOK_SECRET") ?? null, ...a } = {}) {
    if (Fh.add(this), uc.set(this, void 0), this.completions = new qS(this), this.chat = new Gp(this), this.embeddings = new VS(this), this.files = new GS(this), this.images = new QS(this), this.audio = new Ao(this), this.moderations = new tT(this), this.models = new eT(this), this.fineTuning = new mi(this), this.graders = new rm(this), this.vectorStores = new gl(this), this.webhooks = new fT(this), this.beta = new pi(this), this.batches = new NS(this), this.uploads = new im(this), this.responses = new ml(this), this.realtime = new pl(this), this.conversations = new Yp(this), this.evals = new Qp(this), this.containers = new Kp(this), this.videos = new lT(this), n === void 0)
      throw new ue("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    const o = {
      apiKey: n,
      organization: r,
      project: s,
      webhookSecret: i,
      ...a,
      baseURL: t || "https://api.openai.com/v1"
    };
    if (!o.dangerouslyAllowBrowser && VI())
      throw new ue(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    this.baseURL = o.baseURL, this.timeout = o.timeout ?? am.DEFAULT_TIMEOUT, this.logger = o.logger ?? console;
    const u = "warn";
    this.logLevel = u, this.logLevel = p_(o.logLevel, "ClientOptions.logLevel", this) ?? p_(Rs("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? u, this.fetchOptions = o.fetchOptions, this.maxRetries = o.maxRetries ?? 2, this.fetch = o.fetch ?? KI(), de(this, uc, XI), this._options = o, this.apiKey = typeof n == "string" ? n : "Missing Key", this.organization = r, this.project = s, this.webhookSecret = i;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(t) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...t
    });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: t, nulls: n }) {
  }
  async authHeaders(t) {
    return J([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(t) {
    return s1(t, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${qs}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${Nb()}`;
  }
  makeStatusError(t, n, r, s) {
    return Ht.generate(t, n, r, s);
  }
  async _callApiKey() {
    const t = this._options.apiKey;
    if (typeof t != "function")
      return !1;
    let n;
    try {
      n = await t();
    } catch (r) {
      throw r instanceof ue ? r : new ue(
        `Failed to get token from 'apiKey' function: ${r.message}`,
        // @ts-ignore
        { cause: r }
      );
    }
    if (typeof n != "string" || !n)
      throw new ue(`Expected 'apiKey' function argument to return a string but it returned ${n}`);
    return this.apiKey = n, !0;
  }
  buildURL(t, n, r) {
    const s = !I(this, Fh, "m", hT).call(this) && r || this.baseURL, i = FI(t) ? new URL(t) : new URL(s + (s.endsWith("/") && t.startsWith("/") ? t.slice(1) : t)), a = this.defaultQuery();
    return zI(a) || (n = { ...a, ...n }), typeof n == "object" && n && !Array.isArray(n) && (i.search = this.stringifyQuery(n)), i.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(t) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(t, { url: n, options: r }) {
  }
  get(t, n) {
    return this.methodRequest("get", t, n);
  }
  post(t, n) {
    return this.methodRequest("post", t, n);
  }
  patch(t, n) {
    return this.methodRequest("patch", t, n);
  }
  put(t, n) {
    return this.methodRequest("put", t, n);
  }
  delete(t, n) {
    return this.methodRequest("delete", t, n);
  }
  methodRequest(t, n, r) {
    return this.request(Promise.resolve(r).then((s) => ({ method: t, path: n, ...s })));
  }
  request(t, n = null) {
    return new nS(this, this.makeRequest(t, n, void 0));
  }
  async makeRequest(t, n, r) {
    const s = await t, i = s.maxRetries ?? this.maxRetries;
    n == null && (n = i), await this.prepareOptions(s);
    const { req: a, url: o, timeout: u } = await this.buildRequest(s, {
      retryCount: i - n
    });
    await this.prepareRequest(a, { url: o, options: s });
    const c = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0"), l = r === void 0 ? "" : `, retryOf: ${r}`, d = Date.now();
    if (bt(this).debug(`[${c}] sending request`, rs({
      retryOfRequestLogID: r,
      method: s.method,
      url: o,
      options: s,
      headers: a.headers
    })), s.signal?.aborted)
      throw new an();
    const f = new AbortController(), h = await this.fetchWithTimeout(o, a, u, f).catch(Oh), p = Date.now();
    if (h instanceof globalThis.Error) {
      const _ = `retrying, ${n} attempts remaining`;
      if (s.signal?.aborted)
        throw new an();
      const y = kh(h) || /timed? ?out/i.test(String(h) + ("cause" in h ? String(h.cause) : ""));
      if (n)
        return bt(this).info(`[${c}] connection ${y ? "timed out" : "failed"} - ${_}`), bt(this).debug(`[${c}] connection ${y ? "timed out" : "failed"} (${_})`, rs({
          retryOfRequestLogID: r,
          url: o,
          durationMs: p - d,
          message: h.message
        })), this.retryRequest(s, n, r ?? c);
      throw bt(this).info(`[${c}] connection ${y ? "timed out" : "failed"} - error; no more retries left`), bt(this).debug(`[${c}] connection ${y ? "timed out" : "failed"} (error; no more retries left)`, rs({
        retryOfRequestLogID: r,
        url: o,
        durationMs: p - d,
        message: h.message
      })), y ? new ul() : new ol({ cause: h });
    }
    const g = [...h.headers.entries()].filter(([_]) => _ === "x-request-id").map(([_, y]) => ", " + _ + ": " + JSON.stringify(y)).join(""), m = `[${c}${l}${g}] ${a.method} ${o} ${h.ok ? "succeeded" : "failed"} with status ${h.status} in ${p - d}ms`;
    if (!h.ok) {
      const _ = await this.shouldRetry(h);
      if (n && _) {
        const O = `retrying, ${n} attempts remaining`;
        return await YI(h.body), bt(this).info(`${m} - ${O}`), bt(this).debug(`[${c}] response error (${O})`, rs({
          retryOfRequestLogID: r,
          url: h.url,
          status: h.status,
          headers: h.headers,
          durationMs: p - d
        })), this.retryRequest(s, n, r ?? c, h.headers);
      }
      const y = _ ? "error; no more retries left" : "error; not retryable";
      bt(this).info(`${m} - ${y}`);
      const b = await h.text().catch((O) => Oh(O).message), T = ZI(b), x = T ? void 0 : b;
      throw bt(this).debug(`[${c}] response error (${y})`, rs({
        retryOfRequestLogID: r,
        url: h.url,
        status: h.status,
        headers: h.headers,
        message: x,
        durationMs: Date.now() - d
      })), this.makeStatusError(h.status, T, x, h.headers);
    }
    return bt(this).info(m), bt(this).debug(`[${c}] response start`, rs({
      retryOfRequestLogID: r,
      url: h.url,
      status: h.status,
      headers: h.headers,
      durationMs: p - d
    })), { response: h, options: s, controller: f, requestLogID: c, retryOfRequestLogID: r, startTime: d };
  }
  getAPIList(t, n, r) {
    return this.requestAPIList(n, { method: "get", path: t, ...r });
  }
  requestAPIList(t, n) {
    const r = this.makeRequest(n, null, void 0);
    return new h1(this, r, t);
  }
  async fetchWithTimeout(t, n, r, s) {
    const { signal: i, method: a, ...o } = n || {};
    i && i.addEventListener("abort", () => s.abort());
    const u = setTimeout(() => s.abort(), r), c = globalThis.ReadableStream && o.body instanceof globalThis.ReadableStream || typeof o.body == "object" && o.body !== null && Symbol.asyncIterator in o.body, l = {
      signal: s.signal,
      ...c ? { duplex: "half" } : {},
      method: "GET",
      ...o
    };
    a && (l.method = a.toUpperCase());
    try {
      return await this.fetch.call(void 0, t, l);
    } finally {
      clearTimeout(u);
    }
  }
  async shouldRetry(t) {
    const n = t.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : t.status === 408 || t.status === 409 || t.status === 429 || t.status >= 500;
  }
  async retryRequest(t, n, r, s) {
    let i;
    const a = s?.get("retry-after-ms");
    if (a) {
      const u = parseFloat(a);
      Number.isNaN(u) || (i = u);
    }
    const o = s?.get("retry-after");
    if (o && !i) {
      const u = parseFloat(o);
      Number.isNaN(u) ? i = Date.parse(o) - Date.now() : i = u * 1e3;
    }
    if (!(i && 0 <= i && i < 60 * 1e3)) {
      const u = t.maxRetries ?? this.maxRetries;
      i = this.calculateDefaultRetryTimeoutMillis(n, u);
    }
    return await Oo(i), this.makeRequest(t, n - 1, r);
  }
  calculateDefaultRetryTimeoutMillis(t, n) {
    const i = n - t, a = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;
    return a * o * 1e3;
  }
  async buildRequest(t, { retryCount: n = 0 } = {}) {
    const r = { ...t }, { method: s, path: i, query: a, defaultBaseURL: o } = r, u = this.buildURL(i, a, o);
    "timeout" in r && BI("timeout", r.timeout), r.timeout = r.timeout ?? this.timeout;
    const { bodyHeaders: c, body: l } = this.buildBody({ options: r }), d = await this.buildHeaders({ options: t, method: s, bodyHeaders: c, retryCount: n });
    return { req: {
      method: s,
      headers: d,
      ...r.signal && { signal: r.signal },
      ...globalThis.ReadableStream && l instanceof globalThis.ReadableStream && { duplex: "half" },
      ...l && { body: l },
      ...this.fetchOptions ?? {},
      ...r.fetchOptions ?? {}
    }, url: u, timeout: r.timeout };
  }
  async buildHeaders({ options: t, method: n, bodyHeaders: r, retryCount: s }) {
    let i = {};
    this.idempotencyHeader && n !== "get" && (t.idempotencyKey || (t.idempotencyKey = this.defaultIdempotencyKey()), i[this.idempotencyHeader] = t.idempotencyKey);
    const a = J([
      i,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(s),
        ...t.timeout ? { "X-Stainless-Timeout": String(Math.trunc(t.timeout / 1e3)) } : {},
        ...JI(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(t),
      this._options.defaultHeaders,
      r,
      t.headers
    ]);
    return this.validateHeaders(a), a.values;
  }
  buildBody({ options: { body: t, headers: n } }) {
    if (!t)
      return { bodyHeaders: void 0, body: void 0 };
    const r = J([n]);
    return (
      // Pass raw type verbatim
      ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof DataView || typeof t == "string" && // Preserve legacy string encoding behavior for now
      r.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && t instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      t instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      t instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && t instanceof globalThis.ReadableStream ? { bodyHeaders: void 0, body: t } : typeof t == "object" && (Symbol.asyncIterator in t || Symbol.iterator in t && "next" in t && typeof t.next == "function") ? { bodyHeaders: void 0, body: Gb(t) } : I(this, uc, "f").call(this, { body: t, headers: r })
    );
  }
}
am = xe, uc = /* @__PURE__ */ new WeakMap(), Fh = /* @__PURE__ */ new WeakSet(), hT = function() {
  return this.baseURL !== "https://api.openai.com/v1";
};
xe.OpenAI = am;
xe.DEFAULT_TIMEOUT = 6e5;
xe.OpenAIError = ue;
xe.APIError = Ht;
xe.APIConnectionError = ol;
xe.APIConnectionTimeoutError = ul;
xe.APIUserAbortError = an;
xe.NotFoundError = Db;
xe.ConflictError = Ub;
xe.RateLimitError = zb;
xe.BadRequestError = Mb;
xe.AuthenticationError = jb;
xe.InternalServerError = qb;
xe.PermissionDeniedError = Lb;
xe.UnprocessableEntityError = Fb;
xe.InvalidWebhookSignatureError = Ra;
xe.toFile = y1;
xe.Completions = qS;
xe.Chat = Gp;
xe.Embeddings = VS;
xe.Files = GS;
xe.Images = QS;
xe.Audio = Ao;
xe.Moderations = tT;
xe.Models = eT;
xe.FineTuning = mi;
xe.Graders = rm;
xe.VectorStores = gl;
xe.Webhooks = fT;
xe.Beta = pi;
xe.Batches = NS;
xe.Uploads = im;
xe.Responses = ml;
xe.Realtime = pl;
xe.Conversations = Yp;
xe.Evals = Qp;
xe.Containers = Kp;
xe.Videos = lT;
function om(e) {
  if (!e || typeof e != "object") return e;
  let t;
  return e.constructor.name === ul.name && "message" in e && typeof e.message == "string" ? (t = new Error(e.message), t.name = "TimeoutError") : e.constructor.name === an.name && "message" in e && typeof e.message == "string" ? (t = new Error(e.message), t.name = "AbortError") : "status" in e && e.status === 400 && "message" in e && typeof e.message == "string" && e.message.includes("tool_calls") ? t = Qo(e, "INVALID_TOOL_RESULTS") : "status" in e && e.status === 401 ? t = Qo(e, "MODEL_AUTHENTICATION") : "status" in e && e.status === 429 ? t = Qo(e, "MODEL_RATE_LIMIT") : "status" in e && e.status === 404 ? t = Qo(e, "MODEL_NOT_FOUND") : t = e, t;
}
var V1 = Object.defineProperty, $e = (e, t) => {
  for (var n in t) V1(e, n, {
    get: t[n],
    enumerable: !0
  });
};
function gn(e) {
  return typeof e == "object" && e !== null && "type" in e && typeof e.type == "string" && "source_type" in e && (e.source_type === "url" || e.source_type === "base64" || e.source_type === "text" || e.source_type === "id");
}
function um(e) {
  return gn(e) && e.source_type === "url" && "url" in e && typeof e.url == "string";
}
function cm(e) {
  return gn(e) && e.source_type === "base64" && "data" in e && typeof e.data == "string";
}
function H1(e) {
  return gn(e) && e.source_type === "text" && "text" in e && typeof e.text == "string";
}
function pT(e) {
  return gn(e) && e.source_type === "id" && "id" in e && typeof e.id == "string";
}
function mT(e) {
  if (gn(e)) {
    if (e.source_type === "url") return {
      type: "image_url",
      image_url: { url: e.url }
    };
    if (e.source_type === "base64") {
      if (!e.mime_type) throw new Error("mime_type key is required for base64 data.");
      return {
        type: "image_url",
        image_url: { url: `data:${e.mime_type};base64,${e.data}` }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}
function zh(e) {
  const t = e.split(";")[0].split("/");
  if (t.length !== 2) throw new Error(`Invalid mime type: "${e}" - does not match type/subtype format.`);
  const n = t[0].trim(), r = t[1].trim();
  if (n === "" || r === "") throw new Error(`Invalid mime type: "${e}" - type or subtype is empty.`);
  const s = {};
  for (const i of e.split(";").slice(1)) {
    const a = i.split("=");
    if (a.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${e}".`);
    const o = a[0].trim(), u = a[1].trim();
    if (o === "") throw new Error(`Invalid parameter syntax in mime type: "${e}".`);
    s[o] = u;
  }
  return {
    type: n,
    subtype: r,
    parameters: s
  };
}
function Gn({ dataUrl: e, asTypedArray: t = !1 }) {
  const n = e.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let r;
  if (n) {
    r = n[1].toLowerCase();
    const s = t ? Uint8Array.from(atob(n[2]), (i) => i.charCodeAt(0)) : n[2];
    return {
      mime_type: r,
      data: s
    };
  }
}
function Co(e, t) {
  if (e.type === "text") {
    if (!t.fromStandardTextBlock) throw new Error(`Converter for ${t.providerName} does not implement \`fromStandardTextBlock\` method.`);
    return t.fromStandardTextBlock(e);
  }
  if (e.type === "image") {
    if (!t.fromStandardImageBlock) throw new Error(`Converter for ${t.providerName} does not implement \`fromStandardImageBlock\` method.`);
    return t.fromStandardImageBlock(e);
  }
  if (e.type === "audio") {
    if (!t.fromStandardAudioBlock) throw new Error(`Converter for ${t.providerName} does not implement \`fromStandardAudioBlock\` method.`);
    return t.fromStandardAudioBlock(e);
  }
  if (e.type === "file") {
    if (!t.fromStandardFileBlock) throw new Error(`Converter for ${t.providerName} does not implement \`fromStandardFileBlock\` method.`);
    return t.fromStandardFileBlock(e);
  }
  throw new Error(`Unable to convert content block type '${e.type}' to provider-specific format: not recognized.`);
}
function gT(e) {
  return typeof e == "object" && e !== null && "type" in e && "content" in e && (typeof e.content == "string" || Array.isArray(e.content));
}
var Vd, R_;
function G1() {
  return R_ || (R_ = 1, Vd = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return t = typeof t > "u" ? "_" : t, e.replace(/([a-z\d])([A-Z])/g, "$1" + t + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + t + "$2").toLowerCase();
  }), Vd;
}
var W1 = G1();
const J1 = /* @__PURE__ */ Zr(W1);
var ou = { exports: {} }, P_;
function K1() {
  if (P_) return ou.exports;
  P_ = 1;
  const e = /[\p{Lu}]/u, t = /[\p{Ll}]/u, n = /^[\p{Lu}](?![\p{Lu}])/gu, r = /([\p{Alpha}\p{N}_]|$)/u, s = /[_.\- ]+/, i = new RegExp("^" + s.source), a = new RegExp(s.source + r.source, "gu"), o = new RegExp("\\d+" + r.source, "gu"), u = (f, h, p) => {
    let g = !1, m = !1, _ = !1;
    for (let y = 0; y < f.length; y++) {
      const b = f[y];
      g && e.test(b) ? (f = f.slice(0, y) + "-" + f.slice(y), g = !1, _ = m, m = !0, y++) : m && _ && t.test(b) ? (f = f.slice(0, y - 1) + "-" + f.slice(y - 1), _ = m, m = !1, g = !0) : (g = h(b) === b && p(b) !== b, _ = m, m = p(b) === b && h(b) !== b);
    }
    return f;
  }, c = (f, h) => (n.lastIndex = 0, f.replace(n, (p) => h(p))), l = (f, h) => (a.lastIndex = 0, o.lastIndex = 0, f.replace(a, (p, g) => h(g)).replace(o, (p) => h(p))), d = (f, h) => {
    if (!(typeof f == "string" || Array.isArray(f)))
      throw new TypeError("Expected the input to be `string | string[]`");
    if (h = {
      pascalCase: !1,
      preserveConsecutiveUppercase: !1,
      ...h
    }, Array.isArray(f) ? f = f.map((_) => _.trim()).filter((_) => _.length).join("-") : f = f.trim(), f.length === 0)
      return "";
    const p = h.locale === !1 ? (_) => _.toLowerCase() : (_) => _.toLocaleLowerCase(h.locale), g = h.locale === !1 ? (_) => _.toUpperCase() : (_) => _.toLocaleUpperCase(h.locale);
    return f.length === 1 ? h.pascalCase ? g(f) : p(f) : (f !== p(f) && (f = u(f, p, g)), f = f.replace(i, ""), h.preserveConsecutiveUppercase ? f = c(f, p) : f = p(f), h.pascalCase && (f = g(f.charAt(0)) + f.slice(1)), l(f, g));
  };
  return ou.exports = d, ou.exports.default = d, ou.exports;
}
K1();
function Y1(e, t) {
  return t?.[e] || J1(e);
}
function X1(e, t, n) {
  const r = {};
  for (const s in e) Object.hasOwn(e, s) && (r[t(s, n)] = e[s]);
  return r;
}
const _T = "__lc_escaped__";
function Q1(e) {
  return "lc" in e || Object.keys(e).length === 1 && _T in e;
}
function eA(e) {
  return { [_T]: e };
}
function tA(e) {
  return e !== null && typeof e == "object" && "lc_serializable" in e && typeof e.toJSON == "function";
}
function nA(e) {
  let t;
  return e !== null && typeof e == "object" ? "lc_id" in e && Array.isArray(e.lc_id) ? t = e.lc_id : t = [e.constructor?.name ?? "Object"] : t = [typeof e], {
    lc: 1,
    type: "not_implemented",
    id: t
  };
}
function qh(e, t = /* @__PURE__ */ new WeakSet()) {
  if (e !== null && typeof e == "object" && !Array.isArray(e)) {
    if (t.has(e)) return nA(e);
    if (tA(e)) return e;
    t.add(e);
    const n = e;
    if (Q1(n))
      return t.delete(e), eA(n);
    const r = {};
    for (const [s, i] of Object.entries(n)) r[s] = qh(i, t);
    return t.delete(e), r;
  }
  return Array.isArray(e) ? e.map((n) => qh(n, t)) : e;
}
var rA = {};
$e(rA, {
  Serializable: () => ri,
  get_lc_unique_name: () => lm
});
function N_(e) {
  return Array.isArray(e) ? [...e] : { ...e };
}
function sA(e, t) {
  const n = N_(e);
  for (const [r, s] of Object.entries(t)) {
    const [i, ...a] = r.split(".").reverse();
    let o = n;
    for (const u of a.reverse()) {
      if (o[u] === void 0) break;
      o[u] = N_(o[u]), o = o[u];
    }
    o[i] !== void 0 && (o[i] = {
      lc: 1,
      type: "secret",
      id: [s]
    });
  }
  return n;
}
function lm(e) {
  const t = Object.getPrototypeOf(e);
  return typeof e.lc_name == "function" && (typeof t.lc_name != "function" || e.lc_name() !== t.lc_name()) ? e.lc_name() : e.name;
}
var ri = class yT {
  lc_serializable = !1;
  lc_kwargs;
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, lm(this.constructor)];
  }
  /**
  * A map of secrets, which will be omitted from serialization.
  * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
  * Values are the secret ids, which will be used when deserializing.
  */
  get lc_secrets() {
  }
  /**
  * A map of additional attributes to merge with constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the attribute values, which will be serialized.
  * These attributes need to be accepted by the constructor as arguments.
  */
  get lc_attributes() {
  }
  /**
  * A map of aliases for constructor args.
  * Keys are the attribute names, e.g. "foo".
  * Values are the alias that will replace the key in serialization.
  * This is used to eg. make argument names match Python.
  */
  get lc_aliases() {
  }
  /**
  * A manual list of keys that should be serialized.
  * If not overridden, all fields passed into the constructor will be serialized.
  */
  get lc_serializable_keys() {
  }
  constructor(t, ...n) {
    this.lc_serializable_keys !== void 0 ? this.lc_kwargs = Object.fromEntries(Object.entries(t || {}).filter(([r]) => this.lc_serializable_keys?.includes(r))) : this.lc_kwargs = t ?? {};
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof yT || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    const t = {}, n = {}, r = Object.keys(this.lc_kwargs).reduce((u, c) => (u[c] = c in this ? this[c] : this.lc_kwargs[c], u), {});
    for (let u = Object.getPrototypeOf(this); u; u = Object.getPrototypeOf(u))
      Object.assign(t, Reflect.get(u, "lc_aliases", this)), Object.assign(n, Reflect.get(u, "lc_secrets", this)), Object.assign(r, Reflect.get(u, "lc_attributes", this));
    Object.keys(n).forEach((u) => {
      let c = this, l = r;
      const [d, ...f] = u.split(".").reverse();
      for (const h of f.reverse()) {
        if (!(h in c) || c[h] === void 0) return;
        (!(h in l) || l[h] === void 0) && (typeof c[h] == "object" && c[h] != null ? l[h] = {} : Array.isArray(c[h]) && (l[h] = [])), c = c[h], l = l[h];
      }
      d in c && c[d] !== void 0 && (l[d] = l[d] || c[d]);
    });
    const s = {}, i = /* @__PURE__ */ new WeakSet();
    i.add(this);
    for (const [u, c] of Object.entries(r)) s[u] = qh(c, i);
    const a = Object.keys(n).length ? sA(s, n) : s, o = X1(a, Y1, t);
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: o
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};
function re(e, t) {
  return _e(e) && e.type === t;
}
function _e(e) {
  return typeof e == "object" && e !== null;
}
function Nn(e) {
  return Array.isArray(e);
}
function F(e) {
  return typeof e == "string";
}
function Cn(e) {
  return typeof e == "number";
}
function dm(e) {
  return e instanceof Uint8Array;
}
function M_(e) {
  try {
    return JSON.parse(e);
  } catch {
    return;
  }
}
const co = (e) => e();
function iA(e) {
  if (e.type === "char_location" && F(e.document_title) && Cn(e.start_char_index) && Cn(e.end_char_index) && F(e.cited_text)) {
    const { document_title: t, start_char_index: n, end_char_index: r, cited_text: s, ...i } = e;
    return {
      ...i,
      type: "citation",
      source: "char",
      title: t ?? void 0,
      startIndex: n,
      endIndex: r,
      citedText: s
    };
  }
  if (e.type === "page_location" && F(e.document_title) && Cn(e.start_page_number) && Cn(e.end_page_number) && F(e.cited_text)) {
    const { document_title: t, start_page_number: n, end_page_number: r, cited_text: s, ...i } = e;
    return {
      ...i,
      type: "citation",
      source: "page",
      title: t ?? void 0,
      startIndex: n,
      endIndex: r,
      citedText: s
    };
  }
  if (e.type === "content_block_location" && F(e.document_title) && Cn(e.start_block_index) && Cn(e.end_block_index) && F(e.cited_text)) {
    const { document_title: t, start_block_index: n, end_block_index: r, cited_text: s, ...i } = e;
    return {
      ...i,
      type: "citation",
      source: "block",
      title: t ?? void 0,
      startIndex: n,
      endIndex: r,
      citedText: s
    };
  }
  if (e.type === "web_search_result_location" && F(e.url) && F(e.title) && F(e.encrypted_index) && F(e.cited_text)) {
    const { url: t, title: n, encrypted_index: r, cited_text: s, ...i } = e;
    return {
      ...i,
      type: "citation",
      source: "url",
      url: t,
      title: n,
      startIndex: Number(r),
      endIndex: Number(r),
      citedText: s
    };
  }
  if (e.type === "search_result_location" && F(e.source) && F(e.title) && Cn(e.start_block_index) && Cn(e.end_block_index) && F(e.cited_text)) {
    const { source: t, title: n, start_block_index: r, end_block_index: s, cited_text: i, ...a } = e;
    return {
      ...a,
      type: "citation",
      source: "search",
      url: t,
      title: n ?? void 0,
      startIndex: r,
      endIndex: s,
      citedText: i
    };
  }
}
function wT(e) {
  if (re(e, "document") && _e(e.source) && "type" in e.source) {
    if (e.source.type === "base64" && F(e.source.media_type) && F(e.source.data)) return {
      type: "file",
      mimeType: e.source.media_type,
      data: e.source.data
    };
    if (e.source.type === "url" && F(e.source.url)) return {
      type: "file",
      url: e.source.url
    };
    if (e.source.type === "file" && F(e.source.file_id)) return {
      type: "file",
      fileId: e.source.file_id
    };
    if (e.source.type === "text" && F(e.source.data)) return {
      type: "file",
      mimeType: String(e.source.media_type ?? "text/plain"),
      data: e.source.data
    };
  } else if (re(e, "image") && _e(e.source) && "type" in e.source) {
    if (e.source.type === "base64" && F(e.source.media_type) && F(e.source.data)) return {
      type: "image",
      mimeType: e.source.media_type,
      data: e.source.data
    };
    if (e.source.type === "url" && F(e.source.url)) return {
      type: "image",
      url: e.source.url
    };
    if (e.source.type === "file" && F(e.source.file_id)) return {
      type: "image",
      fileId: e.source.file_id
    };
  }
}
function aA(e) {
  function* t() {
    for (const n of e) {
      const r = wT(n);
      r ? yield r : yield n;
    }
  }
  return Array.from(t());
}
function j_(e) {
  function* t() {
    const n = typeof e.content == "string" ? [{
      type: "text",
      text: e.content
    }] : e.content;
    for (const r of n) {
      if (re(r, "text") && F(r.text)) {
        const { text: s, citations: i, ...a } = r;
        if (Nn(i) && i.length) {
          const o = i.reduce((u, c) => {
            const l = iA(c);
            return l ? [...u, l] : u;
          }, []);
          yield {
            ...a,
            type: "text",
            text: s,
            annotations: o
          };
          continue;
        } else {
          yield {
            ...a,
            type: "text",
            text: s
          };
          continue;
        }
      } else if (re(r, "thinking") && F(r.thinking)) {
        const { thinking: s, signature: i, ...a } = r;
        yield {
          ...a,
          type: "reasoning",
          reasoning: s,
          signature: i
        };
        continue;
      } else if (re(r, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "tool_use") && F(r.name) && F(r.id)) {
        yield {
          type: "tool_call",
          id: r.id,
          name: r.name,
          args: r.input
        };
        continue;
      } else if (re(r, "input_json_delta")) {
        if (uA(e) && e.tool_call_chunks?.length) {
          const s = e.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: s.id,
            name: s.name,
            args: s.args,
            index: s.index
          };
          continue;
        }
      } else if (re(r, "server_tool_use") && F(r.name) && F(r.id)) {
        const { name: s, id: i } = r;
        if (s === "web_search") {
          const a = co(() => {
            if (typeof r.input == "string") return r.input;
            if (_e(r.input) && F(r.input.query)) return r.input.query;
            if (F(r.partial_json)) {
              const o = M_(r.partial_json);
              if (o?.query) return o.query;
            }
            return "";
          });
          yield {
            id: i,
            type: "server_tool_call",
            name: "web_search",
            args: { query: a }
          };
          continue;
        } else if (r.name === "code_execution") {
          const a = co(() => {
            if (typeof r.input == "string") return r.input;
            if (_e(r.input) && F(r.input.code)) return r.input.code;
            if (F(r.partial_json)) {
              const o = M_(r.partial_json);
              if (o?.code) return o.code;
            }
            return "";
          });
          yield {
            id: i,
            type: "server_tool_call",
            name: "code_execution",
            args: { code: a }
          };
          continue;
        }
      } else if (re(r, "web_search_tool_result") && F(r.tool_use_id) && Nn(r.content)) {
        const { content: s, tool_use_id: i } = r, a = s.reduce((o, u) => re(u, "web_search_result") ? [...o, u.url] : o, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: i,
          status: "success",
          output: { urls: a }
        };
        continue;
      } else if (re(r, "code_execution_tool_result") && F(r.tool_use_id) && _e(r.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: r.tool_use_id,
          status: "success",
          output: r.content
        };
        continue;
      } else if (re(r, "mcp_tool_use")) {
        yield {
          id: r.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: r.input
        };
        continue;
      } else if (re(r, "mcp_tool_result") && F(r.tool_use_id) && _e(r.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: r.tool_use_id,
          status: "success",
          output: r.content
        };
        continue;
      } else if (re(r, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: r.input
        };
        continue;
      } else if (re(r, "search_result")) {
        yield {
          id: r.id,
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "tool_result")) {
        yield {
          id: r.id,
          type: "non_standard",
          value: r
        };
        continue;
      } else {
        const s = wT(r);
        if (s) {
          yield s;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(t());
}
const oA = {
  translateContent: j_,
  translateContentChunk: j_
};
function uA(e) {
  return typeof e?._getType == "function" && typeof e.concat == "function" && e._getType() === "ai";
}
function cA(e) {
  return um(e) ? {
    type: e.type,
    mimeType: e.mime_type,
    url: e.url,
    metadata: e.metadata
  } : cm(e) ? {
    type: e.type,
    mimeType: e.mime_type ?? "application/octet-stream",
    data: e.data,
    metadata: e.metadata
  } : pT(e) ? {
    type: e.type,
    mimeType: e.mime_type,
    fileId: e.id,
    metadata: e.metadata
  } : e;
}
function lA(e) {
  return e.map(cA);
}
function dA(e) {
  return !!(re(e, "image_url") && _e(e.image_url) || re(e, "input_audio") && _e(e.input_audio) || re(e, "file") && _e(e.file));
}
function fA(e) {
  if (re(e, "image_url") && _e(e.image_url) && F(e.image_url.url)) {
    const t = Gn({ dataUrl: e.image_url.url });
    return t ? {
      type: "image",
      mimeType: t.mime_type,
      data: t.data
    } : {
      type: "image",
      url: e.image_url.url
    };
  } else {
    if (re(e, "input_audio") && _e(e.input_audio) && F(e.input_audio.data) && F(e.input_audio.format)) return {
      type: "audio",
      data: e.input_audio.data,
      mimeType: `audio/${e.input_audio.format}`
    };
    if (re(e, "file") && _e(e.file) && F(e.file.data)) {
      const t = Gn({ dataUrl: e.file.data });
      if (t) return {
        type: "file",
        data: t.data,
        mimeType: t.mime_type
      };
      if (F(e.file.file_id)) return {
        type: "file",
        fileId: e.file.file_id
      };
    }
  }
  return e;
}
function hA(e) {
  const t = [];
  typeof e.content == "string" ? t.push({
    type: "text",
    text: e.content
  }) : t.push(...fm(e.content));
  for (const n of e.tool_calls ?? []) t.push({
    type: "tool_call",
    id: n.id,
    name: n.name,
    args: n.args
  });
  return t;
}
function pA(e) {
  const t = [];
  typeof e.content == "string" ? t.push({
    type: "text",
    text: e.content
  }) : t.push(...fm(e.content));
  for (const n of e.tool_calls ?? []) t.push({
    type: "tool_call",
    id: n.id,
    name: n.name,
    args: n.args
  });
  return t;
}
function fm(e) {
  const t = [];
  for (const n of e) dA(n) ? t.push(fA(n)) : t.push(n);
  return t;
}
function mA(e) {
  if (e.type === "url_citation") {
    const { url: t, title: n, start_index: r, end_index: s } = e;
    return {
      type: "citation",
      url: t,
      title: n,
      startIndex: r,
      endIndex: s
    };
  }
  if (e.type === "file_citation") {
    const { file_id: t, filename: n, index: r } = e;
    return {
      type: "citation",
      title: n,
      startIndex: r,
      endIndex: r,
      fileId: t
    };
  }
  return e;
}
function vT(e) {
  function* t() {
    _e(e.additional_kwargs?.reasoning) && Nn(e.additional_kwargs.reasoning.summary) && (yield {
      type: "reasoning",
      reasoning: e.additional_kwargs.reasoning.summary.reduce((s, i) => _e(i) && F(i.text) ? `${s}${i.text}` : s, "")
    });
    const n = typeof e.content == "string" ? [{
      type: "text",
      text: e.content
    }] : e.content;
    for (const r of n) if (re(r, "text")) {
      const { text: s, annotations: i, ...a } = r;
      Array.isArray(i) ? yield {
        ...a,
        type: "text",
        text: String(s),
        annotations: i.map(mA)
      } : yield {
        ...a,
        type: "text",
        text: String(s)
      };
    }
    for (const r of e.tool_calls ?? []) yield {
      type: "tool_call",
      id: r.id,
      name: r.name,
      args: r.args
    };
    if (_e(e.additional_kwargs) && Nn(e.additional_kwargs.tool_outputs)) for (const r of e.additional_kwargs.tool_outputs) {
      if (re(r, "web_search_call")) {
        yield {
          id: r.id,
          type: "server_tool_call",
          name: "web_search",
          args: { query: r.query }
        };
        continue;
      } else if (re(r, "file_search_call")) {
        yield {
          id: r.id,
          type: "server_tool_call",
          name: "file_search",
          args: { query: r.query }
        };
        continue;
      } else if (re(r, "computer_call")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "code_interpreter_call")) {
        if (F(r.code) && (yield {
          id: r.id,
          type: "server_tool_call",
          name: "code_interpreter",
          args: { code: r.code }
        }), Nn(r.outputs)) {
          const s = co(() => {
            if (r.status !== "in_progress") {
              if (r.status === "completed") return 0;
              if (r.status === "incomplete") return 127;
              if (r.status !== "interpreting" && r.status === "failed")
                return 1;
            }
          });
          for (const i of r.outputs) if (re(i, "logs")) {
            yield {
              type: "server_tool_call_result",
              toolCallId: r.id ?? "",
              status: "success",
              output: {
                type: "code_interpreter_output",
                returnCode: s ?? 0,
                stderr: [0, void 0].includes(s) ? void 0 : String(i.logs),
                stdout: [0, void 0].includes(s) ? String(i.logs) : void 0
              }
            };
            continue;
          }
        }
        continue;
      } else if (re(r, "mcp_call")) {
        yield {
          id: r.id,
          type: "server_tool_call",
          name: "mcp_call",
          args: r.input
        };
        continue;
      } else if (re(r, "mcp_list_tools")) {
        yield {
          id: r.id,
          type: "server_tool_call",
          name: "mcp_list_tools",
          args: r.input
        };
        continue;
      } else if (re(r, "mcp_approval_request")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "image_generation_call")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      }
      _e(r) && (yield {
        type: "non_standard",
        value: r
      });
    }
  }
  return Array.from(t());
}
function gA(e) {
  function* t() {
    yield* vT(e);
    for (const n of e.tool_call_chunks ?? []) yield {
      type: "tool_call_chunk",
      id: n.id,
      name: n.name,
      args: n.args
    };
  }
  return Array.from(t());
}
const _A = {
  translateContent: (e) => typeof e.content == "string" ? hA(e) : vT(e),
  translateContentChunk: (e) => typeof e.content == "string" ? pA(e) : gA(e)
};
function yA(e, t = "pretty") {
  return t === "pretty" ? wA(e) : JSON.stringify(e);
}
function wA(e) {
  const t = [], n = ` ${e.type.charAt(0).toUpperCase() + e.type.slice(1)} Message `, r = Math.floor((80 - n.length) / 2), s = "=".repeat(r), i = n.length % 2 === 0 ? s : `${s}=`;
  if (t.push(`${s}${n}${i}`), e.type === "ai") {
    const a = e;
    if (a.tool_calls && a.tool_calls.length > 0) {
      t.push("Tool Calls:");
      for (const o of a.tool_calls) {
        t.push(`  ${o.name} (${o.id})`), t.push(` Call ID: ${o.id}`), t.push("  Args:");
        for (const [u, c] of Object.entries(o.args)) t.push(`    ${u}: ${typeof c == "object" ? JSON.stringify(c) : c}`);
      }
    }
  }
  if (e.type === "tool") {
    const a = e;
    a.name && t.push(`Name: ${a.name}`);
  }
  return typeof e.content == "string" && e.content.trim() && (t.length > 1 && t.push(""), t.push(e.content)), t.join(`
`);
}
const Hd = /* @__PURE__ */ Symbol.for("langchain.message");
function lr(e, t) {
  return typeof e == "string" ? e === "" ? t : typeof t == "string" ? e + t : Array.isArray(t) && t.length === 0 ? e : Array.isArray(t) && t.some((n) => gn(n)) ? [{
    type: "text",
    source_type: "text",
    text: e
  }, ...t] : [{
    type: "text",
    text: e
  }, ...t] : Array.isArray(t) ? $o(e, t) ?? [...e, ...t] : t === "" ? e : Array.isArray(e) && e.some((n) => gn(n)) ? [...e, {
    type: "file",
    source_type: "text",
    text: t
  }] : [...e, {
    type: "text",
    text: t
  }];
}
function bT(e, t) {
  return e === "error" || t === "error" ? "error" : "success";
}
function vA(e, t) {
  function n(r, s) {
    if (typeof r != "object" || r === null || r === void 0) return r;
    if (s >= t)
      return Array.isArray(r) ? "[Array]" : "[Object]";
    if (Array.isArray(r)) return r.map((a) => n(a, s + 1));
    const i = {};
    for (const a of Object.keys(r)) i[a] = n(r[a], s + 1);
    return i;
  }
  return JSON.stringify(n(e, 0), null, 2);
}
var gr = class extends ri {
  lc_namespace = ["langchain_core", "messages"];
  lc_serializable = !0;
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  [Hd] = !0;
  id;
  /** @inheritdoc */
  name;
  content;
  additional_kwargs;
  response_metadata;
  /**
  * @deprecated Use .getType() instead or import the proper typeguard.
  * For example:
  *
  * ```ts
  * import { isAIMessage } from "@langchain/core/messages";
  *
  * const message = new AIMessage("Hello!");
  * isAIMessage(message); // true
  * ```
  */
  _getType() {
    return this.type;
  }
  /**
  * @deprecated Use .type instead
  * The type of the message.
  */
  getType() {
    return this._getType();
  }
  constructor(e) {
    const t = typeof e == "string" || Array.isArray(e) ? { content: e } : e;
    t.additional_kwargs || (t.additional_kwargs = {}), t.response_metadata || (t.response_metadata = {}), super(t), this.name = t.name, t.content === void 0 && t.contentBlocks !== void 0 ? (this.content = t.contentBlocks, this.response_metadata = {
      output_version: "v1",
      ...t.response_metadata
    }) : t.content !== void 0 ? (this.content = t.content ?? [], this.response_metadata = t.response_metadata) : (this.content = [], this.response_metadata = t.response_metadata), this.additional_kwargs = t.additional_kwargs, this.id = t.id;
  }
  /** Get text content of the message. */
  get text() {
    return typeof this.content == "string" ? this.content : Array.isArray(this.content) ? this.content.map((e) => typeof e == "string" ? e : e.type === "text" ? e.text : "").join("") : "";
  }
  get contentBlocks() {
    const e = typeof this.content == "string" ? [{
      type: "text",
      text: this.content
    }] : this.content;
    return [
      lA,
      fm,
      aA
    ].reduce((r, s) => s(r), e);
  }
  toDict() {
    return {
      type: this.getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  static isInstance(e) {
    return typeof e == "object" && e !== null && Hd in e && e[Hd] === !0 && gT(e);
  }
  _updateId(e) {
    this.id = e, this.lc_kwargs.id = e;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")](e) {
    if (e === null) return this;
    const t = vA(this._printableFields, Math.max(4, e));
    return `${this.constructor.lc_name()} ${t}`;
  }
  toFormattedString(e = "pretty") {
    return yA(this, e);
  }
};
function bA(e) {
  return Array.isArray(e) && e.every((t) => typeof t.index == "number");
}
function At(e, t) {
  if (e === void 0 && t === void 0) return;
  if (e === void 0 || t === void 0) return e ?? t;
  const n = { ...e };
  for (const [r, s] of Object.entries(t)) if (n[r] == null) n[r] = s;
  else {
    if (s == null) continue;
    if (typeof n[r] != typeof s || Array.isArray(n[r]) !== Array.isArray(s)) throw new Error(`field[${r}] already exists in the message chunk, but with a different type.`);
    if (typeof n[r] == "string") {
      if (r === "type") continue;
      [
        "id",
        "name",
        "output_version",
        "model_provider"
      ].includes(r) ? s && (n[r] = s) : n[r] += s;
    } else if (typeof n[r] == "number") n[r] = n[r] + s;
    else if (typeof n[r] == "object" && !Array.isArray(n[r])) n[r] = At(n[r], s);
    else if (Array.isArray(n[r])) n[r] = $o(n[r], s);
    else {
      if (n[r] === s) continue;
      console.warn(`field[${r}] already exists in this message chunk and value has unsupported type.`);
    }
  }
  return n;
}
function $o(e, t) {
  if (!(e === void 0 && t === void 0)) {
    if (e === void 0 || t === void 0) return e || t;
    {
      const n = [...e];
      for (const r of t) if (typeof r == "object" && r !== null && "index" in r && typeof r.index == "number") {
        const s = n.findIndex((i) => {
          const a = typeof i == "object", o = "index" in i && i.index === r.index, u = "id" in i && "id" in r && i?.id === r?.id, c = !("id" in i) || !i?.id || !("id" in r) || !r?.id;
          return a && o && (u || c);
        });
        s !== -1 && typeof n[s] == "object" && n[s] !== null ? n[s] = At(n[s], r) : n.push(r);
      } else {
        if (typeof r == "object" && r !== null && "text" in r && r.text === "") continue;
        n.push(r);
      }
      return n;
    }
  }
}
function ST(e, t) {
  if (!(e === void 0 && t === void 0)) {
    if (e === void 0 || t === void 0) return e ?? t;
    if (typeof e != typeof t) throw new Error(`Cannot merge objects of different types.
Left ${typeof e}
Right ${typeof t}`);
    if (typeof e == "string" && typeof t == "string") return e + t;
    if (Array.isArray(e) && Array.isArray(t)) return $o(e, t);
    if (typeof e == "object" && typeof t == "object") return At(e, t);
    if (e === t) return e;
    throw new Error(`Can not merge objects of different types.
Left ${e}
Right ${t}`);
  }
}
var Vr = class TT extends gr {
  static isInstance(t) {
    if (!super.isInstance(t)) return !1;
    let n = Object.getPrototypeOf(t);
    for (; n !== null; ) {
      if (n === TT.prototype) return !0;
      n = Object.getPrototypeOf(n);
    }
    return !1;
  }
};
function xT(e) {
  return typeof e.role == "string";
}
function ur(e) {
  return typeof e?._getType == "function";
}
function hm(e) {
  return Vr.isInstance(e);
}
function ET(e, t) {
  return At(e, t) ?? {};
}
function kT(e, t) {
  const n = {};
  return (e?.audio !== void 0 || t?.audio !== void 0) && (n.audio = (e?.audio ?? 0) + (t?.audio ?? 0)), (e?.image !== void 0 || t?.image !== void 0) && (n.image = (e?.image ?? 0) + (t?.image ?? 0)), (e?.video !== void 0 || t?.video !== void 0) && (n.video = (e?.video ?? 0) + (t?.video ?? 0)), (e?.document !== void 0 || t?.document !== void 0) && (n.document = (e?.document ?? 0) + (t?.document ?? 0)), (e?.text !== void 0 || t?.text !== void 0) && (n.text = (e?.text ?? 0) + (t?.text ?? 0)), n;
}
function SA(e, t) {
  const n = { ...kT(e, t) };
  return (e?.cache_read !== void 0 || t?.cache_read !== void 0) && (n.cache_read = (e?.cache_read ?? 0) + (t?.cache_read ?? 0)), (e?.cache_creation !== void 0 || t?.cache_creation !== void 0) && (n.cache_creation = (e?.cache_creation ?? 0) + (t?.cache_creation ?? 0)), n;
}
function TA(e, t) {
  const n = { ...kT(e, t) };
  return (e?.reasoning !== void 0 || t?.reasoning !== void 0) && (n.reasoning = (e?.reasoning ?? 0) + (t?.reasoning ?? 0)), n;
}
function pm(e, t) {
  return {
    input_tokens: (e?.input_tokens ?? 0) + (t?.input_tokens ?? 0),
    output_tokens: (e?.output_tokens ?? 0) + (t?.output_tokens ?? 0),
    total_tokens: (e?.total_tokens ?? 0) + (t?.total_tokens ?? 0),
    input_token_details: SA(e?.input_token_details, t?.input_token_details),
    output_token_details: TA(e?.output_token_details, t?.output_token_details)
  };
}
var xA = {};
$e(xA, {
  ToolMessage: () => Jn,
  ToolMessageChunk: () => Ro,
  defaultToolCallParser: () => gm,
  isDirectToolOutput: () => mm,
  isToolMessage: () => _m,
  isToolMessageChunk: () => OT
});
function mm(e) {
  return e != null && typeof e == "object" && "lc_direct_tool_output" in e && e.lc_direct_tool_output === !0;
}
var Jn = class extends gr {
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  lc_direct_tool_output = !0;
  type = "tool";
  /**
  * Status of the tool invocation.
  * @version 0.2.19
  */
  status;
  tool_call_id;
  metadata;
  /**
  * Artifact of the Tool execution which is not meant to be sent to the model.
  *
  * Should only be specified if it is different from the message content, e.g. if only
  * a subset of the full tool output is being passed as message content but the full
  * output is needed in other parts of the code.
  */
  artifact;
  constructor(e, t, n) {
    const r = typeof e == "string" || Array.isArray(e) ? {
      content: e,
      name: n,
      tool_call_id: t
    } : e;
    super(r), this.tool_call_id = r.tool_call_id, this.artifact = r.artifact, this.status = r.status, this.metadata = r.metadata;
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
}, Ro = class extends Vr {
  type = "tool";
  tool_call_id;
  /**
  * Status of the tool invocation.
  * @version 0.2.19
  */
  status;
  /**
  * Artifact of the Tool execution which is not meant to be sent to the model.
  *
  * Should only be specified if it is different from the message content, e.g. if only
  * a subset of the full tool output is being passed as message content but the full
  * output is needed in other parts of the code.
  */
  artifact;
  constructor(e) {
    super(e), this.tool_call_id = e.tool_call_id, this.artifact = e.artifact, this.status = e.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: lr(this.content, e.content),
      additional_kwargs: At(this.additional_kwargs, e.additional_kwargs),
      response_metadata: At(this.response_metadata, e.response_metadata),
      artifact: ST(this.artifact, e.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? e.id,
      status: bT(this.status, e.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function gm(e) {
  const t = [], n = [];
  for (const r of e) if (r.function) {
    const s = r.function.name;
    try {
      const i = JSON.parse(r.function.arguments);
      t.push({
        name: s || "",
        args: i || {},
        id: r.id
      });
    } catch {
      n.push({
        name: s,
        args: r.function.arguments,
        id: r.id,
        error: "Malformed args."
      });
    }
  } else
    continue;
  return [t, n];
}
function _m(e) {
  return typeof e == "object" && e !== null && "getType" in e && typeof e.getType == "function" && e.getType() === "tool";
}
function OT(e) {
  return e._getType() === "tool";
}
var Hr = class IT extends gr {
  static lc_name() {
    return "ChatMessage";
  }
  type = "generic";
  role;
  static _chatMessageClass() {
    return IT;
  }
  constructor(t, n) {
    (typeof t == "string" || Array.isArray(t)) && (t = {
      content: t,
      role: n
    }), super(t), this.role = t.role;
  }
  static isInstance(t) {
    return super.isInstance(t) && t.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
}, Po = class extends Vr {
  static lc_name() {
    return "ChatMessageChunk";
  }
  type = "generic";
  role;
  constructor(e, t) {
    (typeof e == "string" || Array.isArray(e)) && (e = {
      content: e,
      role: t
    }), super(e), this.role = e.role;
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: lr(this.content, e.content),
      additional_kwargs: At(this.additional_kwargs, e.additional_kwargs),
      response_metadata: At(this.response_metadata, e.response_metadata),
      role: this.role,
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
function EA(e) {
  return e._getType() === "generic";
}
function kA(e) {
  return e._getType() === "generic";
}
var _l = class extends gr {
  static lc_name() {
    return "FunctionMessage";
  }
  type = "function";
  name;
  constructor(e) {
    super(e), this.name = e.name;
  }
}, No = class extends Vr {
  static lc_name() {
    return "FunctionMessageChunk";
  }
  type = "function";
  concat(e) {
    const t = this.constructor;
    return new t({
      content: lr(this.content, e.content),
      additional_kwargs: At(this.additional_kwargs, e.additional_kwargs),
      response_metadata: At(this.response_metadata, e.response_metadata),
      name: this.name ?? "",
      id: this.id ?? e.id
    });
  }
};
function OA(e) {
  return e._getType() === "function";
}
function IA(e) {
  return e._getType() === "function";
}
var Zt = class extends gr {
  static lc_name() {
    return "HumanMessage";
  }
  type = "human";
  constructor(e) {
    super(e);
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "human";
  }
}, Mo = class extends Vr {
  static lc_name() {
    return "HumanMessageChunk";
  }
  type = "human";
  constructor(e) {
    super(e);
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: lr(this.content, e.content),
      additional_kwargs: At(this.additional_kwargs, e.additional_kwargs),
      response_metadata: At(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "human";
  }
};
function AA(e) {
  return e.getType() === "human";
}
function CA(e) {
  return e.getType() === "human";
}
var Ic = class extends gr {
  type = "remove";
  /**
  * The ID of the message to remove.
  */
  id;
  constructor(e) {
    super({
      ...e,
      content: []
    }), this.id = e.id;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      id: this.id
    };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "remove";
  }
}, Kn = class cc extends gr {
  static lc_name() {
    return "SystemMessage";
  }
  type = "system";
  constructor(t) {
    super(t);
  }
  /**
  * Concatenates a string or another system message with the current system message.
  * @param chunk - The chunk to concatenate with the system message.
  * @returns A new system message with the concatenated content.
  */
  concat(t) {
    if (typeof t == "string") return new cc({
      ...this,
      content: lr(this.content, t)
    });
    if (cc.isInstance(t)) return new cc({
      ...this,
      additional_kwargs: {
        ...this.additional_kwargs,
        ...t.additional_kwargs
      },
      response_metadata: {
        ...this.response_metadata,
        ...t.response_metadata
      },
      content: lr(this.content, t.content)
    });
    throw new Error("Unexpected chunk type for system message");
  }
  static isInstance(t) {
    return super.isInstance(t) && t.type === "system";
  }
}, Lr = class extends Vr {
  static lc_name() {
    return "SystemMessageChunk";
  }
  type = "system";
  constructor(e) {
    super(e);
  }
  concat(e) {
    const t = this.constructor;
    return new t({
      content: lr(this.content, e.content),
      additional_kwargs: At(this.additional_kwargs, e.additional_kwargs),
      response_metadata: At(this.response_metadata, e.response_metadata),
      id: this.id ?? e.id
    });
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "system";
  }
};
function $A(e) {
  return e._getType() === "system";
}
function RA(e) {
  return e._getType() === "system";
}
function AT(e, t) {
  return e.lc_error_code = t, e.message = `${e.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${t}/
`, e;
}
function to(e) {
  return !!(e && typeof e == "object" && "type" in e && e.type === "tool_call");
}
function PA(e) {
  return !!(e && typeof e == "object" && "toolCall" in e && e.toolCall != null && typeof e.toolCall == "object" && "id" in e.toolCall && typeof e.toolCall.id == "string");
}
var Ac = class extends Error {
  output;
  constructor(e, t) {
    super(e), this.output = t;
  }
};
function Bh(e, t = yl) {
  e = e.trim();
  const n = e.indexOf("```");
  if (n === -1) return t(e);
  let r = e.substring(n + 3);
  r.startsWith(`json
`) ? r = r.substring(5) : r.startsWith("json") ? r = r.substring(4) : r.startsWith(`
`) && (r = r.substring(1));
  const s = r.indexOf("```");
  let i = r;
  return s !== -1 && (i = r.substring(0, s)), t(i.trim());
}
function NA(e) {
  try {
    return JSON.parse(e);
  } catch {
  }
  const t = e.trim();
  if (t.length === 0) throw new Error("Unexpected end of JSON input");
  let n = 0;
  function r() {
    for (; n < t.length && /\s/.test(t[n]); ) n += 1;
  }
  function s() {
    if (t[n] !== '"') throw new Error(`Expected '"' at position ${n}, got '${t[n]}'`);
    n += 1;
    let l = "", d = !1;
    for (; n < t.length; ) {
      const f = t[n];
      if (d) {
        if (f === "n") l += `
`;
        else if (f === "t") l += "	";
        else if (f === "r") l += "\r";
        else if (f === "\\") l += "\\";
        else if (f === '"') l += '"';
        else if (f === "b") l += "\b";
        else if (f === "f") l += "\f";
        else if (f === "/") l += "/";
        else if (f === "u") {
          const h = t.substring(n + 1, n + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(h))
            h.length === 4 ? l += String.fromCharCode(Number.parseInt(h, 16)) : l += `u${h}`, n += h.length;
          else throw new Error(`Invalid unicode escape sequence '\\u${h}' at position ${n}`);
        } else throw new Error(`Invalid escape sequence '\\${f}' at position ${n}`);
        d = !1;
      } else if (f === "\\") d = !0;
      else {
        if (f === '"')
          return n += 1, l;
        l += f;
      }
      n += 1;
    }
    return d && (l += "\\"), l;
  }
  function i() {
    const l = n;
    let d = "";
    if (t[n] === "-" && (d += "-", n += 1), n < t.length && t[n] === "0" && (d += "0", n += 1, t[n] >= "0" && t[n] <= "9"))
      throw new Error(`Invalid number at position ${l}`);
    if (n < t.length && t[n] >= "1" && t[n] <= "9") for (; n < t.length && t[n] >= "0" && t[n] <= "9"; )
      d += t[n], n += 1;
    if (n < t.length && t[n] === ".")
      for (d += ".", n += 1; n < t.length && t[n] >= "0" && t[n] <= "9"; )
        d += t[n], n += 1;
    if (n < t.length && (t[n] === "e" || t[n] === "E"))
      for (d += t[n], n += 1, n < t.length && (t[n] === "+" || t[n] === "-") && (d += t[n], n += 1); n < t.length && t[n] >= "0" && t[n] <= "9"; )
        d += t[n], n += 1;
    if (d === "-") return -0;
    const f = Number.parseFloat(d);
    if (Number.isNaN(f))
      throw n = l, new Error(`Invalid number '${d}' at position ${l}`);
    return f;
  }
  function a() {
    if (r(), n >= t.length) throw new Error(`Unexpected end of input at position ${n}`);
    const l = t[n];
    if (l === "{") return u();
    if (l === "[") return o();
    if (l === '"') return s();
    if ("null".startsWith(t.substring(n, n + 4)))
      return n += Math.min(4, t.length - n), null;
    if ("true".startsWith(t.substring(n, n + 4)))
      return n += Math.min(4, t.length - n), !0;
    if ("false".startsWith(t.substring(n, n + 5)))
      return n += Math.min(5, t.length - n), !1;
    if (l === "-" || l >= "0" && l <= "9") return i();
    throw new Error(`Unexpected character '${l}' at position ${n}`);
  }
  function o() {
    if (t[n] !== "[") throw new Error(`Expected '[' at position ${n}, got '${t[n]}'`);
    const l = [];
    if (n += 1, r(), n >= t.length) return l;
    if (t[n] === "]")
      return n += 1, l;
    for (; n < t.length; ) {
      if (r(), n >= t.length || (l.push(a()), r(), n >= t.length)) return l;
      if (t[n] === "]")
        return n += 1, l;
      if (t[n] === ",") {
        n += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${n}, got '${t[n]}'`);
    }
    return l;
  }
  function u() {
    if (t[n] !== "{") throw new Error(`Expected '{' at position ${n}, got '${t[n]}'`);
    const l = {};
    if (n += 1, r(), n >= t.length) return l;
    if (t[n] === "}")
      return n += 1, l;
    for (; n < t.length; ) {
      if (r(), n >= t.length) return l;
      const d = s();
      if (r(), n >= t.length) return l;
      if (t[n] !== ":") throw new Error(`Expected ':' at position ${n}, got '${t[n]}'`);
      if (n += 1, r(), n >= t.length || (l[d] = a(), r(), n >= t.length)) return l;
      if (t[n] === "}")
        return n += 1, l;
      if (t[n] === ",") {
        n += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${n}, got '${t[n]}'`);
    }
    return l;
  }
  const c = a();
  if (r(), n < t.length) throw new Error(`Unexpected character '${t[n]}' at position ${n}`);
  return c;
}
function yl(e) {
  try {
    return typeof e > "u" ? null : NA(e);
  } catch {
    return null;
  }
}
function ym(e) {
  switch (e) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function MA(e) {
  if (_e(e.document) && _e(e.document.source)) {
    const t = _e(e.document) && F(e.document.format) ? e.document.format : "", n = ym(t);
    if (_e(e.document.source)) {
      if (_e(e.document.source.s3Location) && F(e.document.source.s3Location.uri)) return {
        type: "file",
        mimeType: n,
        fileId: e.document.source.s3Location.uri
      };
      if (dm(e.document.source.bytes)) return {
        type: "file",
        mimeType: n,
        data: e.document.source.bytes
      };
      if (F(e.document.source.text)) return {
        type: "file",
        mimeType: n,
        data: Buffer.from(e.document.source.text).toString("base64")
      };
      if (Nn(e.document.source.content)) {
        const r = e.document.source.content.reduce((s, i) => _e(i) && F(i.text) ? s + i.text : s, "");
        return {
          type: "file",
          mimeType: n,
          data: r
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: e
  };
}
function jA(e) {
  if (re(e, "image") && _e(e.image)) {
    const t = _e(e.image) && F(e.image.format) ? e.image.format : "", n = ym(t);
    if (_e(e.image.source)) {
      if (_e(e.image.source.s3Location) && F(e.image.source.s3Location.uri)) return {
        type: "image",
        mimeType: n,
        fileId: e.image.source.s3Location.uri
      };
      if (dm(e.image.source.bytes)) return {
        type: "image",
        mimeType: n,
        data: e.image.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: e
  };
}
function LA(e) {
  if (re(e, "video") && _e(e.video)) {
    const t = _e(e.video) && F(e.video.format) ? e.video.format : "", n = ym(t);
    if (_e(e.video.source)) {
      if (_e(e.video.source.s3Location) && F(e.video.source.s3Location.uri)) return {
        type: "video",
        mimeType: n,
        fileId: e.video.source.s3Location.uri
      };
      if (dm(e.video.source.bytes)) return {
        type: "video",
        mimeType: n,
        data: e.video.source.bytes
      };
    }
  }
  return {
    type: "non_standard",
    value: e
  };
}
function L_(e) {
  function* t() {
    const n = typeof e.content == "string" ? [{
      type: "text",
      text: e.content
    }] : e.content;
    for (const r of n) {
      if (re(r, "cache_point")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "citations_content") && _e(r.citationsContent)) {
        const s = Nn(r.citationsContent.content) ? r.citationsContent.content.reduce((a, o) => _e(o) && F(o.text) ? a + o.text : a, "") : "", i = Nn(r.citationsContent.citations) ? r.citationsContent.citations.reduce((a, o) => {
          if (_e(o)) {
            const u = Nn(o.sourceContent) ? o.sourceContent.reduce((l, d) => _e(d) && F(d.text) ? l + d.text : l, "") : "", c = co(() => {
              if (_e(o.location)) {
                const l = o.location.documentChar || o.location.documentPage || o.location.documentChunk;
                if (_e(l)) return {
                  source: Cn(l.documentIndex) ? l.documentIndex.toString() : void 0,
                  startIndex: Cn(l.start) ? l.start : void 0,
                  endIndex: Cn(l.end) ? l.end : void 0
                };
              }
              return {};
            });
            a.push({
              type: "citation",
              citedText: u,
              ...c
            });
          }
          return a;
        }, []) : [];
        yield {
          type: "text",
          text: s,
          annotations: i
        };
        continue;
      } else if (re(r, "document") && _e(r.document)) {
        yield MA(r);
        continue;
      } else if (re(r, "guard_content")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "image") && _e(r.image)) {
        yield jA(r);
        continue;
      } else if (re(r, "reasoning_content") && F(r.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: r.reasoningText
        };
        continue;
      } else if (re(r, "text") && F(r.text)) {
        yield {
          type: "text",
          text: r.text
        };
        continue;
      } else if (re(r, "tool_result")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else {
        if (re(r, "tool_call")) continue;
        if (re(r, "video") && _e(r.video)) {
          yield LA(r);
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(t());
}
const DA = {
  translateContent: L_,
  translateContentChunk: L_
};
function D_(e) {
  const t = [], n = e.additional_kwargs?.reasoning_content;
  if (F(n) && n.length > 0 && t.push({
    type: "reasoning",
    reasoning: n
  }), typeof e.content == "string")
    e.content.length > 0 && t.push({
      type: "text",
      text: e.content
    });
  else for (const r of e.content) typeof r == "object" && "type" in r && r.type === "text" && "text" in r && F(r.text) && t.push({
    type: "text",
    text: r.text
  });
  for (const r of e.tool_calls ?? []) t.push({
    type: "tool_call",
    id: r.id,
    name: r.name,
    args: r.args
  });
  return t;
}
const UA = {
  translateContent: D_,
  translateContentChunk: D_
};
function U_(e) {
  function* t() {
    const n = typeof e.content == "string" ? [{
      type: "text",
      text: e.content
    }] : e.content;
    for (const r of n) {
      if (re(r, "text") && F(r.text)) {
        yield {
          type: "text",
          text: r.text
        };
        continue;
      } else if (re(r, "thinking") && F(r.thinking)) {
        yield {
          type: "reasoning",
          reasoning: r.thinking,
          ...r.signature ? { signature: r.signature } : {}
        };
        continue;
      } else if (re(r, "inlineData") && _e(r.inlineData) && F(r.inlineData.mimeType) && F(r.inlineData.data)) {
        yield {
          type: "file",
          mimeType: r.inlineData.mimeType,
          data: r.inlineData.data
        };
        continue;
      } else if (re(r, "functionCall") && _e(r.functionCall) && F(r.functionCall.name) && _e(r.functionCall.args)) {
        yield {
          type: "tool_call",
          id: e.id,
          name: r.functionCall.name,
          args: r.functionCall.args
        };
        continue;
      } else if (re(r, "functionResponse")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "fileData") && _e(r.fileData) && F(r.fileData.mimeType) && F(r.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: r.fileData.mimeType,
          fileId: r.fileData.fileUri
        };
        continue;
      } else if (re(r, "executableCode")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      } else if (re(r, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: r
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(t());
}
const FA = {
  translateContent: U_,
  translateContentChunk: U_
};
function F_(e) {
  function* t() {
    const n = typeof e.content == "string" ? [{
      type: "text",
      text: e.content
    }] : e.content;
    for (const r of n) {
      if (re(r, "reasoning") && F(r.reasoning)) {
        const s = co(() => {
          const i = n.indexOf(r);
          if (Nn(e.additional_kwargs?.signatures) && i >= 0) return e.additional_kwargs.signatures.at(i);
        });
        F(s) ? yield {
          type: "reasoning",
          reasoning: r.reasoning,
          signature: s
        } : yield {
          type: "reasoning",
          reasoning: r.reasoning
        };
        continue;
      } else if (re(r, "thinking") && F(r.thinking)) {
        yield {
          type: "reasoning",
          reasoning: r.thinking,
          ...r.signature ? { signature: r.signature } : {}
        };
        continue;
      } else if (re(r, "text") && F(r.text)) {
        yield {
          type: "text",
          text: r.text
        };
        continue;
      } else if (re(r, "image_url")) {
        if (F(r.image_url)) if (r.image_url.startsWith("data:")) {
          const s = /^data:([^;]+);base64,(.+)$/, i = r.image_url.match(s);
          i ? yield {
            type: "image",
            data: i[2],
            mimeType: i[1]
          } : yield {
            type: "image",
            url: r.image_url
          };
        } else yield {
          type: "image",
          url: r.image_url
        };
        continue;
      } else if (re(r, "media") && F(r.mimeType) && F(r.data)) {
        yield {
          type: "file",
          mimeType: r.mimeType,
          data: r.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: r
      };
    }
  }
  return Array.from(t());
}
const zA = {
  translateContent: F_,
  translateContentChunk: F_
};
function z_(e) {
  const t = [], n = e.additional_kwargs?.reasoning;
  if (F(n) && n.length > 0 && t.push({
    type: "reasoning",
    reasoning: n
  }), typeof e.content == "string") {
    let r = e.content;
    const s = r.match(/<think>([\s\S]*?)<\/think>/);
    if (s) {
      const i = s[1].trim();
      i.length > 0 && t.push({
        type: "reasoning",
        reasoning: i
      }), r = r.replace(/<think>[\s\S]*?<\/think>/, "").trim();
    }
    r.length > 0 && t.push({
      type: "text",
      text: r
    });
  } else for (const r of e.content) if (typeof r == "object" && "type" in r && r.type === "text" && "text" in r && F(r.text)) {
    let s = r.text;
    const i = s.match(/<think>([\s\S]*?)<\/think>/);
    if (i) {
      const a = i[1].trim();
      a.length > 0 && t.push({
        type: "reasoning",
        reasoning: a
      }), s = s.replace(/<think>[\s\S]*?<\/think>/, "").trim();
    }
    s.length > 0 && t.push({
      type: "text",
      text: s
    });
  }
  for (const r of e.tool_calls ?? []) t.push({
    type: "tool_call",
    id: r.id,
    name: r.name,
    args: r.args
  });
  return t;
}
const qA = {
  translateContent: z_,
  translateContentChunk: z_
};
function q_(e) {
  const t = [], n = e.additional_kwargs?.reasoning_content;
  if (F(n) && n.length > 0 && t.push({
    type: "reasoning",
    reasoning: n
  }), typeof e.content == "string")
    e.content.length > 0 && t.push({
      type: "text",
      text: e.content
    });
  else for (const r of e.content) typeof r == "object" && "type" in r && r.type === "text" && "text" in r && F(r.text) && t.push({
    type: "text",
    text: r.text
  });
  for (const r of e.tool_calls ?? []) t.push({
    type: "tool_call",
    id: r.id,
    name: r.name,
    args: r.args
  });
  return t;
}
const BA = {
  translateContent: q_,
  translateContentChunk: q_
};
function B_(e) {
  const t = [];
  if (_e(e.additional_kwargs?.reasoning)) {
    const r = e.additional_kwargs.reasoning;
    if (Nn(r.summary)) {
      const s = r.summary.reduce((i, a) => _e(a) && F(a.text) ? `${i}${a.text}` : i, "");
      s.length > 0 && t.push({
        type: "reasoning",
        reasoning: s
      });
    }
  }
  const n = e.additional_kwargs?.reasoning_content;
  if (F(n) && n.length > 0 && t.push({
    type: "reasoning",
    reasoning: n
  }), typeof e.content == "string")
    e.content.length > 0 && t.push({
      type: "text",
      text: e.content
    });
  else for (const r of e.content) typeof r == "object" && "type" in r && r.type === "text" && "text" in r && F(r.text) && t.push({
    type: "text",
    text: r.text
  });
  for (const r of e.tool_calls ?? []) t.push({
    type: "tool_call",
    id: r.id,
    name: r.name,
    args: r.args
  });
  return t;
}
const ZA = {
  translateContent: B_,
  translateContentChunk: B_
};
globalThis.lc_block_translators_registry ??= /* @__PURE__ */ new Map([
  ["anthropic", oA],
  ["bedrock-converse", DA],
  ["deepseek", UA],
  ["google-genai", FA],
  ["google-vertexai", zA],
  ["groq", qA],
  ["ollama", BA],
  ["openai", _A],
  ["xai", ZA]
]);
function CT(e) {
  return globalThis.lc_block_translators_registry.get(e);
}
var rt = class extends gr {
  type = "ai";
  tool_calls = [];
  invalid_tool_calls = [];
  usage_metadata;
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  constructor(e) {
    let t;
    if (typeof e == "string" || Array.isArray(e)) t = {
      content: e,
      tool_calls: [],
      invalid_tool_calls: [],
      additional_kwargs: {}
    };
    else {
      t = e;
      const n = t.additional_kwargs?.tool_calls, r = t.tool_calls;
      n != null && n.length > 0 && (r === void 0 || r.length === 0) && console.warn([
        "New LangChain packages are available that more efficiently handle",
        `tool calling.

Please upgrade your packages to versions that set`,
        "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
        "pnpm install @langchain/openai`, etc."
      ].join(" "));
      try {
        if (n != null && r === void 0) {
          const [s, i] = gm(n);
          t.tool_calls = s ?? [], t.invalid_tool_calls = i ?? [];
        } else
          t.tool_calls = t.tool_calls ?? [], t.invalid_tool_calls = t.invalid_tool_calls ?? [];
      } catch {
        t.tool_calls = [], t.invalid_tool_calls = [];
      }
      if (t.response_metadata !== void 0 && "output_version" in t.response_metadata && t.response_metadata.output_version === "v1" && (t.contentBlocks = t.content, t.content = void 0), t.contentBlocks !== void 0) {
        t.tool_calls && t.contentBlocks.push(...t.tool_calls.map((i) => ({
          type: "tool_call",
          id: i.id,
          name: i.name,
          args: i.args
        })));
        const s = t.contentBlocks.filter((i) => i.type === "tool_call").filter((i) => !t.tool_calls?.some((a) => a.id === i.id && a.name === i.name));
        s.length > 0 && (t.tool_calls = s.map((i) => ({
          type: "tool_call",
          id: i.id,
          name: i.name,
          args: i.args
        })));
      }
    }
    super(t), typeof t != "string" && (this.tool_calls = t.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls), this.usage_metadata = t.usage_metadata;
  }
  static lc_name() {
    return "AIMessage";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const t = CT(this.response_metadata.model_provider);
      if (t) return t.translateContent(this);
    }
    const e = super.contentBlocks;
    if (this.tool_calls) {
      const t = this.tool_calls.filter((n) => !e.some((r) => r.id === n.id && r.name === n.name));
      e.push(...t.map((n) => ({
        type: "tool_call",
        id: n.id,
        name: n.name,
        args: n.args
      })));
    }
    return e;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "ai";
  }
};
function Dr(e) {
  return e._getType() === "ai";
}
function Zh(e) {
  return e._getType() === "ai";
}
var We = class extends Vr {
  type = "ai";
  tool_calls = [];
  invalid_tool_calls = [];
  tool_call_chunks = [];
  usage_metadata;
  constructor(e) {
    let t;
    if (typeof e == "string" || Array.isArray(e)) t = {
      content: e,
      tool_calls: [],
      invalid_tool_calls: [],
      tool_call_chunks: []
    };
    else if (e.tool_call_chunks === void 0 || e.tool_call_chunks.length === 0) t = {
      ...e,
      tool_calls: e.tool_calls ?? [],
      invalid_tool_calls: [],
      tool_call_chunks: [],
      usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
    };
    else {
      const n = RT(e.tool_call_chunks ?? []);
      t = {
        ...e,
        tool_call_chunks: n.tool_call_chunks,
        tool_calls: n.tool_calls,
        invalid_tool_calls: n.invalid_tool_calls,
        usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
      };
    }
    super(t), this.tool_call_chunks = t.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = t.tool_calls ?? this.tool_calls, this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = t.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider == "string") {
      const t = CT(this.response_metadata.model_provider);
      if (t) return t.translateContent(this);
    }
    const e = super.contentBlocks;
    if (this.tool_calls && typeof this.content != "string") {
      const t = this.content.filter((n) => n.type === "tool_call").map((n) => n.id);
      for (const n of this.tool_calls) n.id && !t.includes(n.id) && e.push({
        ...n,
        type: "tool_call",
        id: n.id,
        name: n.name,
        args: n.args
      });
    }
    return e;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(e) {
    const t = {
      content: lr(this.content, e.content),
      additional_kwargs: At(this.additional_kwargs, e.additional_kwargs),
      response_metadata: ET(this.response_metadata, e.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? e.id
    };
    if (this.tool_call_chunks !== void 0 || e.tool_call_chunks !== void 0) {
      const r = $o(this.tool_call_chunks, e.tool_call_chunks);
      r !== void 0 && r.length > 0 && (t.tool_call_chunks = r);
    }
    (this.usage_metadata !== void 0 || e.usage_metadata !== void 0) && (t.usage_metadata = pm(this.usage_metadata, e.usage_metadata));
    const n = this.constructor;
    return new n(t);
  }
  static isInstance(e) {
    return super.isInstance(e) && e.type === "ai";
  }
};
const $T = (e) => e();
function VA(e) {
  return to(e) ? e : typeof e.id == "string" && e.type === "function" && typeof e.function == "object" && e.function !== null && "arguments" in e.function && typeof e.function.arguments == "string" && "name" in e.function && typeof e.function.name == "string" ? {
    id: e.id,
    args: JSON.parse(e.function.arguments),
    name: e.function.name,
    type: "tool_call"
  } : e;
}
function HA(e) {
  return typeof e == "object" && e != null && e.lc === 1 && Array.isArray(e.id) && e.kwargs != null && typeof e.kwargs == "object";
}
function Gd(e) {
  let t, n;
  if (HA(e)) {
    const r = e.id.at(-1);
    r === "HumanMessage" || r === "HumanMessageChunk" ? t = "user" : r === "AIMessage" || r === "AIMessageChunk" ? t = "assistant" : r === "SystemMessage" || r === "SystemMessageChunk" ? t = "system" : r === "FunctionMessage" || r === "FunctionMessageChunk" ? t = "function" : r === "ToolMessage" || r === "ToolMessageChunk" ? t = "tool" : t = "unknown", n = e.kwargs;
  } else {
    const { type: r, ...s } = e;
    t = r, n = s;
  }
  if (t === "human" || t === "user") return new Zt(n);
  if (t === "ai" || t === "assistant") {
    const { tool_calls: r, ...s } = n;
    if (!Array.isArray(r)) return new rt(n);
    const i = r.map(VA);
    return new rt({
      ...s,
      tool_calls: i
    });
  } else {
    if (t === "system") return new Kn(n);
    if (t === "developer") return new Kn({
      ...n,
      additional_kwargs: {
        ...n.additional_kwargs,
        __openai_role__: "developer"
      }
    });
    if (t === "tool" && "tool_call_id" in n) return new Jn({
      ...n,
      content: n.content,
      tool_call_id: n.tool_call_id,
      name: n.name
    });
    if (t === "remove" && "id" in n && typeof n.id == "string") return new Ic({
      ...n,
      id: n.id
    });
    throw AT(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(e, null, 2)}`), "MESSAGE_COERCION_FAILURE");
  }
}
function no(e) {
  if (typeof e == "string") return new Zt(e);
  if (ur(e)) return e;
  if (Array.isArray(e)) {
    const [t, n] = e;
    return Gd({
      type: t,
      content: n
    });
  } else if (xT(e)) {
    const { role: t, ...n } = e;
    return Gd({
      ...n,
      type: t
    });
  } else return Gd(e);
}
function wm(e, t = "Human", n = "AI") {
  const r = [];
  for (const s of e) {
    let i;
    if (s.type === "human") i = t;
    else if (s.type === "ai") i = n;
    else if (s.type === "system") i = "System";
    else if (s.type === "tool") i = "Tool";
    else if (s.type === "generic") i = s.role;
    else throw new Error(`Got unsupported message type: ${s.type}`);
    const a = s.name ? `${s.name}, ` : "", o = s.text;
    let u = `${i}: ${a}${o}`;
    if (s.type === "ai") {
      const c = s;
      c.tool_calls && c.tool_calls.length > 0 ? u += JSON.stringify(c.tool_calls) : c.additional_kwargs && "function_call" in c.additional_kwargs && (u += JSON.stringify(c.additional_kwargs.function_call));
    }
    r.push(u);
  }
  return r.join(`
`);
}
function GA(e) {
  if (e.data !== void 0) return e;
  {
    const t = e;
    return {
      type: t.type,
      data: {
        content: t.text,
        role: t.role,
        name: void 0,
        tool_call_id: void 0
      }
    };
  }
}
function vm(e) {
  const t = GA(e);
  switch (t.type) {
    case "human":
      return new Zt(t.data);
    case "ai":
      return new rt(t.data);
    case "system":
      return new Kn(t.data);
    case "function":
      if (t.data.name === void 0) throw new Error("Name must be defined for function messages");
      return new _l(t.data);
    case "tool":
      if (t.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
      return new Jn(t.data);
    case "generic":
      if (t.data.role === void 0) throw new Error("Role must be defined for chat messages");
      return new Hr(t.data);
    default:
      throw new Error(`Got unexpected type: ${t.type}`);
  }
}
function WA(e) {
  return e.map(vm);
}
function JA(e) {
  return e.map((t) => t.toDict());
}
function Cc(e) {
  const t = e._getType();
  if (t === "human") return new Mo({ ...e });
  if (t === "ai") {
    let n = { ...e };
    return "tool_calls" in n && (n = {
      ...n,
      tool_call_chunks: n.tool_calls?.map((r) => ({
        ...r,
        type: "tool_call_chunk",
        index: void 0,
        args: JSON.stringify(r.args)
      }))
    }), new We({ ...n });
  } else {
    if (t === "system") return new Lr({ ...e });
    if (t === "function") return new No({ ...e });
    if (Hr.isInstance(e)) return new Po({ ...e });
    throw new Error("Unknown message type.");
  }
}
function RT(e) {
  const t = e.reduce((s, i) => {
    const a = s.findIndex(([o]) => "id" in i && i.id && "index" in i && i.index !== void 0 ? i.id === o.id && i.index === o.index : "id" in i && i.id ? i.id === o.id : "index" in i && i.index !== void 0 ? i.index === o.index : !1);
    return a !== -1 ? s[a].push(i) : s.push([i]), s;
  }, []), n = [], r = [];
  for (const s of t) {
    let i = null;
    const a = s[0]?.name ?? "", o = s.map((l) => l.args || "").join("").trim(), u = o.length ? o : "{}", c = s[0]?.id;
    try {
      if (i = yl(u), !c || i === null || typeof i != "object" || Array.isArray(i)) throw new Error("Malformed tool call chunk args.");
      n.push({
        name: a,
        args: i,
        id: c,
        type: "tool_call"
      });
    } catch {
      r.push({
        name: a,
        args: u,
        id: c,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: e,
    tool_calls: n,
    invalid_tool_calls: r
  };
}
const PT = /* @__PURE__ */ Symbol.for("ls:tracing_async_local_storage"), ro = /* @__PURE__ */ Symbol.for("lc:context_variables"), KA = (e) => {
  globalThis[PT] = e;
}, lo = () => globalThis[PT];
var YA = {};
$e(YA, {
  getEnv: () => bm,
  getEnvironmentVariable: () => on,
  getRuntimeEnvironment: () => DT,
  isBrowser: () => NT,
  isDeno: () => wl,
  isJsDom: () => jT,
  isNode: () => LT,
  isWebWorker: () => MT
});
const NT = () => typeof window < "u" && typeof window.document < "u", MT = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", jT = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), wl = () => typeof Deno < "u", LT = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !wl(), bm = () => {
  let e;
  return NT() ? e = "browser" : LT() ? e = "node" : MT() ? e = "webworker" : jT() ? e = "jsdom" : wl() ? e = "deno" : e = "other", e;
};
let Wd;
function DT() {
  return Wd === void 0 && (Wd = {
    library: "langchain-js",
    runtime: bm()
  }), Wd;
}
function on(e) {
  try {
    return typeof process < "u" ? process.env?.[e] : wl() ? Deno?.env.get(e) : void 0;
  } catch {
    return;
  }
}
var Jd = {}, Ei = {}, Z_;
function XA() {
  return Z_ || (Z_ = 1, Object.defineProperty(Ei, "__esModule", {
    value: !0
  }), Ei.default = void 0, Ei.default = "ffffffff-ffff-ffff-ffff-ffffffffffff"), Ei;
}
var ki = {}, V_;
function QA() {
  return V_ || (V_ = 1, Object.defineProperty(ki, "__esModule", {
    value: !0
  }), ki.default = void 0, ki.default = "00000000-0000-0000-0000-000000000000"), ki;
}
var Oi = {}, Ii = {}, Ai = {}, H_;
function eC() {
  return H_ || (H_ = 1, Object.defineProperty(Ai, "__esModule", {
    value: !0
  }), Ai.default = void 0, Ai.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i), Ai;
}
var G_;
function vl() {
  if (G_) return Ii;
  G_ = 1, Object.defineProperty(Ii, "__esModule", {
    value: !0
  }), Ii.default = void 0;
  var e = t(/* @__PURE__ */ eC());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return typeof r == "string" && e.default.test(r);
  }
  return Ii.default = n, Ii;
}
var W_;
function bl() {
  if (W_) return Oi;
  W_ = 1, Object.defineProperty(Oi, "__esModule", {
    value: !0
  }), Oi.default = void 0;
  var e = t(/* @__PURE__ */ vl());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    if (!(0, e.default)(r))
      throw TypeError("Invalid UUID");
    let s;
    const i = new Uint8Array(16);
    return i[0] = (s = parseInt(r.slice(0, 8), 16)) >>> 24, i[1] = s >>> 16 & 255, i[2] = s >>> 8 & 255, i[3] = s & 255, i[4] = (s = parseInt(r.slice(9, 13), 16)) >>> 8, i[5] = s & 255, i[6] = (s = parseInt(r.slice(14, 18), 16)) >>> 8, i[7] = s & 255, i[8] = (s = parseInt(r.slice(19, 23), 16)) >>> 8, i[9] = s & 255, i[10] = (s = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, i[11] = s / 4294967296 & 255, i[12] = s >>> 24 & 255, i[13] = s >>> 16 & 255, i[14] = s >>> 8 & 255, i[15] = s & 255, i;
  }
  return Oi.default = n, Oi;
}
var Ns = {}, J_;
function Gr() {
  if (J_) return Ns;
  J_ = 1, Object.defineProperty(Ns, "__esModule", {
    value: !0
  }), Ns.default = void 0, Ns.unsafeStringify = r;
  var e = t(/* @__PURE__ */ vl());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  const n = [];
  for (let i = 0; i < 256; ++i)
    n.push((i + 256).toString(16).slice(1));
  function r(i, a = 0) {
    return (n[i[a + 0]] + n[i[a + 1]] + n[i[a + 2]] + n[i[a + 3]] + "-" + n[i[a + 4]] + n[i[a + 5]] + "-" + n[i[a + 6]] + n[i[a + 7]] + "-" + n[i[a + 8]] + n[i[a + 9]] + "-" + n[i[a + 10]] + n[i[a + 11]] + n[i[a + 12]] + n[i[a + 13]] + n[i[a + 14]] + n[i[a + 15]]).toLowerCase();
  }
  function s(i, a = 0) {
    const o = r(i, a);
    if (!(0, e.default)(o))
      throw TypeError("Stringified UUID is invalid");
    return o;
  }
  return Ns.default = s, Ns;
}
var Ci = {}, uu = {}, K_;
function Sm() {
  if (K_) return uu;
  K_ = 1, Object.defineProperty(uu, "__esModule", {
    value: !0
  }), uu.default = s;
  var e = t(wn);
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  const n = new Uint8Array(256);
  let r = n.length;
  function s() {
    return r > n.length - 16 && (e.default.randomFillSync(n), r = 0), n.slice(r, r += 16);
  }
  return uu;
}
var Y_;
function UT() {
  if (Y_) return Ci;
  Y_ = 1, Object.defineProperty(Ci, "__esModule", {
    value: !0
  }), Ci.default = void 0;
  var e = n(/* @__PURE__ */ Sm()), t = /* @__PURE__ */ Gr();
  function n(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let r, s, i = 0, a = 0;
  function o(u, c, l) {
    let d = c && l || 0;
    const f = c || new Array(16);
    u = u || {};
    let h = u.node, p = u.clockseq;
    if (u._v6 || (h || (h = r), p == null && (p = s)), h == null || p == null) {
      const T = u.random || (u.rng || e.default)();
      h == null && (h = [T[0], T[1], T[2], T[3], T[4], T[5]], !r && !u._v6 && (h[0] |= 1, r = h)), p == null && (p = (T[6] << 8 | T[7]) & 16383, s === void 0 && !u._v6 && (s = p));
    }
    let g = u.msecs !== void 0 ? u.msecs : Date.now(), m = u.nsecs !== void 0 ? u.nsecs : a + 1;
    const _ = g - i + (m - a) / 1e4;
    if (_ < 0 && u.clockseq === void 0 && (p = p + 1 & 16383), (_ < 0 || g > i) && u.nsecs === void 0 && (m = 0), m >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    i = g, a = m, s = p, g += 122192928e5;
    const y = ((g & 268435455) * 1e4 + m) % 4294967296;
    f[d++] = y >>> 24 & 255, f[d++] = y >>> 16 & 255, f[d++] = y >>> 8 & 255, f[d++] = y & 255;
    const b = g / 4294967296 * 1e4 & 268435455;
    f[d++] = b >>> 8 & 255, f[d++] = b & 255, f[d++] = b >>> 24 & 15 | 16, f[d++] = b >>> 16 & 255, f[d++] = p >>> 8 | 128, f[d++] = p & 255;
    for (let T = 0; T < 6; ++T)
      f[d + T] = h[T];
    return c || (0, t.unsafeStringify)(f);
  }
  return Ci.default = o, Ci;
}
var cu = {}, X_;
function FT() {
  if (X_) return cu;
  X_ = 1, Object.defineProperty(cu, "__esModule", {
    value: !0
  }), cu.default = r;
  var e = n(/* @__PURE__ */ bl()), t = /* @__PURE__ */ Gr();
  function n(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    const a = typeof i == "string" ? (0, e.default)(i) : i, o = s(a);
    return typeof i == "string" ? (0, t.unsafeStringify)(o) : o;
  }
  function s(i, a = !1) {
    return Uint8Array.of((i[6] & 15) << 4 | i[7] >> 4 & 15, (i[7] & 15) << 4 | (i[4] & 240) >> 4, (i[4] & 15) << 4 | (i[5] & 240) >> 4, (i[5] & 15) << 4 | (i[0] & 240) >> 4, (i[0] & 15) << 4 | (i[1] & 240) >> 4, (i[1] & 15) << 4 | (i[2] & 240) >> 4, 96 | i[2] & 15, i[3], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  }
  return cu;
}
var $i = {}, br = {}, Q_;
function zT() {
  if (Q_) return br;
  Q_ = 1, Object.defineProperty(br, "__esModule", {
    value: !0
  }), br.URL = br.DNS = void 0, br.default = a;
  var e = /* @__PURE__ */ Gr(), t = n(/* @__PURE__ */ bl());
  function n(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function r(o) {
    o = unescape(encodeURIComponent(o));
    const u = [];
    for (let c = 0; c < o.length; ++c)
      u.push(o.charCodeAt(c));
    return u;
  }
  const s = br.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", i = br.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function a(o, u, c) {
    function l(d, f, h, p) {
      var g;
      if (typeof d == "string" && (d = r(d)), typeof f == "string" && (f = (0, t.default)(f)), ((g = f) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + d.length);
      if (m.set(f), m.set(d, f.length), m = c(m), m[6] = m[6] & 15 | u, m[8] = m[8] & 63 | 128, h) {
        p = p || 0;
        for (let _ = 0; _ < 16; ++_)
          h[p + _] = m[_];
        return h;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = o;
    } catch {
    }
    return l.DNS = s, l.URL = i, l;
  }
  return br;
}
var Ri = {}, ey;
function tC() {
  if (ey) return Ri;
  ey = 1, Object.defineProperty(Ri, "__esModule", {
    value: !0
  }), Ri.default = void 0;
  var e = t(wn);
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), e.default.createHash("md5").update(r).digest();
  }
  return Ri.default = n, Ri;
}
var ty;
function nC() {
  if (ty) return $i;
  ty = 1, Object.defineProperty($i, "__esModule", {
    value: !0
  }), $i.default = void 0;
  var e = n(/* @__PURE__ */ zT()), t = n(/* @__PURE__ */ tC());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = (0, e.default)("v3", 48, t.default);
  return $i.default = r, $i;
}
var Pi = {}, Ni = {}, ny;
function rC() {
  if (ny) return Ni;
  ny = 1, Object.defineProperty(Ni, "__esModule", {
    value: !0
  }), Ni.default = void 0;
  var e = t(wn);
  function t(n) {
    return n && n.__esModule ? n : { default: n };
  }
  return Ni.default = {
    randomUUID: e.default.randomUUID
  }, Ni;
}
var ry;
function sC() {
  if (ry) return Pi;
  ry = 1, Object.defineProperty(Pi, "__esModule", {
    value: !0
  }), Pi.default = void 0;
  var e = r(/* @__PURE__ */ rC()), t = r(/* @__PURE__ */ Sm()), n = /* @__PURE__ */ Gr();
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function s(i, a, o) {
    if (e.default.randomUUID && !a && !i)
      return e.default.randomUUID();
    i = i || {};
    const u = i.random || (i.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, a) {
      o = o || 0;
      for (let c = 0; c < 16; ++c)
        a[o + c] = u[c];
      return a;
    }
    return (0, n.unsafeStringify)(u);
  }
  return Pi.default = s, Pi;
}
var Mi = {}, ji = {}, sy;
function iC() {
  if (sy) return ji;
  sy = 1, Object.defineProperty(ji, "__esModule", {
    value: !0
  }), ji.default = void 0;
  var e = t(wn);
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), e.default.createHash("sha1").update(r).digest();
  }
  return ji.default = n, ji;
}
var iy;
function aC() {
  if (iy) return Mi;
  iy = 1, Object.defineProperty(Mi, "__esModule", {
    value: !0
  }), Mi.default = void 0;
  var e = n(/* @__PURE__ */ zT()), t = n(/* @__PURE__ */ iC());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = (0, e.default)("v5", 80, t.default);
  return Mi.default = r, Mi;
}
var lu = {}, ay;
function oC() {
  if (ay) return lu;
  ay = 1, Object.defineProperty(lu, "__esModule", {
    value: !0
  }), lu.default = s;
  var e = /* @__PURE__ */ Gr(), t = r(/* @__PURE__ */ UT()), n = r(/* @__PURE__ */ FT());
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function s(i = {}, a, o = 0) {
    let u = (0, t.default)({
      ...i,
      _v6: !0
    }, new Uint8Array(16));
    if (u = (0, n.default)(u), a) {
      for (let c = 0; c < 16; c++)
        a[o + c] = u[c];
      return a;
    }
    return (0, e.unsafeStringify)(u);
  }
  return lu;
}
var du = {}, oy;
function uC() {
  if (oy) return du;
  oy = 1, Object.defineProperty(du, "__esModule", {
    value: !0
  }), du.default = r;
  var e = n(/* @__PURE__ */ bl()), t = /* @__PURE__ */ Gr();
  function n(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    const a = typeof i == "string" ? (0, e.default)(i) : i, o = s(a);
    return typeof i == "string" ? (0, t.unsafeStringify)(o) : o;
  }
  function s(i) {
    return Uint8Array.of((i[3] & 15) << 4 | i[4] >> 4 & 15, (i[4] & 15) << 4 | (i[5] & 240) >> 4, (i[5] & 15) << 4 | i[6] & 15, i[7], (i[1] & 15) << 4 | (i[2] & 240) >> 4, (i[2] & 15) << 4 | (i[3] & 240) >> 4, 16 | (i[0] & 240) >> 4, (i[0] & 15) << 4 | (i[1] & 240) >> 4, i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  }
  return du;
}
var Li = {}, uy;
function cC() {
  if (uy) return Li;
  uy = 1, Object.defineProperty(Li, "__esModule", {
    value: !0
  }), Li.default = void 0;
  var e = n(/* @__PURE__ */ Sm()), t = /* @__PURE__ */ Gr();
  function n(o) {
    return o && o.__esModule ? o : { default: o };
  }
  let r = null, s = null, i = 0;
  function a(o, u, c) {
    o = o || {};
    let l = u && c || 0;
    const d = u || new Uint8Array(16), f = o.random || (o.rng || e.default)(), h = o.msecs !== void 0 ? o.msecs : Date.now();
    let p = o.seq !== void 0 ? o.seq : null, g = s, m = r;
    return h > i && o.msecs === void 0 && (i = h, p !== null && (g = null, m = null)), p !== null && (p > 2147483647 && (p = 2147483647), g = p >>> 19 & 4095, m = p & 524287), (g === null || m === null) && (g = f[6] & 127, g = g << 8 | f[7], m = f[8] & 63, m = m << 8 | f[9], m = m << 5 | f[10] >>> 3), h + 1e4 > i && p === null ? ++m > 524287 && (m = 0, ++g > 4095 && (g = 0, i++)) : i = h, s = g, r = m, d[l++] = i / 1099511627776 & 255, d[l++] = i / 4294967296 & 255, d[l++] = i / 16777216 & 255, d[l++] = i / 65536 & 255, d[l++] = i / 256 & 255, d[l++] = i & 255, d[l++] = g >>> 4 & 15 | 112, d[l++] = g & 255, d[l++] = m >>> 13 & 63 | 128, d[l++] = m >>> 5 & 255, d[l++] = m << 3 & 255 | f[10] & 7, d[l++] = f[11], d[l++] = f[12], d[l++] = f[13], d[l++] = f[14], d[l++] = f[15], u || (0, t.unsafeStringify)(d);
  }
  return Li.default = a, Li;
}
var Di = {}, cy;
function lC() {
  if (cy) return Di;
  cy = 1, Object.defineProperty(Di, "__esModule", {
    value: !0
  }), Di.default = void 0;
  var e = t(/* @__PURE__ */ vl());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    if (!(0, e.default)(r))
      throw TypeError("Invalid UUID");
    return parseInt(r.slice(14, 15), 16);
  }
  return Di.default = n, Di;
}
var ly;
function dC() {
  return ly || (ly = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "MAX", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "v1ToV6", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v6", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "v6ToV1", {
      enumerable: !0,
      get: function() {
        return d.default;
      }
    }), Object.defineProperty(e, "v7", {
      enumerable: !0,
      get: function() {
        return f.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return h.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return p.default;
      }
    });
    var t = g(/* @__PURE__ */ XA()), n = g(/* @__PURE__ */ QA()), r = g(/* @__PURE__ */ bl()), s = g(/* @__PURE__ */ Gr()), i = g(/* @__PURE__ */ UT()), a = g(/* @__PURE__ */ FT()), o = g(/* @__PURE__ */ nC()), u = g(/* @__PURE__ */ sC()), c = g(/* @__PURE__ */ aC()), l = g(/* @__PURE__ */ oC()), d = g(/* @__PURE__ */ uC()), f = g(/* @__PURE__ */ cC()), h = g(/* @__PURE__ */ vl()), p = g(/* @__PURE__ */ lC());
    function g(m) {
      return m && m.__esModule ? m : { default: m };
    }
  })(Jd)), Jd;
}
var fC = /* @__PURE__ */ dC();
const Wt = /* @__PURE__ */ Zr(fC);
Wt.v1;
Wt.v1ToV6;
Wt.v3;
const qT = Wt.v4;
Wt.v5;
Wt.v6;
Wt.v6ToV1;
const ss = Wt.v7;
Wt.NIL;
Wt.MAX;
Wt.version;
const lc = Wt.validate;
Wt.stringify;
Wt.parse;
var hC = {};
$e(hC, {
  BaseCallbackHandler: () => jo,
  callbackHandlerPrefersStreaming: () => Tm,
  isBaseCallbackHandler: () => BT
});
var pC = class {
};
function Tm(e) {
  return "lc_prefer_streaming" in e && e.lc_prefer_streaming;
}
var jo = class extends pC {
  lc_serializable = !1;
  get lc_namespace() {
    return [
      "langchain_core",
      "callbacks",
      this.name
    ];
  }
  get lc_secrets() {
  }
  get lc_attributes() {
  }
  get lc_aliases() {
  }
  get lc_serializable_keys() {
  }
  /**
  * The name of the serializable. Override to provide an alias or
  * to preserve the serialized module name in minified environments.
  *
  * Implemented as a static method to support loading logic.
  */
  static lc_name() {
    return this.name;
  }
  /**
  * The final serialized identifier for the module.
  */
  get lc_id() {
    return [...this.lc_namespace, lm(this.constructor)];
  }
  lc_kwargs;
  ignoreLLM = !1;
  ignoreChain = !1;
  ignoreAgent = !1;
  ignoreRetriever = !1;
  ignoreCustomEvent = !1;
  raiseError = !1;
  awaitHandlers = on("LANGCHAIN_CALLBACKS_BACKGROUND") === "false";
  constructor(e) {
    super(), this.lc_kwargs = e || {}, e && (this.ignoreLLM = e.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = e.ignoreChain ?? this.ignoreChain, this.ignoreAgent = e.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = e.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = e.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = e.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || (e._awaitHandler ?? this.awaitHandlers));
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return ri.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return ri.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(e) {
    class t extends jo {
      name = ss();
      constructor() {
        super(), Object.assign(this, e);
      }
    }
    return new t();
  }
};
const BT = (e) => {
  const t = e;
  return t !== void 0 && typeof t.copy == "function" && typeof t.name == "string" && typeof t.awaitHandlers == "boolean";
};
var Kd = {}, Ui = {}, dy;
function mC() {
  return dy || (dy = 1, Object.defineProperty(Ui, "__esModule", {
    value: !0
  }), Ui.default = void 0, Ui.default = "ffffffff-ffff-ffff-ffff-ffffffffffff"), Ui;
}
var Fi = {}, fy;
function gC() {
  return fy || (fy = 1, Object.defineProperty(Fi, "__esModule", {
    value: !0
  }), Fi.default = void 0, Fi.default = "00000000-0000-0000-0000-000000000000"), Fi;
}
var zi = {}, qi = {}, Bi = {}, hy;
function _C() {
  return hy || (hy = 1, Object.defineProperty(Bi, "__esModule", {
    value: !0
  }), Bi.default = void 0, Bi.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i), Bi;
}
var py;
function Sl() {
  if (py) return qi;
  py = 1, Object.defineProperty(qi, "__esModule", {
    value: !0
  }), qi.default = void 0;
  var e = t(/* @__PURE__ */ _C());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return typeof r == "string" && e.default.test(r);
  }
  return qi.default = n, qi;
}
var my;
function Tl() {
  if (my) return zi;
  my = 1, Object.defineProperty(zi, "__esModule", {
    value: !0
  }), zi.default = void 0;
  var e = t(/* @__PURE__ */ Sl());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    if (!(0, e.default)(r))
      throw TypeError("Invalid UUID");
    let s;
    const i = new Uint8Array(16);
    return i[0] = (s = parseInt(r.slice(0, 8), 16)) >>> 24, i[1] = s >>> 16 & 255, i[2] = s >>> 8 & 255, i[3] = s & 255, i[4] = (s = parseInt(r.slice(9, 13), 16)) >>> 8, i[5] = s & 255, i[6] = (s = parseInt(r.slice(14, 18), 16)) >>> 8, i[7] = s & 255, i[8] = (s = parseInt(r.slice(19, 23), 16)) >>> 8, i[9] = s & 255, i[10] = (s = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, i[11] = s / 4294967296 & 255, i[12] = s >>> 24 & 255, i[13] = s >>> 16 & 255, i[14] = s >>> 8 & 255, i[15] = s & 255, i;
  }
  return zi.default = n, zi;
}
var Ms = {}, gy;
function Wr() {
  if (gy) return Ms;
  gy = 1, Object.defineProperty(Ms, "__esModule", {
    value: !0
  }), Ms.default = void 0, Ms.unsafeStringify = r;
  var e = t(/* @__PURE__ */ Sl());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  const n = [];
  for (let i = 0; i < 256; ++i)
    n.push((i + 256).toString(16).slice(1));
  function r(i, a = 0) {
    return (n[i[a + 0]] + n[i[a + 1]] + n[i[a + 2]] + n[i[a + 3]] + "-" + n[i[a + 4]] + n[i[a + 5]] + "-" + n[i[a + 6]] + n[i[a + 7]] + "-" + n[i[a + 8]] + n[i[a + 9]] + "-" + n[i[a + 10]] + n[i[a + 11]] + n[i[a + 12]] + n[i[a + 13]] + n[i[a + 14]] + n[i[a + 15]]).toLowerCase();
  }
  function s(i, a = 0) {
    const o = r(i, a);
    if (!(0, e.default)(o))
      throw TypeError("Stringified UUID is invalid");
    return o;
  }
  return Ms.default = s, Ms;
}
var Zi = {}, fu = {}, _y;
function xm() {
  if (_y) return fu;
  _y = 1, Object.defineProperty(fu, "__esModule", {
    value: !0
  }), fu.default = s;
  var e = t(wn);
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  const n = new Uint8Array(256);
  let r = n.length;
  function s() {
    return r > n.length - 16 && (e.default.randomFillSync(n), r = 0), n.slice(r, r += 16);
  }
  return fu;
}
var yy;
function ZT() {
  if (yy) return Zi;
  yy = 1, Object.defineProperty(Zi, "__esModule", {
    value: !0
  }), Zi.default = void 0;
  var e = n(/* @__PURE__ */ xm()), t = /* @__PURE__ */ Wr();
  function n(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let r, s, i = 0, a = 0;
  function o(u, c, l) {
    let d = c && l || 0;
    const f = c || new Array(16);
    u = u || {};
    let h = u.node, p = u.clockseq;
    if (u._v6 || (h || (h = r), p == null && (p = s)), h == null || p == null) {
      const T = u.random || (u.rng || e.default)();
      h == null && (h = [T[0], T[1], T[2], T[3], T[4], T[5]], !r && !u._v6 && (h[0] |= 1, r = h)), p == null && (p = (T[6] << 8 | T[7]) & 16383, s === void 0 && !u._v6 && (s = p));
    }
    let g = u.msecs !== void 0 ? u.msecs : Date.now(), m = u.nsecs !== void 0 ? u.nsecs : a + 1;
    const _ = g - i + (m - a) / 1e4;
    if (_ < 0 && u.clockseq === void 0 && (p = p + 1 & 16383), (_ < 0 || g > i) && u.nsecs === void 0 && (m = 0), m >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    i = g, a = m, s = p, g += 122192928e5;
    const y = ((g & 268435455) * 1e4 + m) % 4294967296;
    f[d++] = y >>> 24 & 255, f[d++] = y >>> 16 & 255, f[d++] = y >>> 8 & 255, f[d++] = y & 255;
    const b = g / 4294967296 * 1e4 & 268435455;
    f[d++] = b >>> 8 & 255, f[d++] = b & 255, f[d++] = b >>> 24 & 15 | 16, f[d++] = b >>> 16 & 255, f[d++] = p >>> 8 | 128, f[d++] = p & 255;
    for (let T = 0; T < 6; ++T)
      f[d + T] = h[T];
    return c || (0, t.unsafeStringify)(f);
  }
  return Zi.default = o, Zi;
}
var hu = {}, wy;
function VT() {
  if (wy) return hu;
  wy = 1, Object.defineProperty(hu, "__esModule", {
    value: !0
  }), hu.default = r;
  var e = n(/* @__PURE__ */ Tl()), t = /* @__PURE__ */ Wr();
  function n(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    const a = typeof i == "string" ? (0, e.default)(i) : i, o = s(a);
    return typeof i == "string" ? (0, t.unsafeStringify)(o) : o;
  }
  function s(i, a = !1) {
    return Uint8Array.of((i[6] & 15) << 4 | i[7] >> 4 & 15, (i[7] & 15) << 4 | (i[4] & 240) >> 4, (i[4] & 15) << 4 | (i[5] & 240) >> 4, (i[5] & 15) << 4 | (i[0] & 240) >> 4, (i[0] & 15) << 4 | (i[1] & 240) >> 4, (i[1] & 15) << 4 | (i[2] & 240) >> 4, 96 | i[2] & 15, i[3], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  }
  return hu;
}
var Vi = {}, Sr = {}, vy;
function HT() {
  if (vy) return Sr;
  vy = 1, Object.defineProperty(Sr, "__esModule", {
    value: !0
  }), Sr.URL = Sr.DNS = void 0, Sr.default = a;
  var e = /* @__PURE__ */ Wr(), t = n(/* @__PURE__ */ Tl());
  function n(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function r(o) {
    o = unescape(encodeURIComponent(o));
    const u = [];
    for (let c = 0; c < o.length; ++c)
      u.push(o.charCodeAt(c));
    return u;
  }
  const s = Sr.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", i = Sr.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function a(o, u, c) {
    function l(d, f, h, p) {
      var g;
      if (typeof d == "string" && (d = r(d)), typeof f == "string" && (f = (0, t.default)(f)), ((g = f) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + d.length);
      if (m.set(f), m.set(d, f.length), m = c(m), m[6] = m[6] & 15 | u, m[8] = m[8] & 63 | 128, h) {
        p = p || 0;
        for (let _ = 0; _ < 16; ++_)
          h[p + _] = m[_];
        return h;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = o;
    } catch {
    }
    return l.DNS = s, l.URL = i, l;
  }
  return Sr;
}
var Hi = {}, by;
function yC() {
  if (by) return Hi;
  by = 1, Object.defineProperty(Hi, "__esModule", {
    value: !0
  }), Hi.default = void 0;
  var e = t(wn);
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), e.default.createHash("md5").update(r).digest();
  }
  return Hi.default = n, Hi;
}
var Sy;
function wC() {
  if (Sy) return Vi;
  Sy = 1, Object.defineProperty(Vi, "__esModule", {
    value: !0
  }), Vi.default = void 0;
  var e = n(/* @__PURE__ */ HT()), t = n(/* @__PURE__ */ yC());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = (0, e.default)("v3", 48, t.default);
  return Vi.default = r, Vi;
}
var Gi = {}, Wi = {}, Ty;
function vC() {
  if (Ty) return Wi;
  Ty = 1, Object.defineProperty(Wi, "__esModule", {
    value: !0
  }), Wi.default = void 0;
  var e = t(wn);
  function t(n) {
    return n && n.__esModule ? n : { default: n };
  }
  return Wi.default = {
    randomUUID: e.default.randomUUID
  }, Wi;
}
var xy;
function bC() {
  if (xy) return Gi;
  xy = 1, Object.defineProperty(Gi, "__esModule", {
    value: !0
  }), Gi.default = void 0;
  var e = r(/* @__PURE__ */ vC()), t = r(/* @__PURE__ */ xm()), n = /* @__PURE__ */ Wr();
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function s(i, a, o) {
    if (e.default.randomUUID && !a && !i)
      return e.default.randomUUID();
    i = i || {};
    const u = i.random || (i.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, a) {
      o = o || 0;
      for (let c = 0; c < 16; ++c)
        a[o + c] = u[c];
      return a;
    }
    return (0, n.unsafeStringify)(u);
  }
  return Gi.default = s, Gi;
}
var Ji = {}, Ki = {}, Ey;
function SC() {
  if (Ey) return Ki;
  Ey = 1, Object.defineProperty(Ki, "__esModule", {
    value: !0
  }), Ki.default = void 0;
  var e = t(wn);
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), e.default.createHash("sha1").update(r).digest();
  }
  return Ki.default = n, Ki;
}
var ky;
function TC() {
  if (ky) return Ji;
  ky = 1, Object.defineProperty(Ji, "__esModule", {
    value: !0
  }), Ji.default = void 0;
  var e = n(/* @__PURE__ */ HT()), t = n(/* @__PURE__ */ SC());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = (0, e.default)("v5", 80, t.default);
  return Ji.default = r, Ji;
}
var pu = {}, Oy;
function xC() {
  if (Oy) return pu;
  Oy = 1, Object.defineProperty(pu, "__esModule", {
    value: !0
  }), pu.default = s;
  var e = /* @__PURE__ */ Wr(), t = r(/* @__PURE__ */ ZT()), n = r(/* @__PURE__ */ VT());
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function s(i = {}, a, o = 0) {
    let u = (0, t.default)({
      ...i,
      _v6: !0
    }, new Uint8Array(16));
    if (u = (0, n.default)(u), a) {
      for (let c = 0; c < 16; c++)
        a[o + c] = u[c];
      return a;
    }
    return (0, e.unsafeStringify)(u);
  }
  return pu;
}
var mu = {}, Iy;
function EC() {
  if (Iy) return mu;
  Iy = 1, Object.defineProperty(mu, "__esModule", {
    value: !0
  }), mu.default = r;
  var e = n(/* @__PURE__ */ Tl()), t = /* @__PURE__ */ Wr();
  function n(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    const a = typeof i == "string" ? (0, e.default)(i) : i, o = s(a);
    return typeof i == "string" ? (0, t.unsafeStringify)(o) : o;
  }
  function s(i) {
    return Uint8Array.of((i[3] & 15) << 4 | i[4] >> 4 & 15, (i[4] & 15) << 4 | (i[5] & 240) >> 4, (i[5] & 15) << 4 | i[6] & 15, i[7], (i[1] & 15) << 4 | (i[2] & 240) >> 4, (i[2] & 15) << 4 | (i[3] & 240) >> 4, 16 | (i[0] & 240) >> 4, (i[0] & 15) << 4 | (i[1] & 240) >> 4, i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  }
  return mu;
}
var Yi = {}, Ay;
function kC() {
  if (Ay) return Yi;
  Ay = 1, Object.defineProperty(Yi, "__esModule", {
    value: !0
  }), Yi.default = void 0;
  var e = n(/* @__PURE__ */ xm()), t = /* @__PURE__ */ Wr();
  function n(o) {
    return o && o.__esModule ? o : { default: o };
  }
  let r = null, s = null, i = 0;
  function a(o, u, c) {
    o = o || {};
    let l = u && c || 0;
    const d = u || new Uint8Array(16), f = o.random || (o.rng || e.default)(), h = o.msecs !== void 0 ? o.msecs : Date.now();
    let p = o.seq !== void 0 ? o.seq : null, g = s, m = r;
    return h > i && o.msecs === void 0 && (i = h, p !== null && (g = null, m = null)), p !== null && (p > 2147483647 && (p = 2147483647), g = p >>> 19 & 4095, m = p & 524287), (g === null || m === null) && (g = f[6] & 127, g = g << 8 | f[7], m = f[8] & 63, m = m << 8 | f[9], m = m << 5 | f[10] >>> 3), h + 1e4 > i && p === null ? ++m > 524287 && (m = 0, ++g > 4095 && (g = 0, i++)) : i = h, s = g, r = m, d[l++] = i / 1099511627776 & 255, d[l++] = i / 4294967296 & 255, d[l++] = i / 16777216 & 255, d[l++] = i / 65536 & 255, d[l++] = i / 256 & 255, d[l++] = i & 255, d[l++] = g >>> 4 & 15 | 112, d[l++] = g & 255, d[l++] = m >>> 13 & 63 | 128, d[l++] = m >>> 5 & 255, d[l++] = m << 3 & 255 | f[10] & 7, d[l++] = f[11], d[l++] = f[12], d[l++] = f[13], d[l++] = f[14], d[l++] = f[15], u || (0, t.unsafeStringify)(d);
  }
  return Yi.default = a, Yi;
}
var Xi = {}, Cy;
function OC() {
  if (Cy) return Xi;
  Cy = 1, Object.defineProperty(Xi, "__esModule", {
    value: !0
  }), Xi.default = void 0;
  var e = t(/* @__PURE__ */ Sl());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    if (!(0, e.default)(r))
      throw TypeError("Invalid UUID");
    return parseInt(r.slice(14, 15), 16);
  }
  return Xi.default = n, Xi;
}
var $y;
function IC() {
  return $y || ($y = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "MAX", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "v1ToV6", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v6", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "v6ToV1", {
      enumerable: !0,
      get: function() {
        return d.default;
      }
    }), Object.defineProperty(e, "v7", {
      enumerable: !0,
      get: function() {
        return f.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return h.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return p.default;
      }
    });
    var t = g(/* @__PURE__ */ mC()), n = g(/* @__PURE__ */ gC()), r = g(/* @__PURE__ */ Tl()), s = g(/* @__PURE__ */ Wr()), i = g(/* @__PURE__ */ ZT()), a = g(/* @__PURE__ */ VT()), o = g(/* @__PURE__ */ wC()), u = g(/* @__PURE__ */ bC()), c = g(/* @__PURE__ */ TC()), l = g(/* @__PURE__ */ xC()), d = g(/* @__PURE__ */ EC()), f = g(/* @__PURE__ */ kC()), h = g(/* @__PURE__ */ Sl()), p = g(/* @__PURE__ */ OC());
    function g(m) {
      return m && m.__esModule ? m : { default: m };
    }
  })(Kd)), Kd;
}
var AC = /* @__PURE__ */ IC();
const Jt = /* @__PURE__ */ Zr(AC);
Jt.v1;
Jt.v1ToV6;
Jt.v3;
const Qi = Jt.v4, qa = Jt.v5;
Jt.v6;
Jt.v6ToV1;
const CC = Jt.v7;
Jt.NIL;
Jt.MAX;
Jt.version;
Jt.validate;
Jt.stringify;
Jt.parse;
const $C = "gen_ai.operation.name", RC = "gen_ai.system", Ry = "gen_ai.request.model", PC = "gen_ai.response.model", Py = "gen_ai.usage.input_tokens", Ny = "gen_ai.usage.output_tokens", My = "gen_ai.usage.total_tokens", NC = "gen_ai.request.max_tokens", MC = "gen_ai.request.temperature", jC = "gen_ai.request.top_p", LC = "gen_ai.request.frequency_penalty", DC = "gen_ai.request.presence_penalty", UC = "gen_ai.response.finish_reasons", FC = "gen_ai.prompt", zC = "gen_ai.completion", qC = "gen_ai.request.extra_query", BC = "gen_ai.request.extra_body", ZC = "gen_ai.serialized.name", VC = "gen_ai.serialized.signature", HC = "gen_ai.serialized.doc", GC = "gen_ai.response.id", WC = "gen_ai.response.service_tier", JC = "gen_ai.response.system_fingerprint", KC = "gen_ai.usage.input_token_details", YC = "gen_ai.usage.output_token_details", XC = "langsmith.trace.session_id", QC = "langsmith.trace.session_name", e$ = "langsmith.span.kind", t$ = "langsmith.trace.name", n$ = "langsmith.metadata", jy = "langsmith.span.tags", r$ = "langsmith.request.streaming", s$ = "langsmith.request.headers", i$ = (...e) => fetch(...e), GT = /* @__PURE__ */ Symbol.for("ls:fetch_implementation"), a$ = () => {
  const e = globalThis[GT];
  return e ? typeof e == "function" && "Headers" in e && "Request" in e && "Response" in e : !1;
}, o$ = (e) => async (...t) => {
  if (e || Bt("DEBUG") === "true") {
    const [r, s] = t;
    console.log(` ${s?.method || "GET"} ${r}`);
  }
  const n = await (globalThis[GT] ?? i$)(...t);
  return (e || Bt("DEBUG") === "true") && console.log(` ${n.status} ${n.statusText} ${n.url}`), n;
}, WT = () => Bt("PROJECT") ?? Yn("LANGCHAIN_SESSION") ?? // TODO: Deprecate
"default", Ly = {};
function JT(e) {
  Ly[e] || (console.warn(e), Ly[e] = !0);
}
const u$ = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function ve(e, t) {
  if (!u$.test(e)) {
    const n = t !== void 0 ? `Invalid UUID for ${t}: ${e}` : `Invalid UUID: ${e}`;
    throw new Error(n);
  }
  return e;
}
function c$(e) {
  const t = typeof e == "string" ? Date.parse(e) : e;
  return CC({ msecs: t, seq: 0 });
}
function l$(e, t) {
  const n = rI.dirname(e);
  Cr.existsSync(n) || Cr.mkdirSync(n, { recursive: !0 });
  const r = { entries: t }, s = `${e}.tmp`;
  try {
    Cr.writeFileSync(s, JSON.stringify(r, null, 2)), Cr.renameSync(s, e);
  } catch (i) {
    throw Cr.existsSync(s) && Cr.unlinkSync(s), i;
  }
}
function d$(e) {
  if (!Cr.existsSync(e))
    return null;
  try {
    const t = Cr.readFileSync(e, "utf-8");
    return JSON.parse(t).entries ?? null;
  } catch {
    return null;
  }
}
function f$(e, t) {
  return t === null ? !1 : Date.now() - e.createdAt > t * 1e3;
}
class h$ {
  constructor(t = {}) {
    Object.defineProperty(this, "cache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ttlSeconds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "refreshIntervalSeconds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchFunc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "refreshTimer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_metrics", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        hits: 0,
        misses: 0,
        refreshes: 0,
        refreshErrors: 0
      }
    }), this.maxSize = t.maxSize ?? 100, this.ttlSeconds = t.ttlSeconds ?? 3600, this.refreshIntervalSeconds = t.refreshIntervalSeconds ?? 60, this.fetchFunc = t.fetchFunc, this.fetchFunc && this.ttlSeconds !== null && this.startRefreshLoop();
  }
  /**
   * Get cache performance metrics.
   */
  get metrics() {
    return { ...this._metrics };
  }
  /**
   * Get total cache requests (hits + misses).
   */
  get totalRequests() {
    return this._metrics.hits + this._metrics.misses;
  }
  /**
   * Get cache hit rate (0.0 to 1.0).
   */
  get hitRate() {
    const t = this.totalRequests;
    return t > 0 ? this._metrics.hits / t : 0;
  }
  /**
   * Reset all metrics to zero.
   */
  resetMetrics() {
    this._metrics = {
      hits: 0,
      misses: 0,
      refreshes: 0,
      refreshErrors: 0
    };
  }
  /**
   * Get a value from cache.
   *
   * Returns the cached value or undefined if not found.
   * Stale entries are still returned (background refresh handles updates).
   */
  get(t) {
    const n = this.cache.get(t);
    if (!n) {
      this._metrics.misses += 1;
      return;
    }
    return this.cache.delete(t), this.cache.set(t, n), this._metrics.hits += 1, n.value;
  }
  /**
   * Set a value in the cache.
   */
  set(t, n) {
    if (!this.cache.has(t) && this.cache.size >= this.maxSize) {
      const s = this.cache.keys().next().value;
      s !== void 0 && this.cache.delete(s);
    }
    const r = {
      value: n,
      createdAt: Date.now()
    };
    this.cache.delete(t), this.cache.set(t, r);
  }
  /**
   * Remove a specific entry from cache.
   */
  invalidate(t) {
    this.cache.delete(t);
  }
  /**
   * Clear all cache entries.
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get the number of entries in the cache.
   */
  get size() {
    return this.cache.size;
  }
  /**
   * Stop background refresh.
   * Should be called when the client is being cleaned up.
   */
  stop() {
    this.refreshTimer && (clearInterval(this.refreshTimer), this.refreshTimer = void 0);
  }
  /**
   * Dump cache contents to a JSON file for offline use.
   */
  dump(t) {
    const n = {};
    for (const [r, s] of this.cache.entries())
      n[r] = s.value;
    l$(t, n);
  }
  /**
   * Load cache contents from a JSON file.
   *
   * Loaded entries get a fresh TTL starting from load time.
   *
   * @returns Number of entries loaded.
   */
  load(t) {
    const n = d$(t);
    if (!n)
      return 0;
    let r = 0;
    const s = Date.now();
    for (const [i, a] of Object.entries(n)) {
      if (this.cache.size >= this.maxSize)
        break;
      const o = {
        value: a,
        createdAt: s
        // Fresh TTL from load time
      };
      this.cache.set(i, o), r += 1;
    }
    return r;
  }
  /**
   * Start the background refresh loop.
   */
  startRefreshLoop() {
    this.refreshTimer = setInterval(() => {
      this.refreshStaleEntries().catch((t) => {
        console.warn("Unexpected error in cache refresh loop:", t);
      });
    }, this.refreshIntervalSeconds * 1e3), this.refreshTimer.unref && this.refreshTimer.unref();
  }
  /**
   * Get list of stale cache keys.
   */
  getStaleKeys() {
    const t = [];
    for (const [n, r] of this.cache.entries())
      f$(r, this.ttlSeconds) && t.push(n);
    return t;
  }
  /**
   * Check for stale entries and refresh them.
   */
  async refreshStaleEntries() {
    if (!this.fetchFunc)
      return;
    const t = this.getStaleKeys();
    if (t.length !== 0)
      for (const n of t)
        try {
          const r = await this.fetchFunc(n);
          this.set(n, r), this._metrics.refreshes += 1;
        } catch (r) {
          this._metrics.refreshErrors += 1, console.warn(`Failed to refresh cache entry ${n}:`, r);
        }
  }
}
const KT = "0.4.6";
let Bn;
const p$ = () => typeof window < "u" && typeof window.document < "u", m$ = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", g$ = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), YT = () => typeof Deno < "u", _$ = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !YT(), XT = () => Bn || (typeof Bun < "u" ? Bn = "bun" : p$() ? Bn = "browser" : _$() ? Bn = "node" : m$() ? Bn = "webworker" : g$() ? Bn = "jsdom" : YT() ? Bn = "deno" : Bn = "other", Bn);
let Yd;
function QT() {
  if (Yd === void 0) {
    const e = XT(), t = w$();
    Yd = {
      library: "langsmith",
      runtime: e,
      sdk: "langsmith-js",
      sdk_version: KT,
      ...t
    };
  }
  return Yd;
}
function ex() {
  const e = y$(), t = {}, n = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [r, s] of Object.entries(e))
    typeof s == "string" && !n.includes(r) && !r.toLowerCase().includes("key") && !r.toLowerCase().includes("secret") && !r.toLowerCase().includes("token") && (r === "LANGCHAIN_REVISION_ID" ? t.revision_id = s : t[r] = s);
  return t;
}
function y$() {
  const e = {};
  try {
    if (typeof process < "u" && process.env)
      for (const [t, n] of Object.entries(process.env))
        (t.startsWith("LANGCHAIN_") || t.startsWith("LANGSMITH_")) && n != null && ((t.toLowerCase().includes("key") || t.toLowerCase().includes("secret") || t.toLowerCase().includes("token")) && typeof n == "string" ? e[t] = n.slice(0, 2) + "*".repeat(n.length - 4) + n.slice(-2) : e[t] = n);
  } catch {
  }
  return e;
}
function Yn(e) {
  try {
    return typeof process < "u" ? (
      // eslint-disable-next-line no-process-env
      process.env?.[e]
    ) : void 0;
  } catch {
    return;
  }
}
function Bt(e) {
  return Yn(`LANGSMITH_${e}`) || Yn(`LANGCHAIN_${e}`);
}
let Xd;
function w$() {
  if (Xd !== void 0)
    return Xd;
  const e = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ], t = {};
  for (const n of e) {
    const r = Yn(n);
    r !== void 0 && (t[n] = r);
  }
  return Xd = t, t;
}
function tx() {
  return Yn("OTEL_ENABLED") === "true" || Bt("OTEL_ENABLED") === "true";
}
class v$ {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  startActiveSpan(t, ...n) {
    !this.hasWarned && tx() && (console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.'), this.hasWarned = !0);
    let r;
    if (n.length === 1 && typeof n[0] == "function" ? r = n[0] : n.length === 2 && typeof n[1] == "function" ? r = n[1] : n.length === 3 && typeof n[2] == "function" && (r = n[2]), typeof r == "function")
      return r();
  }
}
class b$ {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new v$()
    });
  }
  getTracer(t, n) {
    return this.mockTracer;
  }
  getActiveSpan() {
  }
  setSpan(t, n) {
    return t;
  }
  getSpan(t) {
  }
  setSpanContext(t, n) {
    return t;
  }
  getTracerProvider() {
  }
  setGlobalTracerProvider(t) {
    return !1;
  }
}
class S$ {
  active() {
    return {};
  }
  with(t, n) {
    return n();
  }
}
const Qd = /* @__PURE__ */ Symbol.for("ls:otel_trace"), ef = /* @__PURE__ */ Symbol.for("ls:otel_context"), Dy = /* @__PURE__ */ Symbol.for("ls:otel_get_default_otlp_tracer_provider"), T$ = new b$(), x$ = new S$();
class E$ {
  getTraceInstance() {
    return globalThis[Qd] ?? T$;
  }
  getContextInstance() {
    return globalThis[ef] ?? x$;
  }
  initializeGlobalInstances(t) {
    globalThis[Qd] === void 0 && (globalThis[Qd] = t.trace), globalThis[ef] === void 0 && (globalThis[ef] = t.context);
  }
  setDefaultOTLPTracerComponents(t) {
    globalThis[Dy] = t;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[Dy] ?? void 0;
  }
}
const Em = new E$();
function nx() {
  return Em.getTraceInstance();
}
function k$() {
  return Em.getContextInstance();
}
function O$() {
  return Em.getDefaultOTLPTracerComponents();
}
const I$ = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function A$(e) {
  return I$[e] || e;
}
class C$ {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    });
  }
  exportBatch(t, n) {
    for (const r of t)
      try {
        if (!r.run)
          continue;
        if (r.operation === "post") {
          const s = this.createSpanForRun(r, r.run, n.get(r.id));
          s && !r.run.end_time && this.spans.set(r.id, s);
        } else
          this.updateSpanForRun(r, r.run);
      } catch (s) {
        console.error(`Error processing operation ${r.id}:`, s);
      }
  }
  createSpanForRun(t, n, r) {
    const s = r && nx().getSpan(r);
    if (s)
      try {
        return this.finishSpanSetup(s, n, t);
      } catch (i) {
        console.error(`Failed to create span for run ${t.id}:`, i);
        return;
      }
  }
  finishSpanSetup(t, n, r) {
    return this.setSpanAttributes(t, n, r), n.error ? (t.setStatus({ code: 2 }), t.recordException(new Error(n.error))) : t.setStatus({ code: 1 }), n.end_time && t.end(new Date(n.end_time)), t;
  }
  updateSpanForRun(t, n) {
    try {
      const r = this.spans.get(t.id);
      if (!r) {
        console.debug(`No span found for run ${t.id} during update`);
        return;
      }
      this.setSpanAttributes(r, n, t), n.error ? (r.setStatus({ code: 2 }), r.recordException(new Error(n.error))) : r.setStatus({ code: 1 });
      const s = n.end_time;
      s && (r.end(new Date(s)), this.spans.delete(t.id));
    } catch (r) {
      console.error(`Failed to update span for run ${t.id}:`, r);
    }
  }
  extractModelName(t) {
    if (t.extra?.metadata) {
      const n = t.extra.metadata;
      if (n.ls_model_name)
        return n.ls_model_name;
      if (n.invocation_params) {
        const r = n.invocation_params;
        if (r.model)
          return r.model;
        if (r.model_name)
          return r.model_name;
      }
    }
  }
  setSpanAttributes(t, n, r) {
    if ("run_type" in n && n.run_type) {
      t.setAttribute(e$, n.run_type);
      const o = A$(n.run_type || "chain");
      t.setAttribute($C, o);
    }
    "name" in n && n.name && t.setAttribute(t$, n.name), "session_id" in n && n.session_id && t.setAttribute(XC, n.session_id), "session_name" in n && n.session_name && t.setAttribute(QC, n.session_name), this.setGenAiSystem(t, n);
    const s = this.extractModelName(n);
    s && t.setAttribute(Ry, s), "prompt_tokens" in n && typeof n.prompt_tokens == "number" && t.setAttribute(Py, n.prompt_tokens), "completion_tokens" in n && typeof n.completion_tokens == "number" && t.setAttribute(Ny, n.completion_tokens), "total_tokens" in n && typeof n.total_tokens == "number" && t.setAttribute(My, n.total_tokens), this.setInvocationParameters(t, n);
    const i = n.extra?.metadata || {};
    for (const [o, u] of Object.entries(i))
      u != null && t.setAttribute(`${n$}.${o}`, String(u));
    const a = n.tags;
    if (a && Array.isArray(a) ? t.setAttribute(jy, a.join(", ")) : a && t.setAttribute(jy, String(a)), "serialized" in n && typeof n.serialized == "object") {
      const o = n.serialized;
      o.name && t.setAttribute(ZC, String(o.name)), o.signature && t.setAttribute(VC, String(o.signature)), o.doc && t.setAttribute(HC, String(o.doc));
    }
    this.setIOAttributes(t, r);
  }
  setGenAiSystem(t, n) {
    let r = "langchain";
    const s = this.extractModelName(n);
    if (s) {
      const i = s.toLowerCase();
      i.includes("anthropic") || i.startsWith("claude") ? r = "anthropic" : i.includes("bedrock") ? r = "aws.bedrock" : i.includes("azure") && i.includes("openai") ? r = "az.ai.openai" : i.includes("azure") && i.includes("inference") ? r = "az.ai.inference" : i.includes("cohere") ? r = "cohere" : i.includes("deepseek") ? r = "deepseek" : i.includes("gemini") ? r = "gemini" : i.includes("groq") ? r = "groq" : i.includes("watson") || i.includes("ibm") ? r = "ibm.watsonx.ai" : i.includes("mistral") ? r = "mistral_ai" : i.includes("gpt") || i.includes("openai") ? r = "openai" : i.includes("perplexity") || i.includes("sonar") ? r = "perplexity" : i.includes("vertex") ? r = "vertex_ai" : (i.includes("xai") || i.includes("grok")) && (r = "xai");
    }
    t.setAttribute(RC, r);
  }
  setInvocationParameters(t, n) {
    if (!n.extra?.metadata?.invocation_params)
      return;
    const r = n.extra.metadata.invocation_params;
    r.max_tokens !== void 0 && t.setAttribute(NC, r.max_tokens), r.temperature !== void 0 && t.setAttribute(MC, r.temperature), r.top_p !== void 0 && t.setAttribute(jC, r.top_p), r.frequency_penalty !== void 0 && t.setAttribute(LC, r.frequency_penalty), r.presence_penalty !== void 0 && t.setAttribute(DC, r.presence_penalty);
  }
  setIOAttributes(t, n) {
    if (n.run.inputs)
      try {
        const r = n.run.inputs;
        typeof r == "object" && r !== null && (r.model && Array.isArray(r.messages) && t.setAttribute(Ry, r.model), r.stream !== void 0 && t.setAttribute(r$, r.stream), r.extra_headers && t.setAttribute(s$, JSON.stringify(r.extra_headers)), r.extra_query && t.setAttribute(qC, JSON.stringify(r.extra_query)), r.extra_body && t.setAttribute(BC, JSON.stringify(r.extra_body))), t.setAttribute(FC, JSON.stringify(r));
      } catch (r) {
        console.debug(`Failed to process inputs for run ${n.id}`, r);
      }
    if (n.run.outputs)
      try {
        const r = n.run.outputs, s = this.getUnifiedRunTokens(r);
        if (s && (t.setAttribute(Py, s[0]), t.setAttribute(Ny, s[1]), t.setAttribute(My, s[0] + s[1])), r && typeof r == "object") {
          if (r.model && t.setAttribute(PC, String(r.model)), r.id && t.setAttribute(GC, r.id), r.choices && Array.isArray(r.choices)) {
            const i = r.choices.map((a) => a.finish_reason).filter((a) => a).map(String);
            i.length > 0 && t.setAttribute(UC, i.join(", "));
          }
          if (r.service_tier && t.setAttribute(WC, r.service_tier), r.system_fingerprint && t.setAttribute(JC, r.system_fingerprint), r.usage_metadata && typeof r.usage_metadata == "object") {
            const i = r.usage_metadata;
            i.input_token_details && t.setAttribute(KC, JSON.stringify(i.input_token_details)), i.output_token_details && t.setAttribute(YC, JSON.stringify(i.output_token_details));
          }
        }
        t.setAttribute(zC, JSON.stringify(r));
      } catch (r) {
        console.debug(`Failed to process outputs for run ${n.id}`, r);
      }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUnifiedRunTokens(t) {
    if (!t)
      return null;
    let n = this.extractUnifiedRunTokens(t.usage_metadata);
    if (n)
      return n;
    const r = Object.keys(t);
    for (const a of r) {
      const o = t[a];
      if (!(!o || typeof o != "object") && (n = this.extractUnifiedRunTokens(o.usage_metadata), n || o.lc === 1 && o.kwargs && typeof o.kwargs == "object" && (n = this.extractUnifiedRunTokens(o.kwargs.usage_metadata), n)))
        return n;
    }
    const s = t.generations || [];
    if (!Array.isArray(s))
      return null;
    const i = Array.isArray(s[0]) ? s.flat() : s;
    for (const a of i)
      if (typeof a == "object" && a.message && typeof a.message == "object" && a.message.kwargs && typeof a.message.kwargs == "object" && (n = this.extractUnifiedRunTokens(a.message.kwargs.usage_metadata), n))
        return n;
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractUnifiedRunTokens(t) {
    return !t || typeof t != "object" || typeof t.input_tokens != "number" || typeof t.output_tokens != "number" ? null : [t.input_tokens, t.output_tokens];
  }
}
const $$ = Object.prototype.toString, R$ = (e) => $$.call(e) === "[object Error]", P$ = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function N$(e) {
  if (!(e && R$(e) && e.name === "TypeError" && typeof e.message == "string"))
    return !1;
  const { message: n, stack: r } = e;
  return n === "Load failed" ? r === void 0 || // Sentry adds its own stack trace to the fetch error, so also check for that
  "__sentry_captured__" in e : n.startsWith("error sending request for url") ? !0 : P$.has(n);
}
function M$(e) {
  if (typeof e == "number") {
    if (e < 0)
      throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(e))
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (e !== void 0)
    throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function gu(e, t, { min: n = 0, allowInfinity: r = !1 } = {}) {
  if (t !== void 0) {
    if (typeof t != "number" || Number.isNaN(t))
      throw new TypeError(`Expected \`${e}\` to be a number${r ? " or Infinity" : ""}.`);
    if (!r && !Number.isFinite(t))
      throw new TypeError(`Expected \`${e}\` to be a finite number.`);
    if (t < n)
      throw new TypeError(`Expected \`${e}\` to be  ${n}.`);
  }
}
let j$ = class extends Error {
  constructor(t) {
    super(), t instanceof Error ? (this.originalError = t, { message: t } = t) : (this.originalError = new Error(t), this.originalError.stack = this.stack), this.name = "AbortError", this.message = t;
  }
};
function L$(e, t) {
  const n = Math.max(1, e + 1), r = t.randomize ? Math.random() + 1 : 1;
  let s = Math.round(r * t.minTimeout * t.factor ** (n - 1));
  return s = Math.min(s, t.maxTimeout), s;
}
function Uy(e, t) {
  return Number.isFinite(t) ? t - (performance.now() - e) : t;
}
async function D$({ error: e, attemptNumber: t, retriesConsumed: n, startTime: r, options: s }) {
  const i = e instanceof Error ? e : new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`);
  if (i instanceof j$)
    throw i.originalError;
  const a = Number.isFinite(s.retries) ? Math.max(0, s.retries - n) : s.retries, o = s.maxRetryTime ?? Number.POSITIVE_INFINITY, u = Object.freeze({
    error: i,
    attemptNumber: t,
    retriesLeft: a,
    retriesConsumed: n
  });
  if (await s.onFailedAttempt(u), Uy(r, o) <= 0)
    throw i;
  const c = await s.shouldConsumeRetry(u), l = Uy(r, o);
  if (l <= 0 || a <= 0)
    throw i;
  if (i instanceof TypeError && !N$(i)) {
    if (c)
      throw i;
    return s.signal?.throwIfAborted(), !1;
  }
  if (!await s.shouldRetry(u))
    throw i;
  if (!c)
    return s.signal?.throwIfAborted(), !1;
  const d = L$(n, s), f = Math.min(d, l);
  return f > 0 && await new Promise((h, p) => {
    const g = () => {
      clearTimeout(m), s.signal?.removeEventListener("abort", g), p(s.signal.reason);
    }, m = setTimeout(() => {
      s.signal?.removeEventListener("abort", g), h();
    }, f);
    s.unref && m.unref?.(), s.signal?.addEventListener("abort", g, { once: !0 });
  }), s.signal?.throwIfAborted(), !0;
}
async function U$(e, t = {}) {
  if (t = { ...t }, M$(t.retries), Object.hasOwn(t, "forever"))
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  t.retries ??= 10, t.factor ??= 2, t.minTimeout ??= 1e3, t.maxTimeout ??= Number.POSITIVE_INFINITY, t.maxRetryTime ??= Number.POSITIVE_INFINITY, t.randomize ??= !1, t.onFailedAttempt ??= () => {
  }, t.shouldRetry ??= () => !0, t.shouldConsumeRetry ??= () => !0, gu("factor", t.factor, {
    min: 0,
    allowInfinity: !1
  }), gu("minTimeout", t.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), gu("maxTimeout", t.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), gu("maxRetryTime", t.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), t.factor > 0 || (t.factor = 1), t.signal?.throwIfAborted();
  let n = 0, r = 0;
  const s = performance.now();
  for (; !Number.isFinite(t.retries) || r <= t.retries; ) {
    n++;
    try {
      t.signal?.throwIfAborted();
      const i = await e(n);
      return t.signal?.throwIfAborted(), i;
    } catch (i) {
      await D$({
        error: i,
        attemptNumber: n,
        retriesConsumed: r,
        startTime: s,
        options: t
      }) && r++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var _u = {}, tf = { exports: {} }, Fy;
function F$() {
  return Fy || (Fy = 1, (function(e) {
    var t = Object.prototype.hasOwnProperty, n = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
    function s(u, c, l) {
      this.fn = u, this.context = c, this.once = l || !1;
    }
    function i(u, c, l, d, f) {
      if (typeof l != "function")
        throw new TypeError("The listener must be a function");
      var h = new s(l, d || u, f), p = n ? n + c : c;
      return u._events[p] ? u._events[p].fn ? u._events[p] = [u._events[p], h] : u._events[p].push(h) : (u._events[p] = h, u._eventsCount++), u;
    }
    function a(u, c) {
      --u._eventsCount === 0 ? u._events = new r() : delete u._events[c];
    }
    function o() {
      this._events = new r(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var c = [], l, d;
      if (this._eventsCount === 0) return c;
      for (d in l = this._events)
        t.call(l, d) && c.push(n ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(l)) : c;
    }, o.prototype.listeners = function(c) {
      var l = n ? n + c : c, d = this._events[l];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, p = new Array(h); f < h; f++)
        p[f] = d[f].fn;
      return p;
    }, o.prototype.listenerCount = function(c) {
      var l = n ? n + c : c, d = this._events[l];
      return d ? d.fn ? 1 : d.length : 0;
    }, o.prototype.emit = function(c, l, d, f, h, p) {
      var g = n ? n + c : c;
      if (!this._events[g]) return !1;
      var m = this._events[g], _ = arguments.length, y, b;
      if (m.fn) {
        switch (m.once && this.removeListener(c, m.fn, void 0, !0), _) {
          case 1:
            return m.fn.call(m.context), !0;
          case 2:
            return m.fn.call(m.context, l), !0;
          case 3:
            return m.fn.call(m.context, l, d), !0;
          case 4:
            return m.fn.call(m.context, l, d, f), !0;
          case 5:
            return m.fn.call(m.context, l, d, f, h), !0;
          case 6:
            return m.fn.call(m.context, l, d, f, h, p), !0;
        }
        for (b = 1, y = new Array(_ - 1); b < _; b++)
          y[b - 1] = arguments[b];
        m.fn.apply(m.context, y);
      } else {
        var T = m.length, x;
        for (b = 0; b < T; b++)
          switch (m[b].once && this.removeListener(c, m[b].fn, void 0, !0), _) {
            case 1:
              m[b].fn.call(m[b].context);
              break;
            case 2:
              m[b].fn.call(m[b].context, l);
              break;
            case 3:
              m[b].fn.call(m[b].context, l, d);
              break;
            case 4:
              m[b].fn.call(m[b].context, l, d, f);
              break;
            default:
              if (!y) for (x = 1, y = new Array(_ - 1); x < _; x++)
                y[x - 1] = arguments[x];
              m[b].fn.apply(m[b].context, y);
          }
      }
      return !0;
    }, o.prototype.on = function(c, l, d) {
      return i(this, c, l, d, !1);
    }, o.prototype.once = function(c, l, d) {
      return i(this, c, l, d, !0);
    }, o.prototype.removeListener = function(c, l, d, f) {
      var h = n ? n + c : c;
      if (!this._events[h]) return this;
      if (!l)
        return a(this, h), this;
      var p = this._events[h];
      if (p.fn)
        p.fn === l && (!f || p.once) && (!d || p.context === d) && a(this, h);
      else {
        for (var g = 0, m = [], _ = p.length; g < _; g++)
          (p[g].fn !== l || f && !p[g].once || d && p[g].context !== d) && m.push(p[g]);
        m.length ? this._events[h] = m.length === 1 ? m[0] : m : a(this, h);
      }
      return this;
    }, o.prototype.removeAllListeners = function(c) {
      var l;
      return c ? (l = n ? n + c : c, this._events[l] && a(this, l)) : (this._events = new r(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, e.exports = o;
  })(tf)), tf.exports;
}
var ea = { exports: {} }, nf, zy;
function z$() {
  return zy || (zy = 1, nf = (e, t) => (t = t || (() => {
  }), e.then(
    (n) => new Promise((r) => {
      r(t());
    }).then(() => n),
    (n) => new Promise((r) => {
      r(t());
    }).then(() => {
      throw n;
    })
  ))), nf;
}
var qy;
function q$() {
  if (qy) return ea.exports;
  qy = 1;
  const e = z$();
  class t extends Error {
    constructor(s) {
      super(s), this.name = "TimeoutError";
    }
  }
  const n = (r, s, i) => new Promise((a, o) => {
    if (typeof s != "number" || s < 0)
      throw new TypeError("Expected `milliseconds` to be a positive number");
    if (s === 1 / 0) {
      a(r);
      return;
    }
    const u = setTimeout(() => {
      if (typeof i == "function") {
        try {
          a(i());
        } catch (d) {
          o(d);
        }
        return;
      }
      const c = typeof i == "string" ? i : `Promise timed out after ${s} milliseconds`, l = i instanceof Error ? i : new t(c);
      typeof r.cancel == "function" && r.cancel(), o(l);
    }, s);
    e(
      // eslint-disable-next-line promise/prefer-await-to-then
      r.then(a, o),
      () => {
        clearTimeout(u);
      }
    );
  });
  return ea.exports = n, ea.exports.default = n, ea.exports.TimeoutError = t, ea.exports;
}
var yu = {}, wu = {}, By;
function B$() {
  if (By) return wu;
  By = 1, Object.defineProperty(wu, "__esModule", { value: !0 });
  function e(t, n, r) {
    let s = 0, i = t.length;
    for (; i > 0; ) {
      const a = i / 2 | 0;
      let o = s + a;
      r(t[o], n) <= 0 ? (s = ++o, i -= a + 1) : i = a;
    }
    return s;
  }
  return wu.default = e, wu;
}
var Zy;
function Z$() {
  if (Zy) return yu;
  Zy = 1, Object.defineProperty(yu, "__esModule", { value: !0 });
  const e = B$();
  class t {
    constructor() {
      this._queue = [];
    }
    enqueue(r, s) {
      s = Object.assign({ priority: 0 }, s);
      const i = {
        priority: s.priority,
        run: r
      };
      if (this.size && this._queue[this.size - 1].priority >= s.priority) {
        this._queue.push(i);
        return;
      }
      const a = e.default(this._queue, i, (o, u) => u.priority - o.priority);
      this._queue.splice(a, 0, i);
    }
    dequeue() {
      const r = this._queue.shift();
      return r?.run;
    }
    filter(r) {
      return this._queue.filter((s) => s.priority === r.priority).map((s) => s.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  return yu.default = t, yu;
}
var Vy;
function V$() {
  if (Vy) return _u;
  Vy = 1, Object.defineProperty(_u, "__esModule", { value: !0 });
  const e = F$(), t = q$(), n = Z$(), r = () => {
  }, s = new t.TimeoutError();
  class i extends e {
    constructor(o) {
      var u, c, l, d;
      if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = r, this._resolveIdle = r, o = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: n.default }, o), !(typeof o.intervalCap == "number" && o.intervalCap >= 1))
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(c = (u = o.intervalCap) === null || u === void 0 ? void 0 : u.toString()) !== null && c !== void 0 ? c : ""}\` (${typeof o.intervalCap})`);
      if (o.interval === void 0 || !(Number.isFinite(o.interval) && o.interval >= 0))
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(d = (l = o.interval) === null || l === void 0 ? void 0 : l.toString()) !== null && d !== void 0 ? d : ""}\` (${typeof o.interval})`);
      this._carryoverConcurrencyCount = o.carryoverConcurrencyCount, this._isIntervalIgnored = o.intervalCap === 1 / 0 || o.interval === 0, this._intervalCap = o.intervalCap, this._interval = o.interval, this._queue = new o.queueClass(), this._queueClass = o.queueClass, this.concurrency = o.concurrency, this._timeout = o.timeout, this._throwOnTimeout = o.throwOnTimeout === !0, this._isPaused = o.autoStart === !1;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--, this._tryToStartAnother(), this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty(), this._resolveEmpty = r, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = r, this.emit("idle"));
    }
    _onResumeInterval() {
      this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const o = Date.now();
      if (this._intervalId === void 0) {
        const u = this._intervalEnd - o;
        if (u < 0)
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        else
          return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, u)), !0;
      }
      return !1;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0)
        return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
      if (!this._isPaused) {
        const o = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const u = this._queue.dequeue();
          return u ? (this.emit("active"), u(), o && this._initializeIntervalIfNeeded(), !0) : !1;
        }
      }
      return !1;
    }
    _initializeIntervalIfNeeded() {
      this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval), this._intervalEnd = Date.now() + this._interval);
    }
    _onInterval() {
      this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue() {
      for (; this._tryToStartAnother(); )
        ;
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(o) {
      if (!(typeof o == "number" && o >= 1))
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${o}\` (${typeof o})`);
      this._concurrency = o, this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    async add(o, u = {}) {
      return new Promise((c, l) => {
        const d = async () => {
          this._pendingCount++, this._intervalCount++;
          try {
            const f = this._timeout === void 0 && u.timeout === void 0 ? o() : t.default(Promise.resolve(o()), u.timeout === void 0 ? this._timeout : u.timeout, () => {
              (u.throwOnTimeout === void 0 ? this._throwOnTimeout : u.throwOnTimeout) && l(s);
            });
            c(await f);
          } catch (f) {
            l(f);
          }
          this._next();
        };
        this._queue.enqueue(d, u), this._tryToStartAnother(), this.emit("add");
      });
    }
    /**
    	    Same as `.add()`, but accepts an array of sync or async functions.
    
    	    @returns A promise that resolves when all functions are resolved.
    	    */
    async addAll(o, u) {
      return Promise.all(o.map(async (c) => this.add(c, u)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this._isPaused = !0;
    }
    /**
    Clear the queue.
    */
    clear() {
      this._queue = new this._queueClass();
    }
    /**
    	    Can be called multiple times. Useful if you for example add additional items at a later time.
    
    	    @returns A promise that settles when the queue becomes empty.
    	    */
    async onEmpty() {
      if (this._queue.size !== 0)
        return new Promise((o) => {
          const u = this._resolveEmpty;
          this._resolveEmpty = () => {
            u(), o();
          };
        });
    }
    /**
    	    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
    	    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    	    */
    async onIdle() {
      if (!(this._pendingCount === 0 && this._queue.size === 0))
        return new Promise((o) => {
          const u = this._resolveIdle;
          this._resolveIdle = () => {
            u(), o();
          };
        });
    }
    /**
    Size of the queue.
    */
    get size() {
      return this._queue.size;
    }
    /**
    	    Size of the queue, filtered by the given options.
    
    	    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    	    */
    sizeBy(o) {
      return this._queue.filter(o).length;
    }
    /**
    Number of pending promises.
    */
    get pending() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    set timeout(o) {
      this._timeout = o;
    }
  }
  return _u.default = i, _u;
}
var H$ = V$();
const cr = /* @__PURE__ */ Zr(H$), G$ = [
  408,
  // Request Timeout
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
let Hy = class {
  constructor(t) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxRetries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxQueueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "queueSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.maxConcurrency = t.maxConcurrency ?? 1 / 0, this.maxRetries = t.maxRetries ?? 6, this.maxQueueSizeBytes = t.maxQueueSizeBytes, "default" in cr ? this.queue = new cr.default({
      concurrency: this.maxConcurrency
    }) : this.queue = new cr({ concurrency: this.maxConcurrency }), this.onFailedResponseHook = t?.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(t, ...n) {
    return this.callWithOptions({}, t, ...n);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(t, n, ...r) {
    const s = t.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && s > 0 && this.queueSizeBytes + s > this.maxQueueSizeBytes)
      return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${s} bytes.`));
    s > 0 && (this.queueSizeBytes += s);
    const i = this.onFailedResponseHook;
    let a = this.queue.add(() => U$(() => n(...r).catch((o) => {
      throw o instanceof Error ? o : new Error(o);
    }), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async onFailedAttempt({ error: o }) {
        if (o.message.startsWith("Cancel") || o.message.startsWith("TimeoutError") || o.name === "TimeoutError" || o.message.startsWith("AbortError") || o?.code === "ECONNABORTED")
          throw o;
        const u = o?.response;
        if (i && await i(u))
          return;
        const c = u?.status ?? o?.status;
        if (c && !G$.includes(+c))
          throw o;
      },
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
    return s > 0 && (a = a.finally(() => {
      this.queueSizeBytes -= s;
    })), t.signal ? Promise.race([
      a,
      new Promise((o, u) => {
        t.signal?.addEventListener("abort", () => {
          u(new Error("AbortError"));
        });
      })
    ]) : a;
  }
};
function Gy(e) {
  return typeof e?._getType == "function";
}
function Wy(e) {
  const t = {
    type: e._getType(),
    data: { content: e.content }
  };
  return e?.additional_kwargs && Object.keys(e.additional_kwargs).length > 0 && (t.data.additional_kwargs = { ...e.additional_kwargs }), t;
}
var vu = { exports: {} }, rf, Jy;
function xl() {
  if (Jy) return rf;
  Jy = 1;
  const e = "2.0.0", t = 256, n = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, r = 16, s = t - 6;
  return rf = {
    MAX_LENGTH: t,
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: s,
    MAX_SAFE_INTEGER: n,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: e,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, rf;
}
var sf, Ky;
function El() {
  return Ky || (Ky = 1, sf = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
  }), sf;
}
var Yy;
function Lo() {
  return Yy || (Yy = 1, (function(e, t) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: r,
      MAX_LENGTH: s
    } = xl(), i = El();
    t = e.exports = {};
    const a = t.re = [], o = t.safeRe = [], u = t.src = [], c = t.safeSrc = [], l = t.t = {};
    let d = 0;
    const f = "[a-zA-Z0-9-]", h = [
      ["\\s", 1],
      ["\\d", s],
      [f, r]
    ], p = (m) => {
      for (const [_, y] of h)
        m = m.split(`${_}*`).join(`${_}{0,${y}}`).split(`${_}+`).join(`${_}{1,${y}}`);
      return m;
    }, g = (m, _, y) => {
      const b = p(_), T = d++;
      i(m, T, _), l[m] = T, u[T] = _, c[T] = b, a[T] = new RegExp(_, y ? "g" : void 0), o[T] = new RegExp(b, y ? "g" : void 0);
    };
    g("NUMERICIDENTIFIER", "0|[1-9]\\d*"), g("NUMERICIDENTIFIERLOOSE", "\\d+"), g("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), g("MAINVERSION", `(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})`), g("MAINVERSIONLOOSE", `(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})`), g("PRERELEASEIDENTIFIER", `(?:${u[l.NONNUMERICIDENTIFIER]}|${u[l.NUMERICIDENTIFIER]})`), g("PRERELEASEIDENTIFIERLOOSE", `(?:${u[l.NONNUMERICIDENTIFIER]}|${u[l.NUMERICIDENTIFIERLOOSE]})`), g("PRERELEASE", `(?:-(${u[l.PRERELEASEIDENTIFIER]}(?:\\.${u[l.PRERELEASEIDENTIFIER]})*))`), g("PRERELEASELOOSE", `(?:-?(${u[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[l.PRERELEASEIDENTIFIERLOOSE]})*))`), g("BUILDIDENTIFIER", `${f}+`), g("BUILD", `(?:\\+(${u[l.BUILDIDENTIFIER]}(?:\\.${u[l.BUILDIDENTIFIER]})*))`), g("FULLPLAIN", `v?${u[l.MAINVERSION]}${u[l.PRERELEASE]}?${u[l.BUILD]}?`), g("FULL", `^${u[l.FULLPLAIN]}$`), g("LOOSEPLAIN", `[v=\\s]*${u[l.MAINVERSIONLOOSE]}${u[l.PRERELEASELOOSE]}?${u[l.BUILD]}?`), g("LOOSE", `^${u[l.LOOSEPLAIN]}$`), g("GTLT", "((?:<|>)?=?)"), g("XRANGEIDENTIFIERLOOSE", `${u[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), g("XRANGEIDENTIFIER", `${u[l.NUMERICIDENTIFIER]}|x|X|\\*`), g("XRANGEPLAIN", `[v=\\s]*(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:${u[l.PRERELEASE]})?${u[l.BUILD]}?)?)?`), g("XRANGEPLAINLOOSE", `[v=\\s]*(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:${u[l.PRERELEASELOOSE]})?${u[l.BUILD]}?)?)?`), g("XRANGE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAIN]}$`), g("XRANGELOOSE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAINLOOSE]}$`), g("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), g("COERCE", `${u[l.COERCEPLAIN]}(?:$|[^\\d])`), g("COERCEFULL", u[l.COERCEPLAIN] + `(?:${u[l.PRERELEASE]})?(?:${u[l.BUILD]})?(?:$|[^\\d])`), g("COERCERTL", u[l.COERCE], !0), g("COERCERTLFULL", u[l.COERCEFULL], !0), g("LONETILDE", "(?:~>?)"), g("TILDETRIM", `(\\s*)${u[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", g("TILDE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAIN]}$`), g("TILDELOOSE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAINLOOSE]}$`), g("LONECARET", "(?:\\^)"), g("CARETTRIM", `(\\s*)${u[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", g("CARET", `^${u[l.LONECARET]}${u[l.XRANGEPLAIN]}$`), g("CARETLOOSE", `^${u[l.LONECARET]}${u[l.XRANGEPLAINLOOSE]}$`), g("COMPARATORLOOSE", `^${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]})$|^$`), g("COMPARATOR", `^${u[l.GTLT]}\\s*(${u[l.FULLPLAIN]})$|^$`), g("COMPARATORTRIM", `(\\s*)${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]}|${u[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", g("HYPHENRANGE", `^\\s*(${u[l.XRANGEPLAIN]})\\s+-\\s+(${u[l.XRANGEPLAIN]})\\s*$`), g("HYPHENRANGELOOSE", `^\\s*(${u[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[l.XRANGEPLAINLOOSE]})\\s*$`), g("STAR", "(<|>)?=?\\s*\\*"), g("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), g("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(vu, vu.exports)), vu.exports;
}
var af, Xy;
function km() {
  if (Xy) return af;
  Xy = 1;
  const e = Object.freeze({ loose: !0 }), t = Object.freeze({});
  return af = (r) => r ? typeof r != "object" ? e : r : t, af;
}
var of, Qy;
function rx() {
  if (Qy) return of;
  Qy = 1;
  const e = /^[0-9]+$/, t = (r, s) => {
    if (typeof r == "number" && typeof s == "number")
      return r === s ? 0 : r < s ? -1 : 1;
    const i = e.test(r), a = e.test(s);
    return i && a && (r = +r, s = +s), r === s ? 0 : i && !a ? -1 : a && !i ? 1 : r < s ? -1 : 1;
  };
  return of = {
    compareIdentifiers: t,
    rcompareIdentifiers: (r, s) => t(s, r)
  }, of;
}
var uf, ew;
function Lt() {
  if (ew) return uf;
  ew = 1;
  const e = El(), { MAX_LENGTH: t, MAX_SAFE_INTEGER: n } = xl(), { safeRe: r, t: s } = Lo(), i = km(), { compareIdentifiers: a } = rx();
  class o {
    constructor(c, l) {
      if (l = i(l), c instanceof o) {
        if (c.loose === !!l.loose && c.includePrerelease === !!l.includePrerelease)
          return c;
        c = c.version;
      } else if (typeof c != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof c}".`);
      if (c.length > t)
        throw new TypeError(
          `version is longer than ${t} characters`
        );
      e("SemVer", c, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      const d = c.trim().match(l.loose ? r[s.LOOSE] : r[s.FULL]);
      if (!d)
        throw new TypeError(`Invalid Version: ${c}`);
      if (this.raw = c, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > n || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > n || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > n || this.patch < 0)
        throw new TypeError("Invalid patch version");
      d[4] ? this.prerelease = d[4].split(".").map((f) => {
        if (/^[0-9]+$/.test(f)) {
          const h = +f;
          if (h >= 0 && h < n)
            return h;
        }
        return f;
      }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(c) {
      if (e("SemVer.compare", this.version, this.options, c), !(c instanceof o)) {
        if (typeof c == "string" && c === this.version)
          return 0;
        c = new o(c, this.options);
      }
      return c.version === this.version ? 0 : this.compareMain(c) || this.comparePre(c);
    }
    compareMain(c) {
      return c instanceof o || (c = new o(c, this.options)), this.major < c.major ? -1 : this.major > c.major ? 1 : this.minor < c.minor ? -1 : this.minor > c.minor ? 1 : this.patch < c.patch ? -1 : this.patch > c.patch ? 1 : 0;
    }
    comparePre(c) {
      if (c instanceof o || (c = new o(c, this.options)), this.prerelease.length && !c.prerelease.length)
        return -1;
      if (!this.prerelease.length && c.prerelease.length)
        return 1;
      if (!this.prerelease.length && !c.prerelease.length)
        return 0;
      let l = 0;
      do {
        const d = this.prerelease[l], f = c.prerelease[l];
        if (e("prerelease compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return a(d, f);
      } while (++l);
    }
    compareBuild(c) {
      c instanceof o || (c = new o(c, this.options));
      let l = 0;
      do {
        const d = this.build[l], f = c.build[l];
        if (e("build compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return a(d, f);
      } while (++l);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(c, l, d) {
      if (c.startsWith("pre")) {
        if (!l && d === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (l) {
          const f = `-${l}`.match(this.options.loose ? r[s.PRERELEASELOOSE] : r[s.PRERELEASE]);
          if (!f || f[1] !== l)
            throw new Error(`invalid identifier: ${l}`);
        }
      }
      switch (c) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l, d);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l, d);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const f = Number(d) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [f];
          else {
            let h = this.prerelease.length;
            for (; --h >= 0; )
              typeof this.prerelease[h] == "number" && (this.prerelease[h]++, h = -2);
            if (h === -1) {
              if (l === this.prerelease.join(".") && d === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(f);
            }
          }
          if (l) {
            let h = [l, f];
            d === !1 && (h = [l]), a(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = h) : this.prerelease = h;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${c}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return uf = o, uf;
}
var cf, tw;
function gi() {
  if (tw) return cf;
  tw = 1;
  const e = Lt();
  return cf = (n, r, s = !1) => {
    if (n instanceof e)
      return n;
    try {
      return new e(n, r);
    } catch (i) {
      if (!s)
        return null;
      throw i;
    }
  }, cf;
}
var lf, nw;
function W$() {
  if (nw) return lf;
  nw = 1;
  const e = gi();
  return lf = (n, r) => {
    const s = e(n, r);
    return s ? s.version : null;
  }, lf;
}
var df, rw;
function J$() {
  if (rw) return df;
  rw = 1;
  const e = gi();
  return df = (n, r) => {
    const s = e(n.trim().replace(/^[=v]+/, ""), r);
    return s ? s.version : null;
  }, df;
}
var ff, sw;
function K$() {
  if (sw) return ff;
  sw = 1;
  const e = Lt();
  return ff = (n, r, s, i, a) => {
    typeof s == "string" && (a = i, i = s, s = void 0);
    try {
      return new e(
        n instanceof e ? n.version : n,
        s
      ).inc(r, i, a).version;
    } catch {
      return null;
    }
  }, ff;
}
var hf, iw;
function Y$() {
  if (iw) return hf;
  iw = 1;
  const e = gi();
  return hf = (n, r) => {
    const s = e(n, null, !0), i = e(r, null, !0), a = s.compare(i);
    if (a === 0)
      return null;
    const o = a > 0, u = o ? s : i, c = o ? i : s, l = !!u.prerelease.length;
    if (!!c.prerelease.length && !l) {
      if (!c.patch && !c.minor)
        return "major";
      if (c.compareMain(u) === 0)
        return c.minor && !c.patch ? "minor" : "patch";
    }
    const f = l ? "pre" : "";
    return s.major !== i.major ? f + "major" : s.minor !== i.minor ? f + "minor" : s.patch !== i.patch ? f + "patch" : "prerelease";
  }, hf;
}
var pf, aw;
function X$() {
  if (aw) return pf;
  aw = 1;
  const e = Lt();
  return pf = (n, r) => new e(n, r).major, pf;
}
var mf, ow;
function Q$() {
  if (ow) return mf;
  ow = 1;
  const e = Lt();
  return mf = (n, r) => new e(n, r).minor, mf;
}
var gf, uw;
function eR() {
  if (uw) return gf;
  uw = 1;
  const e = Lt();
  return gf = (n, r) => new e(n, r).patch, gf;
}
var _f, cw;
function tR() {
  if (cw) return _f;
  cw = 1;
  const e = gi();
  return _f = (n, r) => {
    const s = e(n, r);
    return s && s.prerelease.length ? s.prerelease : null;
  }, _f;
}
var yf, lw;
function Un() {
  if (lw) return yf;
  lw = 1;
  const e = Lt();
  return yf = (n, r, s) => new e(n, s).compare(new e(r, s)), yf;
}
var wf, dw;
function nR() {
  if (dw) return wf;
  dw = 1;
  const e = Un();
  return wf = (n, r, s) => e(r, n, s), wf;
}
var vf, fw;
function rR() {
  if (fw) return vf;
  fw = 1;
  const e = Un();
  return vf = (n, r) => e(n, r, !0), vf;
}
var bf, hw;
function Om() {
  if (hw) return bf;
  hw = 1;
  const e = Lt();
  return bf = (n, r, s) => {
    const i = new e(n, s), a = new e(r, s);
    return i.compare(a) || i.compareBuild(a);
  }, bf;
}
var Sf, pw;
function sR() {
  if (pw) return Sf;
  pw = 1;
  const e = Om();
  return Sf = (n, r) => n.sort((s, i) => e(s, i, r)), Sf;
}
var Tf, mw;
function iR() {
  if (mw) return Tf;
  mw = 1;
  const e = Om();
  return Tf = (n, r) => n.sort((s, i) => e(i, s, r)), Tf;
}
var xf, gw;
function kl() {
  if (gw) return xf;
  gw = 1;
  const e = Un();
  return xf = (n, r, s) => e(n, r, s) > 0, xf;
}
var Ef, _w;
function Im() {
  if (_w) return Ef;
  _w = 1;
  const e = Un();
  return Ef = (n, r, s) => e(n, r, s) < 0, Ef;
}
var kf, yw;
function sx() {
  if (yw) return kf;
  yw = 1;
  const e = Un();
  return kf = (n, r, s) => e(n, r, s) === 0, kf;
}
var Of, ww;
function ix() {
  if (ww) return Of;
  ww = 1;
  const e = Un();
  return Of = (n, r, s) => e(n, r, s) !== 0, Of;
}
var If, vw;
function Am() {
  if (vw) return If;
  vw = 1;
  const e = Un();
  return If = (n, r, s) => e(n, r, s) >= 0, If;
}
var Af, bw;
function Cm() {
  if (bw) return Af;
  bw = 1;
  const e = Un();
  return Af = (n, r, s) => e(n, r, s) <= 0, Af;
}
var Cf, Sw;
function ax() {
  if (Sw) return Cf;
  Sw = 1;
  const e = sx(), t = ix(), n = kl(), r = Am(), s = Im(), i = Cm();
  return Cf = (o, u, c, l) => {
    switch (u) {
      case "===":
        return typeof o == "object" && (o = o.version), typeof c == "object" && (c = c.version), o === c;
      case "!==":
        return typeof o == "object" && (o = o.version), typeof c == "object" && (c = c.version), o !== c;
      case "":
      case "=":
      case "==":
        return e(o, c, l);
      case "!=":
        return t(o, c, l);
      case ">":
        return n(o, c, l);
      case ">=":
        return r(o, c, l);
      case "<":
        return s(o, c, l);
      case "<=":
        return i(o, c, l);
      default:
        throw new TypeError(`Invalid operator: ${u}`);
    }
  }, Cf;
}
var $f, Tw;
function aR() {
  if (Tw) return $f;
  Tw = 1;
  const e = Lt(), t = gi(), { safeRe: n, t: r } = Lo();
  return $f = (i, a) => {
    if (i instanceof e)
      return i;
    if (typeof i == "number" && (i = String(i)), typeof i != "string")
      return null;
    a = a || {};
    let o = null;
    if (!a.rtl)
      o = i.match(a.includePrerelease ? n[r.COERCEFULL] : n[r.COERCE]);
    else {
      const h = a.includePrerelease ? n[r.COERCERTLFULL] : n[r.COERCERTL];
      let p;
      for (; (p = h.exec(i)) && (!o || o.index + o[0].length !== i.length); )
        (!o || p.index + p[0].length !== o.index + o[0].length) && (o = p), h.lastIndex = p.index + p[1].length + p[2].length;
      h.lastIndex = -1;
    }
    if (o === null)
      return null;
    const u = o[2], c = o[3] || "0", l = o[4] || "0", d = a.includePrerelease && o[5] ? `-${o[5]}` : "", f = a.includePrerelease && o[6] ? `+${o[6]}` : "";
    return t(`${u}.${c}.${l}${d}${f}`, a);
  }, $f;
}
var Rf, xw;
function oR() {
  if (xw) return Rf;
  xw = 1;
  class e {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(n) {
      const r = this.map.get(n);
      if (r !== void 0)
        return this.map.delete(n), this.map.set(n, r), r;
    }
    delete(n) {
      return this.map.delete(n);
    }
    set(n, r) {
      if (!this.delete(n) && r !== void 0) {
        if (this.map.size >= this.max) {
          const i = this.map.keys().next().value;
          this.delete(i);
        }
        this.map.set(n, r);
      }
      return this;
    }
  }
  return Rf = e, Rf;
}
var Pf, Ew;
function Fn() {
  if (Ew) return Pf;
  Ew = 1;
  const e = /\s+/g;
  class t {
    constructor(N, L) {
      if (L = s(L), N instanceof t)
        return N.loose === !!L.loose && N.includePrerelease === !!L.includePrerelease ? N : new t(N.raw, L);
      if (N instanceof i)
        return this.raw = N.value, this.set = [[N]], this.formatted = void 0, this;
      if (this.options = L, this.loose = !!L.loose, this.includePrerelease = !!L.includePrerelease, this.raw = N.trim().replace(e, " "), this.set = this.raw.split("||").map((Z) => this.parseRange(Z.trim())).filter((Z) => Z.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Z = this.set[0];
        if (this.set = this.set.filter((ee) => !g(ee[0])), this.set.length === 0)
          this.set = [Z];
        else if (this.set.length > 1) {
          for (const ee of this.set)
            if (ee.length === 1 && m(ee[0])) {
              this.set = [ee];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let N = 0; N < this.set.length; N++) {
          N > 0 && (this.formatted += "||");
          const L = this.set[N];
          for (let Z = 0; Z < L.length; Z++)
            Z > 0 && (this.formatted += " "), this.formatted += L[Z].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(N) {
      const Z = ((this.options.includePrerelease && h) | (this.options.loose && p)) + ":" + N, ee = r.get(Z);
      if (ee)
        return ee;
      const q = this.options.loose, ie = q ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
      N = N.replace(ie, He(this.options.includePrerelease)), a("hyphen replace", N), N = N.replace(u[c.COMPARATORTRIM], l), a("comparator trim", N), N = N.replace(u[c.TILDETRIM], d), a("tilde trim", N), N = N.replace(u[c.CARETTRIM], f), a("caret trim", N);
      let Te = N.split(" ").map((z) => y(z, this.options)).join(" ").split(/\s+/).map((z) => G(z, this.options));
      q && (Te = Te.filter((z) => (a("loose invalid filter", z, this.options), !!z.match(u[c.COMPARATORLOOSE])))), a("range list", Te);
      const me = /* @__PURE__ */ new Map(), Re = Te.map((z) => new i(z, this.options));
      for (const z of Re) {
        if (g(z))
          return [z];
        me.set(z.value, z);
      }
      me.size > 1 && me.has("") && me.delete("");
      const Be = [...me.values()];
      return r.set(Z, Be), Be;
    }
    intersects(N, L) {
      if (!(N instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((Z) => _(Z, L) && N.set.some((ee) => _(ee, L) && Z.every((q) => ee.every((ie) => q.intersects(ie, L)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(N) {
      if (!N)
        return !1;
      if (typeof N == "string")
        try {
          N = new o(N, this.options);
        } catch {
          return !1;
        }
      for (let L = 0; L < this.set.length; L++)
        if (yt(this.set[L], N, this.options))
          return !0;
      return !1;
    }
  }
  Pf = t;
  const n = oR(), r = new n(), s = km(), i = Ol(), a = El(), o = Lt(), {
    safeRe: u,
    t: c,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: f
  } = Lo(), { FLAG_INCLUDE_PRERELEASE: h, FLAG_LOOSE: p } = xl(), g = (D) => D.value === "<0.0.0-0", m = (D) => D.value === "", _ = (D, N) => {
    let L = !0;
    const Z = D.slice();
    let ee = Z.pop();
    for (; L && Z.length; )
      L = Z.every((q) => ee.intersects(q, N)), ee = Z.pop();
    return L;
  }, y = (D, N) => (D = D.replace(u[c.BUILD], ""), a("comp", D, N), D = k(D, N), a("caret", D), D = T(D, N), a("tildes", D), D = S(D, N), a("xrange", D), D = U(D, N), a("stars", D), D), b = (D) => !D || D.toLowerCase() === "x" || D === "*", T = (D, N) => D.trim().split(/\s+/).map((L) => x(L, N)).join(" "), x = (D, N) => {
    const L = N.loose ? u[c.TILDELOOSE] : u[c.TILDE];
    return D.replace(L, (Z, ee, q, ie, Te) => {
      a("tilde", D, Z, ee, q, ie, Te);
      let me;
      return b(ee) ? me = "" : b(q) ? me = `>=${ee}.0.0 <${+ee + 1}.0.0-0` : b(ie) ? me = `>=${ee}.${q}.0 <${ee}.${+q + 1}.0-0` : Te ? (a("replaceTilde pr", Te), me = `>=${ee}.${q}.${ie}-${Te} <${ee}.${+q + 1}.0-0`) : me = `>=${ee}.${q}.${ie} <${ee}.${+q + 1}.0-0`, a("tilde return", me), me;
    });
  }, k = (D, N) => D.trim().split(/\s+/).map((L) => O(L, N)).join(" "), O = (D, N) => {
    a("caret", D, N);
    const L = N.loose ? u[c.CARETLOOSE] : u[c.CARET], Z = N.includePrerelease ? "-0" : "";
    return D.replace(L, (ee, q, ie, Te, me) => {
      a("caret", D, ee, q, ie, Te, me);
      let Re;
      return b(q) ? Re = "" : b(ie) ? Re = `>=${q}.0.0${Z} <${+q + 1}.0.0-0` : b(Te) ? q === "0" ? Re = `>=${q}.${ie}.0${Z} <${q}.${+ie + 1}.0-0` : Re = `>=${q}.${ie}.0${Z} <${+q + 1}.0.0-0` : me ? (a("replaceCaret pr", me), q === "0" ? ie === "0" ? Re = `>=${q}.${ie}.${Te}-${me} <${q}.${ie}.${+Te + 1}-0` : Re = `>=${q}.${ie}.${Te}-${me} <${q}.${+ie + 1}.0-0` : Re = `>=${q}.${ie}.${Te}-${me} <${+q + 1}.0.0-0`) : (a("no pr"), q === "0" ? ie === "0" ? Re = `>=${q}.${ie}.${Te}${Z} <${q}.${ie}.${+Te + 1}-0` : Re = `>=${q}.${ie}.${Te}${Z} <${q}.${+ie + 1}.0-0` : Re = `>=${q}.${ie}.${Te} <${+q + 1}.0.0-0`), a("caret return", Re), Re;
    });
  }, S = (D, N) => (a("replaceXRanges", D, N), D.split(/\s+/).map((L) => j(L, N)).join(" ")), j = (D, N) => {
    D = D.trim();
    const L = N.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
    return D.replace(L, (Z, ee, q, ie, Te, me) => {
      a("xRange", D, Z, ee, q, ie, Te, me);
      const Re = b(q), Be = Re || b(ie), z = Be || b(Te), v = z;
      return ee === "=" && v && (ee = ""), me = N.includePrerelease ? "-0" : "", Re ? ee === ">" || ee === "<" ? Z = "<0.0.0-0" : Z = "*" : ee && v ? (Be && (ie = 0), Te = 0, ee === ">" ? (ee = ">=", Be ? (q = +q + 1, ie = 0, Te = 0) : (ie = +ie + 1, Te = 0)) : ee === "<=" && (ee = "<", Be ? q = +q + 1 : ie = +ie + 1), ee === "<" && (me = "-0"), Z = `${ee + q}.${ie}.${Te}${me}`) : Be ? Z = `>=${q}.0.0${me} <${+q + 1}.0.0-0` : z && (Z = `>=${q}.${ie}.0${me} <${q}.${+ie + 1}.0-0`), a("xRange return", Z), Z;
    });
  }, U = (D, N) => (a("replaceStars", D, N), D.trim().replace(u[c.STAR], "")), G = (D, N) => (a("replaceGTE0", D, N), D.trim().replace(u[N.includePrerelease ? c.GTE0PRE : c.GTE0], "")), He = (D) => (N, L, Z, ee, q, ie, Te, me, Re, Be, z, v) => (b(Z) ? L = "" : b(ee) ? L = `>=${Z}.0.0${D ? "-0" : ""}` : b(q) ? L = `>=${Z}.${ee}.0${D ? "-0" : ""}` : ie ? L = `>=${L}` : L = `>=${L}${D ? "-0" : ""}`, b(Re) ? me = "" : b(Be) ? me = `<${+Re + 1}.0.0-0` : b(z) ? me = `<${Re}.${+Be + 1}.0-0` : v ? me = `<=${Re}.${Be}.${z}-${v}` : D ? me = `<${Re}.${Be}.${+z + 1}-0` : me = `<=${me}`, `${L} ${me}`.trim()), yt = (D, N, L) => {
    for (let Z = 0; Z < D.length; Z++)
      if (!D[Z].test(N))
        return !1;
    if (N.prerelease.length && !L.includePrerelease) {
      for (let Z = 0; Z < D.length; Z++)
        if (a(D[Z].semver), D[Z].semver !== i.ANY && D[Z].semver.prerelease.length > 0) {
          const ee = D[Z].semver;
          if (ee.major === N.major && ee.minor === N.minor && ee.patch === N.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Pf;
}
var Nf, kw;
function Ol() {
  if (kw) return Nf;
  kw = 1;
  const e = /* @__PURE__ */ Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, d) {
      if (d = n(d), l instanceof t) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), a("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, a("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? r[s.COMPARATORLOOSE] : r[s.COMPARATOR], f = l.match(d);
      if (!f)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = f[1] !== void 0 ? f[1] : "", this.operator === "=" && (this.operator = ""), f[2] ? this.semver = new o(f[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (a("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new o(l, this.options);
        } catch {
          return !1;
        }
      return i(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new u(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new u(this.value, d).test(l.semver) : (d = n(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || i(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || i(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  Nf = t;
  const n = km(), { safeRe: r, t: s } = Lo(), i = ax(), a = El(), o = Lt(), u = Fn();
  return Nf;
}
var Mf, Ow;
function Il() {
  if (Ow) return Mf;
  Ow = 1;
  const e = Fn();
  return Mf = (n, r, s) => {
    try {
      r = new e(r, s);
    } catch {
      return !1;
    }
    return r.test(n);
  }, Mf;
}
var jf, Iw;
function uR() {
  if (Iw) return jf;
  Iw = 1;
  const e = Fn();
  return jf = (n, r) => new e(n, r).set.map((s) => s.map((i) => i.value).join(" ").trim().split(" ")), jf;
}
var Lf, Aw;
function cR() {
  if (Aw) return Lf;
  Aw = 1;
  const e = Lt(), t = Fn();
  return Lf = (r, s, i) => {
    let a = null, o = null, u = null;
    try {
      u = new t(s, i);
    } catch {
      return null;
    }
    return r.forEach((c) => {
      u.test(c) && (!a || o.compare(c) === -1) && (a = c, o = new e(a, i));
    }), a;
  }, Lf;
}
var Df, Cw;
function lR() {
  if (Cw) return Df;
  Cw = 1;
  const e = Lt(), t = Fn();
  return Df = (r, s, i) => {
    let a = null, o = null, u = null;
    try {
      u = new t(s, i);
    } catch {
      return null;
    }
    return r.forEach((c) => {
      u.test(c) && (!a || o.compare(c) === 1) && (a = c, o = new e(a, i));
    }), a;
  }, Df;
}
var Uf, $w;
function dR() {
  if ($w) return Uf;
  $w = 1;
  const e = Lt(), t = Fn(), n = kl();
  return Uf = (s, i) => {
    s = new t(s, i);
    let a = new e("0.0.0");
    if (s.test(a) || (a = new e("0.0.0-0"), s.test(a)))
      return a;
    a = null;
    for (let o = 0; o < s.set.length; ++o) {
      const u = s.set[o];
      let c = null;
      u.forEach((l) => {
        const d = new e(l.semver.version);
        switch (l.operator) {
          case ">":
            d.prerelease.length === 0 ? d.patch++ : d.prerelease.push(0), d.raw = d.format();
          /* fallthrough */
          case "":
          case ">=":
            (!c || n(d, c)) && (c = d);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${l.operator}`);
        }
      }), c && (!a || n(a, c)) && (a = c);
    }
    return a && s.test(a) ? a : null;
  }, Uf;
}
var Ff, Rw;
function fR() {
  if (Rw) return Ff;
  Rw = 1;
  const e = Fn();
  return Ff = (n, r) => {
    try {
      return new e(n, r).range || "*";
    } catch {
      return null;
    }
  }, Ff;
}
var zf, Pw;
function $m() {
  if (Pw) return zf;
  Pw = 1;
  const e = Lt(), t = Ol(), { ANY: n } = t, r = Fn(), s = Il(), i = kl(), a = Im(), o = Cm(), u = Am();
  return zf = (l, d, f, h) => {
    l = new e(l, h), d = new r(d, h);
    let p, g, m, _, y;
    switch (f) {
      case ">":
        p = i, g = o, m = a, _ = ">", y = ">=";
        break;
      case "<":
        p = a, g = u, m = i, _ = "<", y = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (s(l, d, h))
      return !1;
    for (let b = 0; b < d.set.length; ++b) {
      const T = d.set[b];
      let x = null, k = null;
      if (T.forEach((O) => {
        O.semver === n && (O = new t(">=0.0.0")), x = x || O, k = k || O, p(O.semver, x.semver, h) ? x = O : m(O.semver, k.semver, h) && (k = O);
      }), x.operator === _ || x.operator === y || (!k.operator || k.operator === _) && g(l, k.semver))
        return !1;
      if (k.operator === y && m(l, k.semver))
        return !1;
    }
    return !0;
  }, zf;
}
var qf, Nw;
function hR() {
  if (Nw) return qf;
  Nw = 1;
  const e = $m();
  return qf = (n, r, s) => e(n, r, ">", s), qf;
}
var Bf, Mw;
function pR() {
  if (Mw) return Bf;
  Mw = 1;
  const e = $m();
  return Bf = (n, r, s) => e(n, r, "<", s), Bf;
}
var Zf, jw;
function mR() {
  if (jw) return Zf;
  jw = 1;
  const e = Fn();
  return Zf = (n, r, s) => (n = new e(n, s), r = new e(r, s), n.intersects(r, s)), Zf;
}
var Vf, Lw;
function gR() {
  if (Lw) return Vf;
  Lw = 1;
  const e = Il(), t = Un();
  return Vf = (n, r, s) => {
    const i = [];
    let a = null, o = null;
    const u = n.sort((f, h) => t(f, h, s));
    for (const f of u)
      e(f, r, s) ? (o = f, a || (a = f)) : (o && i.push([a, o]), o = null, a = null);
    a && i.push([a, null]);
    const c = [];
    for (const [f, h] of i)
      f === h ? c.push(f) : !h && f === u[0] ? c.push("*") : h ? f === u[0] ? c.push(`<=${h}`) : c.push(`${f} - ${h}`) : c.push(`>=${f}`);
    const l = c.join(" || "), d = typeof r.raw == "string" ? r.raw : String(r);
    return l.length < d.length ? l : r;
  }, Vf;
}
var Hf, Dw;
function _R() {
  if (Dw) return Hf;
  Dw = 1;
  const e = Fn(), t = Ol(), { ANY: n } = t, r = Il(), s = Un(), i = (d, f, h = {}) => {
    if (d === f)
      return !0;
    d = new e(d, h), f = new e(f, h);
    let p = !1;
    e: for (const g of d.set) {
      for (const m of f.set) {
        const _ = u(g, m, h);
        if (p = p || _ !== null, _)
          continue e;
      }
      if (p)
        return !1;
    }
    return !0;
  }, a = [new t(">=0.0.0-0")], o = [new t(">=0.0.0")], u = (d, f, h) => {
    if (d === f)
      return !0;
    if (d.length === 1 && d[0].semver === n) {
      if (f.length === 1 && f[0].semver === n)
        return !0;
      h.includePrerelease ? d = a : d = o;
    }
    if (f.length === 1 && f[0].semver === n) {
      if (h.includePrerelease)
        return !0;
      f = o;
    }
    const p = /* @__PURE__ */ new Set();
    let g, m;
    for (const S of d)
      S.operator === ">" || S.operator === ">=" ? g = c(g, S, h) : S.operator === "<" || S.operator === "<=" ? m = l(m, S, h) : p.add(S.semver);
    if (p.size > 1)
      return null;
    let _;
    if (g && m) {
      if (_ = s(g.semver, m.semver, h), _ > 0)
        return null;
      if (_ === 0 && (g.operator !== ">=" || m.operator !== "<="))
        return null;
    }
    for (const S of p) {
      if (g && !r(S, String(g), h) || m && !r(S, String(m), h))
        return null;
      for (const j of f)
        if (!r(S, String(j), h))
          return !1;
      return !0;
    }
    let y, b, T, x, k = m && !h.includePrerelease && m.semver.prerelease.length ? m.semver : !1, O = g && !h.includePrerelease && g.semver.prerelease.length ? g.semver : !1;
    k && k.prerelease.length === 1 && m.operator === "<" && k.prerelease[0] === 0 && (k = !1);
    for (const S of f) {
      if (x = x || S.operator === ">" || S.operator === ">=", T = T || S.operator === "<" || S.operator === "<=", g) {
        if (O && S.semver.prerelease && S.semver.prerelease.length && S.semver.major === O.major && S.semver.minor === O.minor && S.semver.patch === O.patch && (O = !1), S.operator === ">" || S.operator === ">=") {
          if (y = c(g, S, h), y === S && y !== g)
            return !1;
        } else if (g.operator === ">=" && !r(g.semver, String(S), h))
          return !1;
      }
      if (m) {
        if (k && S.semver.prerelease && S.semver.prerelease.length && S.semver.major === k.major && S.semver.minor === k.minor && S.semver.patch === k.patch && (k = !1), S.operator === "<" || S.operator === "<=") {
          if (b = l(m, S, h), b === S && b !== m)
            return !1;
        } else if (m.operator === "<=" && !r(m.semver, String(S), h))
          return !1;
      }
      if (!S.operator && (m || g) && _ !== 0)
        return !1;
    }
    return !(g && T && !m && _ !== 0 || m && x && !g && _ !== 0 || O || k);
  }, c = (d, f, h) => {
    if (!d)
      return f;
    const p = s(d.semver, f.semver, h);
    return p > 0 ? d : p < 0 || f.operator === ">" && d.operator === ">=" ? f : d;
  }, l = (d, f, h) => {
    if (!d)
      return f;
    const p = s(d.semver, f.semver, h);
    return p < 0 ? d : p > 0 || f.operator === "<" && d.operator === "<=" ? f : d;
  };
  return Hf = i, Hf;
}
var Gf, Uw;
function yR() {
  if (Uw) return Gf;
  Uw = 1;
  const e = Lo(), t = xl(), n = Lt(), r = rx(), s = gi(), i = W$(), a = J$(), o = K$(), u = Y$(), c = X$(), l = Q$(), d = eR(), f = tR(), h = Un(), p = nR(), g = rR(), m = Om(), _ = sR(), y = iR(), b = kl(), T = Im(), x = sx(), k = ix(), O = Am(), S = Cm(), j = ax(), U = aR(), G = Ol(), He = Fn(), yt = Il(), D = uR(), N = cR(), L = lR(), Z = dR(), ee = fR(), q = $m(), ie = hR(), Te = pR(), me = mR(), Re = gR(), Be = _R();
  return Gf = {
    parse: s,
    valid: i,
    clean: a,
    inc: o,
    diff: u,
    major: c,
    minor: l,
    patch: d,
    prerelease: f,
    compare: h,
    rcompare: p,
    compareLoose: g,
    compareBuild: m,
    sort: _,
    rsort: y,
    gt: b,
    lt: T,
    eq: x,
    neq: k,
    gte: O,
    lte: S,
    cmp: j,
    coerce: U,
    Comparator: G,
    Range: He,
    satisfies: yt,
    toComparators: D,
    maxSatisfying: N,
    minSatisfying: L,
    minVersion: Z,
    validRange: ee,
    outside: q,
    gtr: ie,
    ltr: Te,
    intersects: me,
    simplifyRange: Re,
    subset: Be,
    SemVer: n,
    re: e.re,
    src: e.src,
    tokens: e.t,
    SEMVER_SPEC_VERSION: t.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: t.RELEASE_TYPES,
    compareIdentifiers: r.compareIdentifiers,
    rcompareIdentifiers: r.rcompareIdentifiers
  }, Gf;
}
yR();
function Tr(e) {
  if (!e || e.split("/").length > 2 || e.startsWith("/") || e.endsWith("/") || e.split(":").length > 2)
    throw new Error(`Invalid identifier format: ${e}`);
  const [t, n] = e.split(":"), r = n || "latest";
  if (t.includes("/")) {
    const [s, i] = t.split("/", 2);
    if (!s || !i)
      throw new Error(`Invalid identifier format: ${e}`);
    return [s, i, r];
  } else {
    if (!t)
      throw new Error(`Invalid identifier format: ${e}`);
    return ["-", t, r];
  }
}
class wR extends Error {
  constructor(t) {
    super(t), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "LangSmithConflictError", this.status = 409;
  }
}
class vR extends Error {
  constructor(t) {
    super(t), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "LangSmithNotFoundError", this.status = 404;
  }
}
function Fw(e) {
  return e != null && typeof e == "object" && "name" in e && e?.name === "LangSmithNotFoundError";
}
async function ne(e, t, n) {
  let r;
  if (e.ok) {
    n && (r = await e.text());
    return;
  }
  if (e.status === 403)
    try {
      (await e.json())?.error === "org_scoped_key_requires_workspace" && (r = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.");
    } catch {
      const o = new Error(`${e.status} ${e.statusText}`);
      throw o.status = e?.status, o;
    }
  if (r === void 0)
    try {
      r = await e.text();
    } catch {
      r = "";
    }
  const s = `Failed to ${t}. Received status [${e.status}]: ${e.statusText}. Message: ${r}`;
  if (e.status === 404)
    throw new vR(s);
  if (e.status === 409)
    throw new wR(s);
  const i = new Error(s);
  throw i.status = e.status, i;
}
const ox = "ERR_CONFLICTING_ENDPOINTS";
class bR extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS."), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ox
    }), this.name = "ConflictingEndpointsError";
  }
}
function SR(e) {
  return typeof e == "object" && e !== null && e.code === ox;
}
var zw = "[...]", TR = { result: "[Circular]" }, $c = [], Ys = [];
const xR = new TextEncoder();
function ER() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function bu(e) {
  return xR.encode(e);
}
function ux(e) {
  if (e && typeof e == "object" && e !== null) {
    if (e instanceof Map)
      return Object.fromEntries(e);
    if (e instanceof Set)
      return Array.from(e);
    if (e instanceof Date)
      return e.toISOString();
    if (e instanceof RegExp)
      return e.toString();
    if (e instanceof Error)
      return {
        name: e.name,
        message: e.message
      };
  } else if (typeof e == "bigint")
    return e.toString();
  return e;
}
function kR(e) {
  return function(t, n) {
    return ux(n);
  };
}
function tn(e, t, n, r, s) {
  try {
    const i = JSON.stringify(e, kR(n), r);
    return bu(i);
  } catch (i) {
    if (!i.message?.includes("Converting circular structure to JSON"))
      return console.warn(`[WARNING]: LangSmith received unserializable value.${t ? `
Context: ${t}` : ""}`), bu("[Unserializable]");
    Bt("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${t ? `
Context: ${t}` : ""}`), typeof s > "u" && (s = ER()), Vh(e, "", 0, [], void 0, 0, s);
    let a;
    try {
      Ys.length === 0 ? a = JSON.stringify(e, n, r) : a = JSON.stringify(e, OR(n), r);
    } catch {
      return bu("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; $c.length !== 0; ) {
        const o = $c.pop();
        o.length === 4 ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];
      }
    }
    return bu(a);
  }
}
function Wf(e, t, n, r) {
  var s = Object.getOwnPropertyDescriptor(r, n);
  s.get !== void 0 ? s.configurable ? (Object.defineProperty(r, n, { value: e }), $c.push([r, n, t, s])) : Ys.push([t, n, e]) : (r[n] = e, $c.push([r, n, t]));
}
function Vh(e, t, n, r, s, i, a) {
  i += 1;
  var o;
  if (typeof e == "object" && e !== null) {
    for (o = 0; o < r.length; o++)
      if (r[o] === e) {
        Wf(TR, e, t, s);
        return;
      }
    if (typeof a.depthLimit < "u" && i > a.depthLimit) {
      Wf(zw, e, t, s);
      return;
    }
    if (typeof a.edgesLimit < "u" && n + 1 > a.edgesLimit) {
      Wf(zw, e, t, s);
      return;
    }
    if (r.push(e), Array.isArray(e))
      for (o = 0; o < e.length; o++)
        Vh(e[o], o, o, r, e, i, a);
    else {
      e = ux(e);
      var u = Object.keys(e);
      for (o = 0; o < u.length; o++) {
        var c = u[o];
        Vh(e[c], c, o, r, e, i, a);
      }
    }
    r.pop();
  }
}
function OR(e) {
  return e = typeof e < "u" ? e : function(t, n) {
    return n;
  }, function(t, n) {
    if (Ys.length > 0)
      for (var r = 0; r < Ys.length; r++) {
        var s = Ys[r];
        if (s[1] === t && s[0] === n) {
          n = s[2], Ys.splice(r, 1);
          break;
        }
      }
    return e.call(this, t, n);
  };
}
function qw(e, t, n) {
  if (n)
    return e;
  const r = QT(), s = t ?? ex(), i = e.extra ?? {}, a = i.metadata;
  return e.extra = {
    ...i,
    runtime: {
      ...r,
      ...i?.runtime
    },
    metadata: {
      ...s,
      ...s.revision_id || "revision_id" in e && e.revision_id ? {
        revision_id: ("revision_id" in e ? e.revision_id : void 0) ?? s.revision_id
      } : {},
      ...a
    }
  }, e;
}
const IR = (e) => {
  const t = e?.toString() ?? Bt("TRACING_SAMPLING_RATE");
  if (t === void 0)
    return;
  const n = parseFloat(t);
  if (n < 0 || n > 1)
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${n}`);
  return n;
}, AR = (e) => {
  const n = e.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return n === "localhost" || n === "127.0.0.1" || n === "::1";
};
async function CR(e) {
  const t = [];
  for await (const n of e)
    t.push(n);
  return t;
}
function Su(e) {
  if (e !== void 0)
    return e.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
const $R = async (e) => {
  if (e?.status === 429) {
    const t = parseInt(e.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (t > 0)
      return await new Promise((n) => setTimeout(n, t)), !0;
  }
  return !1;
};
function Bw(e) {
  return typeof e == "number" ? Number(e.toFixed(4)) : e;
}
const RR = 24 * 1024 * 1024, cx = 1024 * 1024 * 1024, PR = 1e4, NR = 100, Zw = "https://api.smith.langchain.com";
class MR {
  constructor(t) {
    Object.defineProperty(this, "items", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "sizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "maxSizeBytes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSizeBytes = t ?? cx;
  }
  peek() {
    return this.items[0];
  }
  push(t) {
    let n;
    const r = new Promise((i) => {
      n = i;
    }), s = tn(t.item, `Serializing run with id: ${t.item.id}`).length;
    return this.sizeBytes + s > this.maxSizeBytes && this.items.length > 0 ? (console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${t.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${s} bytes.`), n(), r) : (this.items.push({
      action: t.action,
      payload: t.item,
      otelContext: t.otelContext,
      apiKey: t.apiKey,
      apiUrl: t.apiUrl,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve: n,
      itemPromise: r,
      size: s
    }), this.sizeBytes += s, r);
  }
  pop({ upToSizeBytes: t, upToSize: n }) {
    if (t < 1)
      throw new Error("Number of bytes to pop off may not be less than 1.");
    const r = [];
    let s = 0;
    for (; s + (this.peek()?.size ?? 0) < t && this.items.length > 0 && r.length < n; ) {
      const i = this.items.shift();
      i && (r.push(i), s += i.size, this.sizeBytes -= i.size);
    }
    if (r.length === 0 && this.items.length > 0) {
      const i = this.items.shift();
      r.push(i), s += i.size, this.sizeBytes -= i.size;
    }
    return [
      r.map((i) => ({
        action: i.action,
        item: i.payload,
        otelContext: i.otelContext,
        apiKey: i.apiKey,
        apiUrl: i.apiUrl,
        size: i.size
      })),
      () => r.forEach((i) => i.itemPromiseResolve())
    ];
  }
}
class fo {
  get _fetch() {
    return this.fetchImplementation || o$(this.debug);
  }
  constructor(t = {}) {
    Object.defineProperty(this, "apiKey", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "apiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "webUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "workspaceId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "caller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchIngestCaller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timeout_ms", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tenantId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "hideInputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "hideOutputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "omitTracedRuntimeInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingSampleRate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "filteredPostUuids", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "autoBatchTracing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "autoBatchQueue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 250
    }), Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "batchSizeLimit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Yn("LANGSMITH_TRACING_BACKGROUND") === "false"
    }), Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 5
    }), Object.defineProperty(this, "_serverInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "manualFlushMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fetchImplementation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_cache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "multipartStreamingDisabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_multipartDisabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "debug", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Yn("LANGSMITH_DEBUG") === "true"
    });
    const n = fo.getDefaultClientConfig();
    if (this.tracingSampleRate = IR(t.tracingSamplingRate), this.apiUrl = Su(t.apiUrl ?? n.apiUrl) ?? "", this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)), this.apiKey = Su(t.apiKey ?? n.apiKey), this.webUrl = Su(t.webUrl ?? n.webUrl), this.webUrl?.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)), this.workspaceId = Su(t.workspaceId ?? Bt("WORKSPACE_ID")), this.timeout_ms = t.timeout_ms ?? 9e4, this.caller = new Hy({
      ...t.callerOptions ?? {},
      maxRetries: 4,
      debug: t.debug ?? this.debug
    }), this.traceBatchConcurrency = t.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1)
      throw new Error("Trace batch concurrency must be positive.");
    this.debug = t.debug ?? this.debug, this.fetchImplementation = t.fetchImplementation;
    const r = t.maxIngestMemoryBytes ?? cx;
    this.batchIngestCaller = new Hy({
      maxRetries: 4,
      maxConcurrency: this.traceBatchConcurrency,
      maxQueueSizeBytes: r,
      ...t.callerOptions ?? {},
      onFailedResponseHook: $R,
      debug: t.debug ?? this.debug
    }), this.hideInputs = t.hideInputs ?? t.anonymizer ?? n.hideInputs, this.hideOutputs = t.hideOutputs ?? t.anonymizer ?? n.hideOutputs, this.omitTracedRuntimeInfo = t.omitTracedRuntimeInfo ?? !1, this.autoBatchTracing = t.autoBatchTracing ?? this.autoBatchTracing, this.autoBatchQueue = new MR(r), this.blockOnRootRunFinalization = t.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = t.batchSizeBytesLimit, this.batchSizeLimit = t.batchSizeLimit, this.fetchOptions = t.fetchOptions || {}, this.manualFlushMode = t.manualFlushMode ?? this.manualFlushMode, tx() && (this.langSmithToOTELTranslator = new C$()), this.cachedLSEnvVarsForMetadata = ex(), t.cache === !0 ? this._cache = new h$() : t.cache && typeof t.cache == "object" ? this._cache = t.cache : this._cache = void 0;
  }
  static getDefaultClientConfig() {
    const t = Bt("API_KEY"), n = Bt("ENDPOINT") ?? Zw, r = Bt("HIDE_INPUTS") === "true", s = Bt("HIDE_OUTPUTS") === "true";
    return {
      apiUrl: n,
      apiKey: t,
      webUrl: void 0,
      hideInputs: r,
      hideOutputs: s
    };
  }
  getHostUrl() {
    return this.webUrl ? this.webUrl : AR(this.apiUrl) ? (this.webUrl = "http://localhost:3000", this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com", this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com", this.webUrl) : (this.webUrl = "https://smith.langchain.com", this.webUrl);
  }
  get headers() {
    const t = {
      "User-Agent": `langsmith-js/${KT}`
    };
    return this.apiKey && (t["x-api-key"] = `${this.apiKey}`), this.workspaceId && (t["x-tenant-id"] = this.workspaceId), t;
  }
  _getPlatformEndpointPath(t) {
    return this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/" ? `/v1/platform/${t}` : `/platform/${t}`;
  }
  async processInputs(t) {
    return this.hideInputs === !1 ? t : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(t) : t;
  }
  async processOutputs(t) {
    return this.hideOutputs === !1 ? t : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(t) : t;
  }
  async prepareRunCreateOrUpdateInputs(t) {
    const n = { ...t };
    return n.inputs !== void 0 && (n.inputs = await this.processInputs(n.inputs)), n.outputs !== void 0 && (n.outputs = await this.processOutputs(n.outputs)), n;
  }
  async _getResponse(t, n) {
    const r = n?.toString() ?? "", s = `${this.apiUrl}${t}?${r}`;
    return await this.caller.call(async () => {
      const a = await this._fetch(s, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(a, `fetch ${t}`), a;
    });
  }
  async _get(t, n) {
    return (await this._getResponse(t, n)).json();
  }
  async *_getPaginated(t, n = new URLSearchParams(), r) {
    let s = Number(n.get("offset")) || 0;
    const i = Number(n.get("limit")) || 100;
    for (; ; ) {
      n.set("offset", String(s)), n.set("limit", String(i));
      const a = `${this.apiUrl}${t}?${n}`, o = await this.caller.call(async () => {
        const c = await this._fetch(a, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await ne(c, `fetch ${t}`), c;
      }), u = r ? r(await o.json()) : await o.json();
      if (u.length === 0 || (yield u, u.length < i))
        break;
      s += u.length;
    }
  }
  async *_getCursorPaginatedList(t, n = null, r = "POST", s = "runs") {
    const i = n ? { ...n } : {};
    for (; ; ) {
      const a = JSON.stringify(i), u = await (await this.caller.call(async () => {
        const l = await this._fetch(`${this.apiUrl}${t}`, {
          method: r,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: a
        });
        return await ne(l, `fetch ${t}`), l;
      })).json();
      if (!u || !u[s])
        break;
      yield u[s];
      const c = u.cursors;
      if (!c || !c.next)
        break;
      i.cursor = c.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    return this.tracingSampleRate === void 0 ? !0 : Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(t, n = !1) {
    if (this.tracingSampleRate === void 0)
      return t;
    if (n) {
      const r = [];
      for (const s of t)
        this.filteredPostUuids.has(s.trace_id) ? s.id === s.trace_id && this.filteredPostUuids.delete(s.trace_id) : r.push(s);
      return r;
    } else {
      const r = [];
      for (const s of t) {
        const i = s.trace_id ?? s.id;
        this.filteredPostUuids.has(i) || (s.id === i ? this._shouldSample() ? r.push(s) : this.filteredPostUuids.add(i) : r.push(s));
      }
      return r;
    }
  }
  async _getBatchSizeLimitBytes() {
    const t = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? t?.batch_ingest_config?.size_limit_bytes ?? RR;
  }
  /**
   * Get the maximum number of operations to batch in a single request.
   */
  async _getBatchSizeLimit() {
    const t = await this._ensureServerInfo();
    return this.batchSizeLimit ?? t?.batch_ingest_config?.size_limit ?? NR;
  }
  async _getDatasetExamplesMultiPartSupport() {
    return (await this._ensureServerInfo()).instance_flags?.dataset_examples_multipart_enabled ?? !1;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes: t, batchSizeLimit: n }) {
    const r = [];
    for (; this.autoBatchQueue.items.length > 0; ) {
      const [s, i] = this.autoBatchQueue.pop({
        upToSizeBytes: t,
        upToSize: n
      });
      if (!s.length) {
        i();
        break;
      }
      const a = s.reduce((c, l) => {
        const d = l.apiUrl ?? this.apiUrl, f = l.apiKey ?? this.apiKey, p = l.apiKey === this.apiKey && l.apiUrl === this.apiUrl ? "default" : `${d}|${f}`;
        return c[p] || (c[p] = []), c[p].push(l), c;
      }, {}), o = [];
      for (const [c, l] of Object.entries(a)) {
        const d = this._processBatch(l, {
          apiUrl: c === "default" ? void 0 : c.split("|")[0],
          apiKey: c === "default" ? void 0 : c.split("|")[1]
        });
        o.push(d);
      }
      const u = Promise.all(o).finally(i);
      r.push(u);
    }
    return Promise.all(r);
  }
  async _processBatch(t, n) {
    if (!t.length)
      return;
    const r = t.reduce((s, i) => s + (i.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0)
        this._sendBatchToOTELTranslator(t);
      else {
        const s = {
          runCreates: t.filter((o) => o.action === "create").map((o) => o.item),
          runUpdates: t.filter((o) => o.action === "update").map((o) => o.item)
        }, i = await this._ensureServerInfo();
        if (!this._multipartDisabled && (i?.batch_ingest_config?.use_multipart_endpoint ?? !0)) {
          const o = i?.instance_flags?.gzip_body_enabled;
          try {
            await this.multipartIngestRuns(s, {
              ...n,
              useGzip: o,
              sizeBytes: r
            });
          } catch (u) {
            if (Fw(u))
              this._multipartDisabled = !0, await this.batchIngestRuns(s, {
                ...n,
                sizeBytes: r
              });
            else
              throw u;
          }
        } else
          await this.batchIngestRuns(s, {
            ...n,
            sizeBytes: r
          });
      }
    } catch (s) {
      console.error("Error exporting batch:", s);
    }
  }
  _sendBatchToOTELTranslator(t) {
    if (this.langSmithToOTELTranslator !== void 0) {
      const n = /* @__PURE__ */ new Map(), r = [];
      for (const s of t)
        s.item.id && s.otelContext && (n.set(s.item.id, s.otelContext), s.action === "create" ? r.push({
          operation: "post",
          id: s.item.id,
          trace_id: s.item.trace_id ?? s.item.id,
          run: s.item
        }) : r.push({
          operation: "patch",
          id: s.item.id,
          trace_id: s.item.trace_id ?? s.item.id,
          run: s.item
        }));
      this.langSmithToOTELTranslator.exportBatch(r, n);
    }
  }
  async processRunOperation(t) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, t.item = qw(t.item, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);
    const n = this.autoBatchQueue.push(t);
    if (this.manualFlushMode)
      return n;
    const r = await this._getBatchSizeLimitBytes(), s = await this._getBatchSizeLimit();
    return (this.autoBatchQueue.sizeBytes > r || this.autoBatchQueue.items.length > s) && this.drainAutoBatchQueue({
      batchSizeLimitBytes: r,
      batchSizeLimit: s
    }), this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue({
        batchSizeLimitBytes: r,
        batchSizeLimit: s
      });
    }, this.autoBatchAggregationDelayMs)), n;
  }
  async _getServerInfo() {
    const n = await (await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(PR),
        ...this.fetchOptions
      });
      return await ne(r, "get server info"), r;
    })).json();
    return this.debug && console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(n, null, 2) + `
`), n;
  }
  async _ensureServerInfo() {
    return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0)
        try {
          this._serverInfo = await this._getServerInfo();
        } catch (t) {
          console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${t.status ?? "Unspecified status code"} ${t.message}`);
        }
      return this._serverInfo ?? {};
    })()), this._getServerInfoPromise.then((t) => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0), t));
  }
  async _getSettings() {
    return this.settings || (this.settings = this._get("/settings")), await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const t = await this._getBatchSizeLimitBytes(), n = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({
      batchSizeLimitBytes: t,
      batchSizeLimit: n
    });
  }
  _cloneCurrentOTELContext() {
    const t = nx(), n = k$();
    if (this.langSmithToOTELTranslator !== void 0) {
      const r = t.getActiveSpan();
      if (r)
        return t.setSpan(n.active(), r);
    }
  }
  async createRun(t, n) {
    if (!this._filterForSampling([t]).length)
      return;
    const r = {
      ...this.headers,
      "Content-Type": "application/json"
    }, s = t.project_name;
    delete t.project_name;
    const i = await this.prepareRunCreateOrUpdateInputs({
      session_name: s,
      ...t,
      start_time: t.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && i.trace_id !== void 0 && i.dotted_order !== void 0) {
      const u = this._cloneCurrentOTELContext();
      this.processRunOperation({
        action: "create",
        item: i,
        otelContext: u,
        apiKey: n?.apiKey,
        apiUrl: n?.apiUrl
      }).catch(console.error);
      return;
    }
    const a = qw(i, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);
    n?.apiKey !== void 0 && (r["x-api-key"] = n.apiKey), n?.workspaceId !== void 0 && (r["x-tenant-id"] = n.workspaceId);
    const o = tn(a, `Creating run with id: ${a.id}`);
    await this.caller.call(async () => {
      const u = await this._fetch(`${n?.apiUrl ?? this.apiUrl}/runs`, {
        method: "POST",
        headers: r,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await ne(u, "create run", !0), u;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates: t, runUpdates: n }, r) {
    if (t === void 0 && n === void 0)
      return;
    let s = await Promise.all(t?.map((u) => this.prepareRunCreateOrUpdateInputs(u)) ?? []), i = await Promise.all(n?.map((u) => this.prepareRunCreateOrUpdateInputs(u)) ?? []);
    if (s.length > 0 && i.length > 0) {
      const u = s.reduce((l, d) => (d.id && (l[d.id] = d), l), {}), c = [];
      for (const l of i)
        l.id !== void 0 && u[l.id] ? u[l.id] = {
          ...u[l.id],
          ...l
        } : c.push(l);
      s = Object.values(u), i = c;
    }
    const a = {
      post: s,
      patch: i
    };
    if (!a.post.length && !a.patch.length)
      return;
    const o = {
      post: [],
      patch: []
    };
    for (const u of ["post", "patch"]) {
      const c = u, l = a[c].reverse();
      let d = l.pop();
      for (; d !== void 0; )
        o[c].push(d), d = l.pop();
    }
    if (o.post.length > 0 || o.patch.length > 0) {
      const u = o.post.map((c) => c.id).concat(o.patch.map((c) => c.id)).join(",");
      await this._postBatchIngestRuns(tn(o, `Ingesting runs with ids: ${u}`), r);
    }
  }
  async _postBatchIngestRuns(t, n) {
    const r = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    n?.apiKey !== void 0 && (r["x-api-key"] = n.apiKey), await this.batchIngestCaller.callWithOptions({ sizeBytes: n?.sizeBytes }, async () => {
      const s = await this._fetch(`${n?.apiUrl ?? this.apiUrl}/runs/batch`, {
        method: "POST",
        headers: r,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: t
      });
      return await ne(s, "batch create run", !0), s;
    });
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates: t, runUpdates: n }, r) {
    if (t === void 0 && n === void 0)
      return;
    const s = {};
    let i = [];
    for (const d of t ?? []) {
      const f = await this.prepareRunCreateOrUpdateInputs(d);
      f.id !== void 0 && f.attachments !== void 0 && (s[f.id] = f.attachments), delete f.attachments, i.push(f);
    }
    let a = [];
    for (const d of n ?? [])
      a.push(await this.prepareRunCreateOrUpdateInputs(d));
    if (i.find((d) => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (a.find((d) => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
      throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (i.length > 0 && a.length > 0) {
      const d = i.reduce((h, p) => (p.id && (h[p.id] = p), h), {}), f = [];
      for (const h of a)
        h.id !== void 0 && d[h.id] ? d[h.id] = {
          ...d[h.id],
          ...h
        } : f.push(h);
      i = Object.values(d), a = f;
    }
    if (i.length === 0 && a.length === 0)
      return;
    const c = [], l = [];
    for (const [d, f] of [
      ["post", i],
      ["patch", a]
    ])
      for (const h of f) {
        const { inputs: p, outputs: g, events: m, extra: _, error: y, serialized: b, attachments: T, ...x } = h, k = { inputs: p, outputs: g, events: m, extra: _, error: y, serialized: b }, O = tn(x, `Serializing for multipart ingestion of run with id: ${x.id}`);
        l.push({
          name: `${d}.${x.id}`,
          payload: new Blob([O], {
            type: `application/json; length=${O.length}`
            // encoding=gzip
          })
        });
        for (const [S, j] of Object.entries(k)) {
          if (j === void 0)
            continue;
          const U = tn(j, `Serializing ${S} for multipart ingestion of run with id: ${x.id}`);
          l.push({
            name: `${d}.${x.id}.${S}`,
            payload: new Blob([U], {
              type: `application/json; length=${U.length}`
            })
          });
        }
        if (x.id !== void 0) {
          const S = s[x.id];
          if (S) {
            delete s[x.id];
            for (const [j, U] of Object.entries(S)) {
              let G, He;
              if (Array.isArray(U) ? [G, He] = U : (G = U.mimeType, He = U.data), j.includes(".")) {
                console.warn(`Skipping attachment '${j}' for run ${x.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              l.push({
                name: `attachment.${x.id}.${j}`,
                payload: new Blob([He], {
                  type: `${G}; length=${He.byteLength}`
                })
              });
            }
          }
        }
        c.push(`trace=${x.trace_id},id=${x.id}`);
      }
    await this._sendMultipartRequest(l, c.join("; "), r);
  }
  async _createNodeFetchBody(t, n) {
    const r = [];
    for (const a of t)
      r.push(new Blob([`--${n}\r
`])), r.push(new Blob([
        `Content-Disposition: form-data; name="${a.name}"\r
`,
        `Content-Type: ${a.payload.type}\r
\r
`
      ])), r.push(a.payload), r.push(new Blob([`\r
`]));
    return r.push(new Blob([`--${n}--\r
`])), await new Blob(r).arrayBuffer();
  }
  async _createMultipartStream(t, n) {
    const r = new TextEncoder();
    return new ReadableStream({
      async start(i) {
        const a = async (o) => {
          typeof o == "string" ? i.enqueue(r.encode(o)) : i.enqueue(o);
        };
        for (const o of t) {
          await a(`--${n}\r
`), await a(`Content-Disposition: form-data; name="${o.name}"\r
`), await a(`Content-Type: ${o.payload.type}\r
\r
`);
          const c = o.payload.stream().getReader();
          try {
            let l;
            for (; !(l = await c.read()).done; )
              i.enqueue(l.value);
          } finally {
            c.releaseLock();
          }
          await a(`\r
`);
        }
        await a(`--${n}--\r
`), i.close();
      }
    });
  }
  async _sendMultipartRequest(t, n, r) {
    const s = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), i = a$(), a = () => this._createNodeFetchBody(t, s), o = () => this._createMultipartStream(t, s), u = async (c) => this.batchIngestCaller.callWithOptions({ sizeBytes: r?.sizeBytes }, async () => {
      const l = await c(), d = {
        ...this.headers,
        "Content-Type": `multipart/form-data; boundary=${s}`
      };
      r?.apiKey !== void 0 && (d["x-api-key"] = r.apiKey);
      let f = l;
      r?.useGzip && typeof l == "object" && "pipeThrough" in l && (f = l.pipeThrough(new CompressionStream("gzip")), d["Content-Encoding"] = "gzip");
      const h = await this._fetch(`${r?.apiUrl ?? this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: d,
        body: f,
        duplex: "half",
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(h, "Failed to send multipart request", !0), h;
    });
    try {
      let c, l = !1;
      !i && !this.multipartStreamingDisabled && XT() !== "bun" ? (l = !0, c = await u(o)) : c = await u(a), (!this.multipartStreamingDisabled || l) && c.status === 422 && (r?.apiUrl ?? this.apiUrl) !== Zw && (console.warn(`Streaming multipart upload to ${r?.apiUrl ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${n}".`), this.multipartStreamingDisabled = !0, c = await u(a));
    } catch (c) {
      if (Fw(c))
        throw c;
      console.warn(`${c.message.trim()}

Context: ${n}`);
    }
  }
  async updateRun(t, n, r) {
    ve(t), n.inputs && (n.inputs = await this.processInputs(n.inputs)), n.outputs && (n.outputs = await this.processOutputs(n.outputs));
    const s = { ...n, id: t };
    if (!this._filterForSampling([s], !0).length)
      return;
    if (this.autoBatchTracing && s.trace_id !== void 0 && s.dotted_order !== void 0) {
      const o = this._cloneCurrentOTELContext();
      if (n.end_time !== void 0 && s.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: s,
          otelContext: o,
          apiKey: r?.apiKey,
          apiUrl: r?.apiUrl
        }).catch(console.error);
        return;
      } else
        this.processRunOperation({
          action: "update",
          item: s,
          otelContext: o,
          apiKey: r?.apiKey,
          apiUrl: r?.apiUrl
        }).catch(console.error);
      return;
    }
    const i = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    r?.apiKey !== void 0 && (i["x-api-key"] = r.apiKey), r?.workspaceId !== void 0 && (i["x-tenant-id"] = r.workspaceId);
    const a = tn(n, `Serializing payload to update run with id: ${t}`);
    await this.caller.call(async () => {
      const o = await this._fetch(`${r?.apiUrl ?? this.apiUrl}/runs/${t}`, {
        method: "PATCH",
        headers: i,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(o, "update run", !0), o;
    });
  }
  async readRun(t, { loadChildRuns: n } = { loadChildRuns: !1 }) {
    ve(t);
    let r = await this._get(`/runs/${t}`);
    return n && (r = await this._loadChildRuns(r)), r;
  }
  async getRunUrl({ runId: t, run: n, projectOpts: r }) {
    if (n !== void 0) {
      let s;
      n.session_id ? s = n.session_id : r?.projectName ? s = (await this.readProject({ projectName: r?.projectName })).id : r?.projectId ? s = r?.projectId : s = (await this.readProject({
        projectName: Bt("PROJECT") || "default"
      })).id;
      const i = await this._getTenantId();
      return `${this.getHostUrl()}/o/${i}/projects/p/${s}/r/${n.id}?poll=true`;
    } else if (t !== void 0) {
      const s = await this.readRun(t);
      if (!s.app_path)
        throw new Error(`Run ${t} has no app_path`);
      return `${this.getHostUrl()}${s.app_path}`;
    } else
      throw new Error("Must provide either runId or run");
  }
  async _loadChildRuns(t) {
    const n = await CR(this.listRuns({
      isRoot: !1,
      projectId: t.session_id,
      traceId: t.trace_id
    })), r = {}, s = {};
    n.sort((i, a) => (i?.dotted_order ?? "").localeCompare(a?.dotted_order ?? ""));
    for (const i of n) {
      if (i.parent_run_id === null || i.parent_run_id === void 0)
        throw new Error(`Child run ${i.id} has no parent`);
      i.dotted_order?.startsWith(t.dotted_order ?? "") && i.id !== t.id && (i.parent_run_id in r || (r[i.parent_run_id] = []), r[i.parent_run_id].push(i), s[i.id] = i);
    }
    t.child_runs = r[t.id] || [];
    for (const i in r)
      i !== t.id && (s[i].child_runs = r[i]);
    return t;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(t) {
    const { projectId: n, projectName: r, parentRunId: s, traceId: i, referenceExampleId: a, startTime: o, executionOrder: u, isRoot: c, runType: l, error: d, id: f, query: h, filter: p, traceFilter: g, treeFilter: m, limit: _, select: y, order: b } = t;
    let T = [];
    if (n && (T = Array.isArray(n) ? n : [n]), r) {
      const S = Array.isArray(r) ? r : [r], j = await Promise.all(S.map((U) => this.readProject({ projectName: U }).then((G) => G.id)));
      T.push(...j);
    }
    const x = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ], k = {
      session: T.length ? T : null,
      run_type: l,
      reference_example: a,
      query: h,
      filter: p,
      trace_filter: g,
      tree_filter: m,
      execution_order: u,
      parent_run: s,
      start_time: o ? o.toISOString() : null,
      error: d,
      id: f,
      limit: _,
      trace: i,
      select: y || x,
      is_root: c,
      order: b
    };
    k.select.includes("child_run_ids") && JT("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    let O = 0;
    for await (const S of this._getCursorPaginatedList("/runs/query", k))
      if (_) {
        if (O >= _)
          break;
        if (S.length + O > _) {
          yield* S.slice(0, _ - O);
          break;
        }
        O += S.length, yield* S;
      } else
        yield* S;
  }
  async *listGroupRuns(t) {
    const { projectId: n, projectName: r, groupBy: s, filter: i, startTime: a, endTime: o, limit: u, offset: c } = t, d = {
      session_id: n || (await this.readProject({ projectName: r })).id,
      group_by: s,
      filter: i,
      start_time: a ? a.toISOString() : null,
      end_time: o ? o.toISOString() : null,
      limit: Number(u) || 100
    };
    let f = Number(c) || 0;
    const h = "/runs/group", p = `${this.apiUrl}${h}`;
    for (; ; ) {
      const g = {
        ...d,
        offset: f
      }, m = Object.fromEntries(Object.entries(g).filter(([k, O]) => O !== void 0)), _ = JSON.stringify(m), b = await (await this.caller.call(async () => {
        const k = await this._fetch(p, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: _
        });
        return await ne(k, `Failed to fetch ${h}`), k;
      })).json(), { groups: T, total: x } = b;
      if (T.length === 0)
        break;
      for (const k of T)
        yield k;
      if (f += T.length, f >= x)
        break;
    }
  }
  async getRunStats({ id: t, trace: n, parentRun: r, runType: s, projectNames: i, projectIds: a, referenceExampleIds: o, startTime: u, endTime: c, error: l, query: d, filter: f, traceFilter: h, treeFilter: p, isRoot: g, dataSourceType: m }) {
    let _ = a || [];
    i && (_ = [
      ...a || [],
      ...await Promise.all(i.map((O) => this.readProject({ projectName: O }).then((S) => S.id)))
    ]);
    const b = Object.fromEntries(Object.entries({
      id: t,
      trace: n,
      parent_run: r,
      run_type: s,
      session: _,
      reference_example: o,
      start_time: u,
      end_time: c,
      error: l,
      query: d,
      filter: f,
      trace_filter: h,
      tree_filter: p,
      is_root: g,
      data_source_type: m
    }).filter(([O, S]) => S !== void 0)), T = JSON.stringify(b);
    return await (await this.caller.call(async () => {
      const O = await this._fetch(`${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: T
      });
      return await ne(O, "get run stats"), O;
    })).json();
  }
  async shareRun(t, { shareId: n } = {}) {
    const r = {
      run_id: t,
      share_token: n || Qi()
    };
    ve(t);
    const s = JSON.stringify(r), a = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/runs/${t}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await ne(o, "share run"), o;
    })).json();
    if (a === null || !("share_token" in a))
      throw new Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${a.share_token}/r`;
  }
  async unshareRun(t) {
    ve(t), await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/runs/${t}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(n, "unshare run", !0), n;
    });
  }
  async readRunSharedLink(t) {
    ve(t);
    const r = await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/runs/${t}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(s, "read run shared link"), s;
    })).json();
    if (!(r === null || !("share_token" in r)))
      return `${this.getHostUrl()}/public/${r.share_token}/r`;
  }
  async listSharedRuns(t, { runIds: n } = {}) {
    const r = new URLSearchParams({
      share_token: t
    });
    if (n !== void 0)
      for (const a of n)
        r.append("id", a);
    return ve(t), await (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/public/${t}/runs${r}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(a, "list shared runs"), a;
    })).json();
  }
  async readDatasetSharedSchema(t, n) {
    if (!t && !n)
      throw new Error("Either datasetId or datasetName must be given");
    t || (t = (await this.readDataset({ datasetName: n })).id), ve(t);
    const s = await (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}/datasets/${t}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(i, "read dataset shared schema"), i;
    })).json();
    return s.url = `${this.getHostUrl()}/public/${s.share_token}/d`, s;
  }
  async shareDataset(t, n) {
    if (!t && !n)
      throw new Error("Either datasetId or datasetName must be given");
    t || (t = (await this.readDataset({ datasetName: n })).id);
    const r = {
      dataset_id: t
    };
    ve(t);
    const s = JSON.stringify(r), a = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/datasets/${t}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: s
      });
      return await ne(o, "share dataset"), o;
    })).json();
    return a.url = `${this.getHostUrl()}/public/${a.share_token}/d`, a;
  }
  async unshareDataset(t) {
    ve(t), await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/datasets/${t}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(n, "unshare dataset", !0), n;
    });
  }
  async readSharedDataset(t) {
    return ve(t), await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/public/${t}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(s, "read shared dataset"), s;
    })).json();
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(t, n) {
    const r = {};
    n?.exampleIds && (r.id = n.exampleIds);
    const s = new URLSearchParams();
    Object.entries(r).forEach(([o, u]) => {
      Array.isArray(u) ? u.forEach((c) => s.append(o, c)) : s.append(o, u);
    });
    const i = await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/public/${t}/examples?${s.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(o, "list shared examples"), o;
    }), a = await i.json();
    if (!i.ok)
      throw "detail" in a ? new Error(`Failed to list shared examples.
Status: ${i.status}
Message: ${Array.isArray(a.detail) ? a.detail.join(`
`) : "Unspecified error"}`) : new Error(`Failed to list shared examples: ${i.status} ${i.statusText}`);
    return a.map((o) => ({
      ...o,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName: t, description: n = null, metadata: r = null, upsert: s = !1, projectExtra: i = null, referenceDatasetId: a = null }) {
    const o = s ? "?upsert=true" : "", u = `${this.apiUrl}/sessions${o}`, c = i || {};
    r && (c.metadata = r);
    const l = {
      name: t,
      extra: c,
      description: n
    };
    a !== null && (l.reference_dataset_id = a);
    const d = JSON.stringify(l);
    return await (await this.caller.call(async () => {
      const p = await this._fetch(u, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: d
      });
      return await ne(p, "create project"), p;
    })).json();
  }
  async updateProject(t, { name: n = null, description: r = null, metadata: s = null, projectExtra: i = null, endTime: a = null }) {
    const o = `${this.apiUrl}/sessions/${t}`;
    let u = i;
    s && (u = { ...u || {}, metadata: s });
    const c = JSON.stringify({
      name: n,
      extra: u,
      description: r,
      end_time: a ? new Date(a).toISOString() : null
    });
    return await (await this.caller.call(async () => {
      const f = await this._fetch(o, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await ne(f, "update project"), f;
    })).json();
  }
  async hasProject({ projectId: t, projectName: n }) {
    let r = "/sessions";
    const s = new URLSearchParams();
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (t !== void 0)
      ve(t), r += `/${t}`;
    else if (n !== void 0)
      s.append("name", n);
    else
      throw new Error("Must provide projectName or projectId");
    const i = await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${r}?${s}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(a, "has project"), a;
    });
    try {
      const a = await i.json();
      return i.ok ? Array.isArray(a) ? a.length > 0 : !0 : !1;
    } catch {
      return !1;
    }
  }
  async readProject({ projectId: t, projectName: n, includeStats: r }) {
    let s = "/sessions";
    const i = new URLSearchParams();
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    if (t !== void 0)
      ve(t), s += `/${t}`;
    else if (n !== void 0)
      i.append("name", n);
    else
      throw new Error("Must provide projectName or projectId");
    r !== void 0 && i.append("include_stats", r.toString());
    const a = await this._get(s, i);
    let o;
    if (Array.isArray(a)) {
      if (a.length === 0)
        throw new Error(`Project[id=${t}, name=${n}] not found`);
      o = a[0];
    } else
      o = a;
    return o;
  }
  async getProjectUrl({ projectId: t, projectName: n }) {
    if (t === void 0 && n === void 0)
      throw new Error("Must provide either projectName or projectId");
    const r = await this.readProject({ projectId: t, projectName: n }), s = await this._getTenantId();
    return `${this.getHostUrl()}/o/${s}/projects/p/${r.id}`;
  }
  async getDatasetUrl({ datasetId: t, datasetName: n }) {
    if (t === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    const r = await this.readDataset({ datasetId: t, datasetName: n }), s = await this._getTenantId();
    return `${this.getHostUrl()}/o/${s}/datasets/${r.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null)
      return this._tenantId;
    const t = new URLSearchParams({ limit: "1" });
    for await (const n of this._getPaginated("/sessions", t))
      return this._tenantId = n[0].tenant_id, n[0].tenant_id;
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: t, name: n, nameContains: r, referenceDatasetId: s, referenceDatasetName: i, includeStats: a, datasetVersion: o, referenceFree: u, metadata: c } = {}) {
    const l = new URLSearchParams();
    if (t !== void 0)
      for (const d of t)
        l.append("id", d);
    if (n !== void 0 && l.append("name", n), r !== void 0 && l.append("name_contains", r), s !== void 0)
      l.append("reference_dataset", s);
    else if (i !== void 0) {
      const d = await this.readDataset({
        datasetName: i
      });
      l.append("reference_dataset", d.id);
    }
    a !== void 0 && l.append("include_stats", a.toString()), o !== void 0 && l.append("dataset_version", o), u !== void 0 && l.append("reference_free", u.toString()), c !== void 0 && l.append("metadata", JSON.stringify(c));
    for await (const d of this._getPaginated("/sessions", l))
      yield* d;
  }
  async deleteProject({ projectId: t, projectName: n }) {
    let r;
    if (t === void 0 && n === void 0)
      throw new Error("Must provide projectName or projectId");
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either projectName or projectId, not both");
    t === void 0 ? r = (await this.readProject({ projectName: n })).id : r = t, ve(r), await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/sessions/${r}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(s, `delete session ${r} (${n})`, !0), s;
    });
  }
  async uploadCsv({ csvFile: t, fileName: n, inputKeys: r, outputKeys: s, description: i, dataType: a, name: o }) {
    const u = `${this.apiUrl}/datasets/upload`, c = new FormData();
    return c.append("file", t, n), r.forEach((f) => {
      c.append("input_keys", f);
    }), s.forEach((f) => {
      c.append("output_keys", f);
    }), i && c.append("description", i), a && c.append("data_type", a), o && c.append("name", o), await (await this.caller.call(async () => {
      const f = await this._fetch(u, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await ne(f, "upload CSV"), f;
    })).json();
  }
  async createDataset(t, { description: n, dataType: r, inputsSchema: s, outputsSchema: i, metadata: a } = {}) {
    const o = {
      name: t,
      description: n,
      extra: a ? { metadata: a } : void 0
    };
    r && (o.data_type = r), s && (o.inputs_schema_definition = s), i && (o.outputs_schema_definition = i);
    const u = JSON.stringify(o);
    return await (await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await ne(d, "create dataset"), d;
    })).json();
  }
  async readDataset({ datasetId: t, datasetName: n }) {
    let r = "/datasets";
    const s = new URLSearchParams({ limit: "1" });
    if (t && n)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (t)
      ve(t), r += `/${t}`;
    else if (n)
      s.append("name", n);
    else
      throw new Error("Must provide datasetName or datasetId");
    const i = await this._get(r, s);
    let a;
    if (Array.isArray(i)) {
      if (i.length === 0)
        throw new Error(`Dataset[id=${t}, name=${n}] not found`);
      a = i[0];
    } else
      a = i;
    return a;
  }
  async hasDataset({ datasetId: t, datasetName: n }) {
    try {
      return await this.readDataset({ datasetId: t, datasetName: n }), !0;
    } catch (r) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        r instanceof Error && r.message.toLocaleLowerCase().includes("not found")
      )
        return !1;
      throw r;
    }
  }
  async diffDatasetVersions({ datasetId: t, datasetName: n, fromVersion: r, toVersion: s }) {
    let i = t;
    if (i === void 0 && n === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (i !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    i === void 0 && (i = (await this.readDataset({ datasetName: n })).id);
    const a = new URLSearchParams({
      from_version: typeof r == "string" ? r : r.toISOString(),
      to_version: typeof s == "string" ? s : s.toISOString()
    });
    return await this._get(`/datasets/${i}/versions/diff`, a);
  }
  async readDatasetOpenaiFinetuning({ datasetId: t, datasetName: n }) {
    const r = "/datasets";
    if (t === void 0) if (n !== void 0)
      t = (await this.readDataset({ datasetName: n })).id;
    else
      throw new Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`${r}/${t}/openai_ft`)).text()).trim().split(`
`).map((o) => JSON.parse(o));
  }
  async *listDatasets({ limit: t = 100, offset: n = 0, datasetIds: r, datasetName: s, datasetNameContains: i, metadata: a } = {}) {
    const o = "/datasets", u = new URLSearchParams({
      limit: t.toString(),
      offset: n.toString()
    });
    if (r !== void 0)
      for (const c of r)
        u.append("id", c);
    s !== void 0 && u.append("name", s), i !== void 0 && u.append("name_contains", i), a !== void 0 && u.append("metadata", JSON.stringify(a));
    for await (const c of this._getPaginated(o, u))
      yield* c;
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(t) {
    const { datasetId: n, datasetName: r, ...s } = t;
    if (!n && !r)
      throw new Error("Must provide either datasetName or datasetId");
    const i = n ?? (await this.readDataset({ datasetName: r })).id;
    ve(i);
    const a = JSON.stringify(s);
    return await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${i}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(u, "update dataset"), u;
    })).json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(t) {
    const { datasetId: n, datasetName: r, asOf: s, tag: i } = t;
    if (!n && !r)
      throw new Error("Must provide either datasetName or datasetId");
    const a = n ?? (await this.readDataset({ datasetName: r })).id;
    ve(a);
    const o = JSON.stringify({
      as_of: typeof s == "string" ? s : s.toISOString(),
      tag: i
    });
    await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${a}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await ne(u, "update dataset tags", !0), u;
    });
  }
  async deleteDataset({ datasetId: t, datasetName: n }) {
    let r = "/datasets", s = t;
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (n !== void 0 && (s = (await this.readDataset({ datasetName: n })).id), s !== void 0)
      ve(s), r += `/${s}`;
    else
      throw new Error("Must provide datasetName or datasetId");
    await this.caller.call(async () => {
      const i = await this._fetch(this.apiUrl + r, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(i, `delete ${r}`, !0), i;
    });
  }
  async indexDataset({ datasetId: t, datasetName: n, tag: r }) {
    let s = t;
    if (!s && !n)
      throw new Error("Must provide either datasetName or datasetId");
    if (s && n)
      throw new Error("Must provide either datasetName or datasetId, not both");
    s || (s = (await this.readDataset({ datasetName: n })).id), ve(s);
    const a = JSON.stringify({
      tag: r
    });
    await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${s}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(u, "index dataset"), u;
    })).json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(t, n, r, { filter: s } = {}) {
    const i = {
      limit: r,
      inputs: t
    };
    s !== void 0 && (i.filter = s), ve(n);
    const a = JSON.stringify(i);
    return (await (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${n}/search`, {
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        method: "POST",
        body: a
      });
      return await ne(c, "fetch similar examples"), c;
    })).json()).examples;
  }
  async createExample(t, n, r) {
    if (Vw(t) && (n !== void 0 || r !== void 0))
      throw new Error("Cannot provide outputs or options when using ExampleCreate object");
    let s = n ? r?.datasetId : t.dataset_id;
    const i = n ? r?.datasetName : t.dataset_name;
    if (s === void 0 && i === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (s !== void 0 && i !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    s === void 0 && (s = (await this.readDataset({ datasetName: i })).id);
    const a = (n ? r?.createdAt : t.created_at) || /* @__PURE__ */ new Date();
    let o;
    Vw(t) ? o = t : o = {
      inputs: t,
      outputs: n,
      created_at: a?.toISOString(),
      id: r?.exampleId,
      metadata: r?.metadata,
      split: r?.split,
      source_run_id: r?.sourceRunId,
      use_source_run_io: r?.useSourceRunIO,
      use_source_run_attachments: r?.useSourceRunAttachments,
      attachments: r?.attachments
    };
    const u = await this._uploadExamplesMultipart(s, [o]);
    return await this.readExample(u.example_ids?.[0] ?? Qi());
  }
  async createExamples(t) {
    if (Array.isArray(t)) {
      if (t.length === 0)
        return [];
      const y = t;
      let b = y[0].dataset_id;
      const T = y[0].dataset_name;
      if (b === void 0 && T === void 0)
        throw new Error("Must provide either datasetName or datasetId");
      if (b !== void 0 && T !== void 0)
        throw new Error("Must provide either datasetName or datasetId, not both");
      b === void 0 && (b = (await this.readDataset({ datasetName: T })).id);
      const x = await this._uploadExamplesMultipart(b, y);
      return await Promise.all(x.example_ids.map((O) => this.readExample(O)));
    }
    const { inputs: n, outputs: r, metadata: s, splits: i, sourceRunIds: a, useSourceRunIOs: o, useSourceRunAttachments: u, attachments: c, exampleIds: l, datasetId: d, datasetName: f } = t;
    if (n === void 0)
      throw new Error("Must provide inputs when using legacy parameters");
    let h = d;
    const p = f;
    if (h === void 0 && p === void 0)
      throw new Error("Must provide either datasetName or datasetId");
    if (h !== void 0 && p !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    h === void 0 && (h = (await this.readDataset({ datasetName: p })).id);
    const g = n.map((y, b) => ({
      dataset_id: h,
      inputs: y,
      outputs: r?.[b],
      metadata: s?.[b],
      split: i?.[b],
      id: l?.[b],
      attachments: c?.[b],
      source_run_id: a?.[b],
      use_source_run_io: o?.[b],
      use_source_run_attachments: u?.[b]
    })), m = await this._uploadExamplesMultipart(h, g);
    return await Promise.all(m.example_ids.map((y) => this.readExample(y)));
  }
  async createLLMExample(t, n, r) {
    return this.createExample({ input: t }, { output: n }, r);
  }
  async createChatExample(t, n, r) {
    const s = t.map((a) => Gy(a) ? Wy(a) : a), i = Gy(n) ? Wy(n) : n;
    return this.createExample({ input: s }, { output: i }, r);
  }
  async readExample(t) {
    ve(t);
    const n = `/examples/${t}`, r = await this._get(n), { attachment_urls: s, ...i } = r, a = i;
    return s && (a.attachments = Object.entries(s).reduce((o, [u, c]) => (o[u.slice(11)] = {
      presigned_url: c.presigned_url,
      mime_type: c.mime_type
    }, o), {})), a;
  }
  async *listExamples({ datasetId: t, datasetName: n, exampleIds: r, asOf: s, splits: i, inlineS3Urls: a, metadata: o, limit: u, offset: c, filter: l, includeAttachments: d } = {}) {
    let f;
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    if (t !== void 0)
      f = t;
    else if (n !== void 0)
      f = (await this.readDataset({ datasetName: n })).id;
    else
      throw new Error("Must provide a datasetName or datasetId");
    const h = new URLSearchParams({ dataset: f }), p = s ? typeof s == "string" ? s : s?.toISOString() : void 0;
    p && h.append("as_of", p);
    const g = a ?? !0;
    if (h.append("inline_s3_urls", g.toString()), r !== void 0)
      for (const _ of r)
        h.append("id", _);
    if (i !== void 0)
      for (const _ of i)
        h.append("splits", _);
    if (o !== void 0) {
      const _ = JSON.stringify(o);
      h.append("metadata", _);
    }
    u !== void 0 && h.append("limit", u.toString()), c !== void 0 && h.append("offset", c.toString()), l !== void 0 && h.append("filter", l), d === !0 && ["attachment_urls", "outputs", "metadata"].forEach((_) => h.append("select", _));
    let m = 0;
    for await (const _ of this._getPaginated("/examples", h)) {
      for (const y of _) {
        const { attachment_urls: b, ...T } = y, x = T;
        b && (x.attachments = Object.entries(b).reduce((k, [O, S]) => (k[O.slice(11)] = {
          presigned_url: S.presigned_url,
          mime_type: S.mime_type || void 0
        }, k), {})), yield x, m++;
      }
      if (u !== void 0 && m >= u)
        break;
    }
  }
  async deleteExample(t) {
    ve(t);
    const n = `/examples/${t}`;
    await this.caller.call(async () => {
      const r = await this._fetch(this.apiUrl + n, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(r, `delete ${n}`, !0), r;
    });
  }
  /**
   * Delete multiple examples by ID.
   * @param exampleIds - The IDs of the examples to delete
   * @param options - Optional settings for deletion
   * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.
   */
  async deleteExamples(t, n) {
    if (t.forEach((r) => ve(r)), n?.hardDelete) {
      const r = this._getPlatformEndpointPath("datasets/examples/delete");
      await this.caller.call(async () => {
        const s = await this._fetch(`${this.apiUrl}${r}`, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            example_ids: t,
            hard_delete: !0
          }),
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await ne(s, "hard delete examples", !0), s;
      });
    } else {
      const r = new URLSearchParams();
      t.forEach((s) => r.append("example_ids", s)), await this.caller.call(async () => {
        const s = await this._fetch(`${this.apiUrl}/examples?${r.toString()}`, {
          method: "DELETE",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        return await ne(s, "delete examples", !0), s;
      });
    }
  }
  async updateExample(t, n) {
    let r;
    n ? r = t : r = t.id, ve(r);
    let s;
    n ? s = { id: r, ...n } : s = t;
    let i;
    return s.dataset_id !== void 0 ? i = s.dataset_id : i = (await this.readExample(r)).dataset_id, this._updateExamplesMultipart(i, [s]);
  }
  async updateExamples(t) {
    let n;
    return t[0].dataset_id === void 0 ? n = (await this.readExample(t[0].id)).dataset_id : n = t[0].dataset_id, this._updateExamplesMultipart(n, t);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId: t, datasetName: n, asOf: r, tag: s }) {
    let i;
    if (t ? i = t : i = (await this.readDataset({ datasetName: n })).id, ve(i), r && s || !r && !s)
      throw new Error("Exactly one of asOf and tag must be specified.");
    const a = new URLSearchParams();
    return r !== void 0 && a.append("as_of", typeof r == "string" ? r : r.toISOString()), s !== void 0 && a.append("tag", s), await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/datasets/${i}/version?${a.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(u, "read dataset version"), u;
    })).json();
  }
  async listDatasetSplits({ datasetId: t, datasetName: n, asOf: r }) {
    let s;
    if (t === void 0 && n === void 0)
      throw new Error("Must provide dataset name or ID");
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    t === void 0 ? s = (await this.readDataset({ datasetName: n })).id : s = t, ve(s);
    const i = new URLSearchParams(), a = r ? typeof r == "string" ? r : r?.toISOString() : void 0;
    return a && i.append("as_of", a), await this._get(`/datasets/${s}/splits`, i);
  }
  async updateDatasetSplits({ datasetId: t, datasetName: n, splitName: r, exampleIds: s, remove: i = !1 }) {
    let a;
    if (t === void 0 && n === void 0)
      throw new Error("Must provide dataset name or ID");
    if (t !== void 0 && n !== void 0)
      throw new Error("Must provide either datasetName or datasetId, not both");
    t === void 0 ? a = (await this.readDataset({ datasetName: n })).id : a = t, ve(a);
    const o = {
      split_name: r,
      examples: s.map((c) => (ve(c), c)),
      remove: i
    }, u = JSON.stringify(o);
    await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/datasets/${a}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await ne(c, "update dataset splits", !0), c;
    });
  }
  async createFeedback(t, n, { score: r, value: s, correction: i, comment: a, sourceInfo: o, feedbackSourceType: u = "api", sourceRunId: c, feedbackId: l, feedbackConfig: d, projectId: f, comparativeExperimentId: h }) {
    if (!t && !f)
      throw new Error("One of runId or projectId must be provided");
    if (t && f)
      throw new Error("Only one of runId or projectId can be provided");
    const p = {
      type: u ?? "api",
      metadata: o ?? {}
    };
    c !== void 0 && p?.metadata !== void 0 && !p.metadata.__run && (p.metadata.__run = { run_id: c }), p?.metadata !== void 0 && p.metadata.__run?.run_id !== void 0 && ve(p.metadata.__run.run_id);
    const g = {
      id: l ?? Qi(),
      run_id: t,
      key: n,
      score: Bw(r),
      value: s,
      correction: i,
      comment: a,
      feedback_source: p,
      comparative_experiment_id: h,
      feedbackConfig: d,
      session_id: f
    }, m = JSON.stringify(g), _ = `${this.apiUrl}/feedback`;
    return await this.caller.call(async () => {
      const y = await this._fetch(_, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: m
      });
      return await ne(y, "create feedback", !0), y;
    }), g;
  }
  async updateFeedback(t, { score: n, value: r, correction: s, comment: i }) {
    const a = {};
    n != null && (a.score = Bw(n)), r != null && (a.value = r), s != null && (a.correction = s), i != null && (a.comment = i), ve(t);
    const o = JSON.stringify(a);
    await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/feedback/${t}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await ne(u, "update feedback", !0), u;
    });
  }
  async readFeedback(t) {
    ve(t);
    const n = `/feedback/${t}`;
    return await this._get(n);
  }
  async deleteFeedback(t) {
    ve(t);
    const n = `/feedback/${t}`;
    await this.caller.call(async () => {
      const r = await this._fetch(this.apiUrl + n, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(r, `delete ${n}`, !0), r;
    });
  }
  async *listFeedback({ runIds: t, feedbackKeys: n, feedbackSourceTypes: r } = {}) {
    const s = new URLSearchParams();
    if (t)
      for (const i of t)
        ve(i), s.append("run", i);
    if (n)
      for (const i of n)
        s.append("key", i);
    if (r)
      for (const i of r)
        s.append("source", i);
    for await (const i of this._getPaginated("/feedback", s))
      yield* i;
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(t, n, { expiration: r, feedbackConfig: s } = {}) {
    const i = {
      run_id: t,
      feedback_key: n,
      feedback_config: s
    };
    r ? typeof r == "string" ? i.expires_at = r : (r?.hours || r?.minutes || r?.days) && (i.expires_in = r) : i.expires_in = {
      hours: 3
    };
    const a = JSON.stringify(i);
    return await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(u, "create presigned feedback token"), u;
    })).json();
  }
  async createComparativeExperiment({ name: t, experimentIds: n, referenceDatasetId: r, createdAt: s, description: i, metadata: a, id: o }) {
    if (n.length === 0)
      throw new Error("At least one experiment is required");
    if (r || (r = (await this.readProject({
      projectId: n[0]
    })).reference_dataset_id), !r == null)
      throw new Error("A reference dataset is required");
    const u = {
      id: o,
      name: t,
      experiment_ids: n,
      reference_dataset_id: r,
      description: i,
      created_at: (s ?? /* @__PURE__ */ new Date())?.toISOString(),
      extra: {}
    };
    a && (u.extra.metadata = a);
    const c = JSON.stringify(u);
    return (await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await ne(d, "create comparative experiment"), d;
    })).json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(t) {
    ve(t);
    const n = new URLSearchParams({ run_id: t });
    for await (const r of this._getPaginated("/feedback/tokens", n))
      yield* r;
  }
  _selectEvalResults(t) {
    let n;
    return "results" in t ? n = t.results : Array.isArray(t) ? n = t : n = [t], n;
  }
  async _logEvaluationFeedback(t, n, r) {
    const s = this._selectEvalResults(t), i = [];
    for (const a of s) {
      let o = r || {};
      a.evaluatorInfo && (o = { ...a.evaluatorInfo, ...o });
      let u = null;
      a.targetRunId ? u = a.targetRunId : n && (u = n.id), i.push(await this.createFeedback(u, a.key, {
        score: a.score,
        value: a.value,
        comment: a.comment,
        correction: a.correction,
        sourceInfo: o,
        sourceRunId: a.sourceRunId,
        feedbackConfig: a.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [s, i];
  }
  async logEvaluationFeedback(t, n, r) {
    const [s] = await this._logEvaluationFeedback(t, n, r);
    return s;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(t = {}) {
    const { queueIds: n, name: r, nameContains: s, limit: i } = t, a = new URLSearchParams();
    n && n.forEach((u, c) => {
      ve(u, `queueIds[${c}]`), a.append("ids", u);
    }), r && a.append("name", r), s && a.append("name_contains", s), a.append("limit", (i !== void 0 ? Math.min(i, 100) : 100).toString());
    let o = 0;
    for await (const u of this._getPaginated("/annotation-queues", a))
      if (yield* u, o++, i !== void 0 && o >= i)
        break;
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(t) {
    const { name: n, description: r, queueId: s, rubricInstructions: i } = t, a = {
      name: n,
      description: r,
      id: s || Qi(),
      rubric_instructions: i
    }, o = JSON.stringify(Object.fromEntries(Object.entries(a).filter(([c, l]) => l !== void 0)));
    return (await this.caller.call(async () => {
      const c = await this._fetch(`${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: o
      });
      return await ne(c, "create annotation queue"), c;
    })).json();
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(t) {
    return (await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(t, "queueId")}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(r, "read annotation queue"), r;
    })).json();
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(t, n) {
    const { name: r, description: s, rubricInstructions: i } = n, a = JSON.stringify({
      name: r,
      description: s,
      rubric_instructions: i
    });
    await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(t, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(o, "update annotation queue", !0), o;
    });
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(t) {
    await this.caller.call(async () => {
      const n = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(t, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(n, "delete annotation queue", !0), n;
    });
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(t, n) {
    const r = JSON.stringify(n.map((s, i) => ve(s, `runIds[${i}]`).toString()));
    await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(t, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: r
      });
      return await ne(s, "add runs to annotation queue", !0), s;
    });
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(t, n) {
    const r = `/annotation-queues/${ve(t, "queueId")}/run`;
    return (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}${r}/${n}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(i, "get run from annotation queue"), i;
    })).json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(t, n) {
    await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(t, "queueId")}/runs/${ve(n, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(r, "delete run from annotation queue", !0), r;
    });
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(t) {
    return (await this.caller.call(async () => {
      const r = await this._fetch(`${this.apiUrl}/annotation-queues/${ve(t, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(r, "get size from annotation queue"), r;
    })).json();
  }
  async _currentTenantIsOwner(t) {
    const n = await this._getSettings();
    return t == "-" || n.tenant_handle === t;
  }
  async _ownerConflictError(t, n) {
    const r = await this._getSettings();
    return new Error(`Cannot ${t} for another tenant.

      Current tenant: ${r.tenant_handle}

      Requested tenant: ${n}`);
  }
  async _getLatestCommitHash(t) {
    const r = await (await this.caller.call(async () => {
      const s = await this._fetch(`${this.apiUrl}/commits/${t}/?limit=1&offset=0`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(s, "get latest commit hash"), s;
    })).json();
    if (r.commits.length !== 0)
      return r.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(t, n) {
    const [r, s, i] = Tr(t), a = JSON.stringify({ like: n });
    return (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/likes/${r}/${s}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(u, `${n ? "like" : "unlike"} prompt`), u;
    })).json();
  }
  async _getPromptUrl(t) {
    const [n, r, s] = Tr(t);
    if (await this._currentTenantIsOwner(n)) {
      const i = await this._getSettings();
      return s !== "latest" ? `${this.getHostUrl()}/prompts/${r}/${s.substring(0, 8)}?organizationId=${i.id}` : `${this.getHostUrl()}/prompts/${r}?organizationId=${i.id}`;
    } else
      return s !== "latest" ? `${this.getHostUrl()}/hub/${n}/${r}/${s.substring(0, 8)}` : `${this.getHostUrl()}/hub/${n}/${r}`;
  }
  async promptExists(t) {
    return !!await this.getPrompt(t);
  }
  async likePrompt(t) {
    return this._likeOrUnlikePrompt(t, !0);
  }
  async unlikePrompt(t) {
    return this._likeOrUnlikePrompt(t, !1);
  }
  async *listCommits(t) {
    for await (const n of this._getPaginated(`/commits/${t}/`, new URLSearchParams(), (r) => r.commits))
      yield* n;
  }
  async *listPrompts(t) {
    const n = new URLSearchParams();
    n.append("sort_field", t?.sortField ?? "updated_at"), n.append("sort_direction", "desc"), n.append("is_archived", (!!t?.isArchived).toString()), t?.isPublic !== void 0 && n.append("is_public", t.isPublic.toString()), t?.query && n.append("query", t.query);
    for await (const r of this._getPaginated("/repos", n, (s) => s.repos))
      yield* r;
  }
  async getPrompt(t) {
    const [n, r, s] = Tr(t), a = await (await this.caller.call(async () => {
      const o = await this._fetch(`${this.apiUrl}/repos/${n}/${r}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return o?.status === 404 ? null : (await ne(o, "get prompt"), o);
    }))?.json();
    return a?.repo ? a.repo : null;
  }
  async createPrompt(t, n) {
    const r = await this._getSettings();
    if (n?.isPublic && !r.tenant_handle)
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    const [s, i, a] = Tr(t);
    if (!await this._currentTenantIsOwner(s))
      throw await this._ownerConflictError("create a prompt", s);
    const o = {
      repo_handle: i,
      ...n?.description && { description: n.description },
      ...n?.readme && { readme: n.readme },
      ...n?.tags && { tags: n.tags },
      is_public: !!n?.isPublic
    }, u = JSON.stringify(o), c = await this.caller.call(async () => {
      const d = await this._fetch(`${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: u
      });
      return await ne(d, "create prompt"), d;
    }), { repo: l } = await c.json();
    return l;
  }
  async createCommit(t, n, r) {
    if (!await this.promptExists(t))
      throw new Error("Prompt does not exist, you must create it first.");
    const [s, i, a] = Tr(t), o = r?.parentCommitHash === "latest" || !r?.parentCommitHash ? await this._getLatestCommitHash(`${s}/${i}`) : r?.parentCommitHash, u = {
      manifest: JSON.parse(JSON.stringify(n)),
      parent_commit: o
    }, c = JSON.stringify(u), d = await (await this.caller.call(async () => {
      const f = await this._fetch(`${this.apiUrl}/commits/${s}/${i}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: c
      });
      return await ne(f, "create commit"), f;
    })).json();
    return this._getPromptUrl(`${s}/${i}${d.commit_hash ? `:${d.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(t, n = []) {
    return this._updateExamplesMultipart(t, n);
  }
  async _updateExamplesMultipart(t, n = []) {
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const r = new FormData();
    for (const a of n) {
      const o = a.id, u = {
        ...a.metadata && { metadata: a.metadata },
        ...a.split && { split: a.split }
      }, c = tn(u, `Serializing body for example with id: ${o}`), l = new Blob([c], {
        type: "application/json"
      });
      if (r.append(o, l), a.inputs) {
        const d = tn(a.inputs, `Serializing inputs for example with id: ${o}`), f = new Blob([d], {
          type: "application/json"
        });
        r.append(`${o}.inputs`, f);
      }
      if (a.outputs) {
        const d = tn(a.outputs, `Serializing outputs whle updating example with id: ${o}`), f = new Blob([d], {
          type: "application/json"
        });
        r.append(`${o}.outputs`, f);
      }
      if (a.attachments)
        for (const [d, f] of Object.entries(a.attachments)) {
          let h, p;
          Array.isArray(f) ? [h, p] = f : (h = f.mimeType, p = f.data);
          const g = new Blob([p], {
            type: `${h}; length=${p.byteLength}`
          });
          r.append(`${o}.attachment.${d}`, g);
        }
      if (a.attachments_operations) {
        const d = tn(a.attachments_operations, `Serializing attachments while updating example with id: ${o}`), f = new Blob([d], {
          type: "application/json"
        });
        r.append(`${o}.attachments_operations`, f);
      }
    }
    const s = t ?? n[0]?.dataset_id;
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${s}/examples`)}`, {
        method: "PATCH",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: r
      });
      return await ne(a, "update examples"), a;
    })).json();
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(t, n = []) {
    return this._uploadExamplesMultipart(t, n);
  }
  async _uploadExamplesMultipart(t, n = []) {
    if (!await this._getDatasetExamplesMultiPartSupport())
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    const r = new FormData();
    for (const i of n) {
      const a = (i.id ?? Qi()).toString(), o = {
        created_at: i.created_at,
        ...i.metadata && { metadata: i.metadata },
        ...i.split && { split: i.split },
        ...i.source_run_id && { source_run_id: i.source_run_id },
        ...i.use_source_run_io && {
          use_source_run_io: i.use_source_run_io
        },
        ...i.use_source_run_attachments && {
          use_source_run_attachments: i.use_source_run_attachments
        }
      }, u = tn(o, `Serializing body for uploaded example with id: ${a}`), c = new Blob([u], {
        type: "application/json"
      });
      if (r.append(a, c), i.inputs) {
        const l = tn(i.inputs, `Serializing inputs for uploaded example with id: ${a}`), d = new Blob([l], {
          type: "application/json"
        });
        r.append(`${a}.inputs`, d);
      }
      if (i.outputs) {
        const l = tn(i.outputs, `Serializing outputs for uploaded example with id: ${a}`), d = new Blob([l], {
          type: "application/json"
        });
        r.append(`${a}.outputs`, d);
      }
      if (i.attachments)
        for (const [l, d] of Object.entries(i.attachments)) {
          let f, h;
          Array.isArray(d) ? [f, h] = d : (f = d.mimeType, h = d.data);
          const p = new Blob([h], {
            type: `${f}; length=${h.byteLength}`
          });
          r.append(`${a}.attachment.${l}`, p);
        }
    }
    return (await this.caller.call(async () => {
      const i = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${t}/examples`)}`, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: r
      });
      return await ne(i, "upload examples"), i;
    })).json();
  }
  async updatePrompt(t, n) {
    if (!await this.promptExists(t))
      throw new Error("Prompt does not exist, you must create it first.");
    const [r, s] = Tr(t);
    if (!await this._currentTenantIsOwner(r))
      throw await this._ownerConflictError("update a prompt", r);
    const i = {};
    if (n?.description !== void 0 && (i.description = n.description), n?.readme !== void 0 && (i.readme = n.readme), n?.tags !== void 0 && (i.tags = n.tags), n?.isPublic !== void 0 && (i.is_public = n.isPublic), n?.isArchived !== void 0 && (i.is_archived = n.isArchived), Object.keys(i).length === 0)
      throw new Error("No valid update options provided");
    const a = JSON.stringify(i);
    return (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/repos/${r}/${s}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: a
      });
      return await ne(u, "update prompt"), u;
    })).json();
  }
  async deletePrompt(t) {
    if (!await this.promptExists(t))
      throw new Error("Prompt does not exist, you must create it first.");
    const [n, r, s] = Tr(t);
    if (!await this._currentTenantIsOwner(n))
      throw await this._ownerConflictError("delete a prompt", n);
    return (await this.caller.call(async () => {
      const a = await this._fetch(`${this.apiUrl}/repos/${n}/${r}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(a, "delete prompt"), a;
    })).json();
  }
  /**
   * Generate a cache key for a prompt.
   * Format: "{identifier}" or "{identifier}:with_model"
   */
  _getPromptCacheKey(t, n) {
    return `${t}${n ? ":with_model" : ""}`;
  }
  /**
   * Fetch a prompt commit directly from the API (bypassing cache).
   */
  async _fetchPromptFromApi(t, n) {
    const [r, s, i] = Tr(t), o = await (await this.caller.call(async () => {
      const u = await this._fetch(`${this.apiUrl}/commits/${r}/${s}/${i}${n?.includeModel ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await ne(u, "pull prompt commit"), u;
    })).json();
    return {
      owner: r,
      repo: s,
      commit_hash: o.commit_hash,
      manifest: o.manifest,
      examples: o.examples
    };
  }
  async pullPromptCommit(t, n) {
    if (!n?.skipCache && this._cache) {
      const r = this._getPromptCacheKey(t, n?.includeModel), s = this._cache.get(r);
      if (s)
        return s;
      const i = await this._fetchPromptFromApi(t, n);
      return this._cache.set(r, i), i;
    }
    return this._fetchPromptFromApi(t, n);
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(t, n) {
    const r = await this.pullPromptCommit(t, {
      includeModel: n?.includeModel,
      skipCache: n?.skipCache
    });
    return JSON.stringify(r.manifest);
  }
  async pushPrompt(t, n) {
    return await this.promptExists(t) ? n && Object.keys(n).some((s) => s !== "object") && await this.updatePrompt(t, {
      description: n?.description,
      readme: n?.readme,
      tags: n?.tags,
      isPublic: n?.isPublic
    }) : await this.createPrompt(t, {
      description: n?.description,
      readme: n?.readme,
      tags: n?.tags,
      isPublic: n?.isPublic
    }), n?.object ? await this.createCommit(t, n?.object, {
      parentCommitHash: n?.parentCommitHash
    }) : await this._getPromptUrl(t);
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(t, n = {}) {
    const { sourceApiUrl: r = this.apiUrl, datasetName: s } = n, [i, a] = this.parseTokenOrUrl(t, r), o = new fo({
      apiUrl: i,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    }), u = await o.readSharedDataset(a), c = s || u.name;
    try {
      if (await this.hasDataset({ datasetId: c })) {
        console.log(`Dataset ${c} already exists in your tenant. Skipping.`);
        return;
      }
    } catch {
    }
    const l = await o.listSharedExamples(a), d = await this.createDataset(c, {
      description: u.description,
      dataType: u.data_type || "kv",
      inputsSchema: u.inputs_schema_definition ?? void 0,
      outputsSchema: u.outputs_schema_definition ?? void 0
    });
    try {
      await this.createExamples({
        inputs: l.map((f) => f.inputs),
        outputs: l.flatMap((f) => f.outputs ? [f.outputs] : []),
        datasetId: d.id
      });
    } catch (f) {
      throw console.error(`An error occurred while creating dataset ${c}. You should delete it manually.`), f;
    }
  }
  parseTokenOrUrl(t, n, r = 2, s = "dataset") {
    try {
      return ve(t), [n, t];
    } catch {
    }
    try {
      const a = new URL(t).pathname.split("/").filter((o) => o !== "");
      if (a.length >= r) {
        const o = a[a.length - r];
        return [n, o];
      } else
        throw new Error(`Invalid public ${s} URL: ${t}`);
    } catch {
      throw new Error(`Invalid public ${s} URL or token: ${t}`);
    }
  }
  /**
   * Get the cache instance, if caching is enabled.
   * Useful for accessing cache metrics or manually managing the cache.
   */
  get cache() {
    return this._cache;
  }
  /**
   * Cleanup resources held by the client.
   * Stops the cache's background refresh timer.
   */
  cleanup() {
    this._cache && this._cache.stop();
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  async awaitPendingTraceBatches() {
    if (this.manualFlushMode)
      return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve();
    await new Promise((t) => setTimeout(t, 1)), await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise: t }) => t),
      this.batchIngestCaller.queue.onIdle()
    ]), this.langSmithToOTELTranslator !== void 0 && await O$()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();
  }
}
function Vw(e) {
  return "dataset_id" in e || "dataset_name" in e;
}
const jR = (e) => !!["TRACING_V2", "TRACING"].find((n) => Bt(n) === "true"), Nr = /* @__PURE__ */ Symbol.for("lc:context_variables"), Jf = /* @__PURE__ */ Symbol.for("langsmith:replica_trace_roots");
function Hw(e, t) {
  if (Nr in e)
    return e[Nr][t];
}
function LR(e, t, n) {
  const r = Nr in e ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e[Nr]
  ) : {};
  r[t] = n, e[Nr] = r;
}
const Ba = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
function Gw(e) {
  const n = Object.keys(e).sort().map((r) => `${r}:${e[r] ?? ""}`).join("|");
  return qa(n, Ba);
}
function DR(e) {
  return e.replace(/[-:.]/g, "");
}
function lx(e, t = 1) {
  const n = t.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(e).toISOString().slice(0, -1)}${n}Z`;
}
function dx(e, t, n = 1) {
  const r = lx(e, n);
  return {
    dottedOrder: DR(r) + t,
    microsecondPrecisionDatestring: r
  };
}
const UR = /* @__PURE__ */ new Set([
  "projectName",
  "updates",
  "reroot"
]);
function FR(e) {
  const t = {};
  for (const n of Object.keys(e))
    UR.has(n) && (t[n] = e[n]);
  return t;
}
class Rc {
  constructor(t, n, r, s) {
    Object.defineProperty(this, "metadata", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.metadata = t, this.tags = n, this.project_name = r, this.replicas = s;
  }
  static fromHeader(t) {
    const n = t.split(",");
    let r = {}, s = [], i, a;
    for (const o of n) {
      const [u, c] = o.split("="), l = decodeURIComponent(c);
      u === "langsmith-metadata" ? r = JSON.parse(l) : u === "langsmith-tags" ? s = l.split(",") : u === "langsmith-project" ? i = l : u === "langsmith-replicas" && (a = JSON.parse(l).map((f) => Array.isArray(f) ? f : FR(f)));
    }
    return new Rc(r, s, i, a);
  }
  toHeader() {
    const t = [];
    return this.metadata && Object.keys(this.metadata).length > 0 && t.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`), this.tags && this.tags.length > 0 && t.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`), this.project_name && t.push(`langsmith-project=${encodeURIComponent(this.project_name)}`), t.join(",");
  }
}
class zt {
  constructor(t) {
    if (Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "run_type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "project_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "parent_run_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_runs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "end_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "extra", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tags", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "error", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "serialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "outputs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reference_example_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "client", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "trace_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dotted_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tracingEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "child_execution_order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "attachments", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "replicas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "distributedParentId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_serialized_start_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_awaitInputsOnPost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), zR(t)) {
      Object.assign(this, { ...t });
      return;
    }
    const n = zt.getDefaultConfig(), { metadata: r, ...s } = t, i = s.client ?? zt.getSharedClient(), a = {
      ...r,
      ...s?.extra?.metadata
    };
    if (s.extra = { ...s.extra, metadata: a }, "id" in s && s.id == null && delete s.id, Object.assign(this, { ...n, ...s, client: i }), this.execution_order ??= 1, this.child_execution_order ??= 1, this.dotted_order || (this._serialized_start_time = lx(this.start_time, this.execution_order)), this.id || (this.id = c$(this._serialized_start_time ?? this.start_time)), this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id), this.replicas = VR(this.replicas), !this.dotted_order) {
      const { dottedOrder: o } = dx(this.start_time, this.id, this.execution_order);
      this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + o : this.dotted_order = o;
    }
  }
  set metadata(t) {
    this.extra = {
      ...this.extra,
      metadata: {
        ...this.extra?.metadata,
        ...t
      }
    };
  }
  get metadata() {
    return this.extra?.metadata;
  }
  static getDefaultConfig() {
    const t = Date.now();
    return {
      run_type: "chain",
      project_name: WT(),
      child_runs: [],
      api_url: Yn("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: Yn("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: t,
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    return zt.sharedClient || (zt.sharedClient = new fo()), zt.sharedClient;
  }
  createChild(t) {
    const n = this.child_execution_order + 1, r = this.replicas?.map((l) => {
      const { reroot: d, ...f } = l;
      return f;
    }), s = t.replicas ?? r, i = new zt({
      ...t,
      parent_run: this,
      project_name: this.project_name,
      replicas: s,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: n,
      child_execution_order: n
    });
    Nr in this && (i[Nr] = this[Nr]);
    const a = /* @__PURE__ */ Symbol.for("lc:child_config"), o = t.extra?.[a] ?? this.extra[a];
    if (BR(o)) {
      const l = { ...o }, d = qR(l.callbacks) ? l.callbacks.copy?.() : void 0;
      d && (Object.assign(d, { _parentRunId: i.id }), d.handlers?.find(fx)?.updateFromRunTree?.(i), l.callbacks = d), i.extra[a] = l;
    }
    const u = /* @__PURE__ */ new Set();
    let c = this;
    for (; c != null && !u.has(c.id); )
      u.add(c.id), c.child_execution_order = Math.max(c.child_execution_order, n), c = c.parent_run;
    return this.child_runs.push(i), i;
  }
  async end(t, n, r = Date.now(), s) {
    this.outputs = this.outputs ?? t, this.error = this.error ?? n, this.end_time = this.end_time ?? r, s && Object.keys(s).length > 0 && (this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...s } } : { metadata: s });
  }
  _convertToCreate(t, n, r = !0) {
    const s = t.extra ?? {};
    if (s?.runtime?.library === void 0 && (s.runtime || (s.runtime = {}), n))
      for (const [o, u] of Object.entries(n))
        s.runtime[o] || (s.runtime[o] = u);
    let i, a;
    return r ? (a = t.parent_run?.id ?? t.parent_run_id, i = []) : (i = t.child_runs.map((o) => this._convertToCreate(o, n, r)), a = void 0), {
      id: t.id,
      name: t.name,
      start_time: t._serialized_start_time ?? t.start_time,
      end_time: t.end_time,
      run_type: t.run_type,
      reference_example_id: t.reference_example_id,
      extra: s,
      serialized: t.serialized,
      error: t.error,
      inputs: t.inputs,
      outputs: t.outputs,
      session_name: t.project_name,
      child_runs: i,
      parent_run_id: a,
      trace_id: t.trace_id,
      dotted_order: t.dotted_order,
      tags: t.tags,
      attachments: t.attachments,
      events: t.events
    };
  }
  _sliceParentId(t, n) {
    if (n.dotted_order) {
      const r = n.dotted_order.split(".");
      let s = null;
      for (let i = 0; i < r.length; i++)
        if (r[i].slice(-36) === t) {
          s = i;
          break;
        }
      if (s !== null) {
        const i = r.slice(s + 1);
        n.dotted_order = i.join("."), i.length > 0 ? n.trace_id = i[0].slice(-36) : n.trace_id = n.id;
      }
    }
    n.parent_run_id === t && (n.parent_run_id = void 0);
  }
  _setReplicaTraceRoot(t, n) {
    const r = Hw(this, Jf) ?? {};
    r[t] = n, LR(this, Jf, r);
    for (const s of this.child_runs)
      s._setReplicaTraceRoot(t, n);
  }
  _remapForProject(t) {
    const { projectName: n, runtimeEnv: r, excludeChildRuns: s = !0, reroot: i = !1, distributedParentId: a, apiUrl: o, apiKey: u, workspaceId: c } = t, l = this._convertToCreate(this, r, s);
    if (n === this.project_name)
      return {
        ...l,
        session_name: n
      };
    if (i) {
      if (a)
        this._sliceParentId(a, l);
      else if (l.parent_run_id = void 0, l.dotted_order) {
        const y = l.dotted_order.split(".");
        y.length > 0 && (l.dotted_order = y[y.length - 1], l.trace_id = l.id);
      }
      const _ = Gw({
        projectName: n,
        apiUrl: o,
        apiKey: u,
        workspaceId: c
      });
      this._setReplicaTraceRoot(_, l.id);
    }
    let d;
    if (!i) {
      const _ = Hw(this, Jf) ?? {}, y = Gw({
        projectName: n,
        apiUrl: o,
        apiKey: u,
        workspaceId: c
      });
      if (d = _[y], d && (l.trace_id = d, l.dotted_order)) {
        const b = l.dotted_order.split(".");
        let T = null;
        for (let x = 0; x < b.length; x++)
          if (b[x].slice(-36) === d) {
            T = x;
            break;
          }
        if (T !== null) {
          const x = b.slice(T);
          l.dotted_order = x.join(".");
        }
      }
    }
    const f = l.id, h = qa(`${f}:${n}`, Ba);
    let p;
    l.trace_id ? p = qa(`${l.trace_id}:${n}`, Ba) : p = h;
    let g;
    l.parent_run_id && (g = qa(`${l.parent_run_id}:${n}`, Ba));
    let m;
    return l.dotted_order && (m = l.dotted_order.split(".").map((b) => {
      const T = b.slice(-36), x = qa(`${T}:${n}`, Ba);
      return b.slice(0, -36) + x;
    }).join(".")), {
      ...l,
      id: h,
      trace_id: p,
      parent_run_id: g,
      dotted_order: m,
      session_name: n
    };
  }
  async postRun(t = !0) {
    this._awaitInputsOnPost && (this.inputs = await this.inputs);
    try {
      const n = QT();
      if (this.replicas && this.replicas.length > 0)
        for (const { projectName: r, apiKey: s, apiUrl: i, workspaceId: a, reroot: o } of this.replicas) {
          const u = this._remapForProject({
            projectName: r ?? this.project_name,
            runtimeEnv: n,
            excludeChildRuns: !0,
            reroot: o,
            distributedParentId: this.distributedParentId,
            apiUrl: i,
            apiKey: s,
            workspaceId: a
          });
          await this.client.createRun(u, {
            apiKey: s,
            apiUrl: i,
            workspaceId: a
          });
        }
      else {
        const r = this._convertToCreate(this, n, t);
        await this.client.createRun(r);
      }
      if (!t) {
        JT("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const r of this.child_runs)
          await r.postRun(!1);
      }
      this.child_runs = [];
    } catch (n) {
      console.error(`Error in postRun for run ${this.id}:`, n);
    }
  }
  async patchRun(t) {
    if (this.replicas && this.replicas.length > 0)
      for (const { projectName: n, apiKey: r, apiUrl: s, workspaceId: i, updates: a, reroot: o } of this.replicas) {
        const u = this._remapForProject({
          projectName: n ?? this.project_name,
          runtimeEnv: void 0,
          excludeChildRuns: !0,
          reroot: o,
          distributedParentId: this.distributedParentId,
          apiUrl: s,
          apiKey: r,
          workspaceId: i
        }), c = {
          id: u.id,
          name: u.name,
          run_type: u.run_type,
          start_time: u.start_time,
          outputs: u.outputs,
          error: u.error,
          parent_run_id: u.parent_run_id,
          session_name: u.session_name,
          reference_example_id: u.reference_example_id,
          end_time: u.end_time,
          dotted_order: u.dotted_order,
          trace_id: u.trace_id,
          events: u.events,
          tags: u.tags,
          extra: u.extra,
          attachments: this.attachments,
          ...a
        };
        t?.excludeInputs || (c.inputs = u.inputs), await this.client.updateRun(u.id, c, {
          apiKey: r,
          apiUrl: s,
          workspaceId: i
        });
      }
    else
      try {
        const n = {
          name: this.name,
          run_type: this.run_type,
          start_time: this._serialized_start_time ?? this.start_time,
          end_time: this.end_time,
          error: this.error,
          outputs: this.outputs,
          parent_run_id: this.parent_run?.id ?? this.parent_run_id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        t?.excludeInputs || (n.inputs = this.inputs), await this.client.updateRun(this.id, n);
      } catch (n) {
        console.error(`Error in patchRun for run ${this.id}`, n);
      }
    this.child_runs = [];
  }
  toJSON() {
    return this._convertToCreate(this, void 0, !1);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(t) {
    this.events || (this.events = []), typeof t == "string" ? this.events.push({
      name: "event",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      message: t
    }) : this.events.push({
      ...t,
      time: t.time ?? (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static fromRunnableConfig(t, n) {
    const r = t?.callbacks;
    let s, i, a, o = jR();
    if (r) {
      const c = r?.getParentRunId?.() ?? "", l = r?.handlers?.find((d) => d?.name == "langchain_tracer");
      s = l?.getRun?.(c), i = l?.projectName, a = l?.client, o = o || !!l;
    }
    return s ? new zt({
      name: s.name,
      id: s.id,
      trace_id: s.trace_id,
      dotted_order: s.dotted_order,
      client: a,
      tracingEnabled: o,
      project_name: i,
      tags: [
        ...new Set((s?.tags ?? []).concat(t?.tags ?? []))
      ],
      extra: {
        metadata: {
          ...s?.extra?.metadata,
          ...t?.metadata
        }
      }
    }).createChild(n) : new zt({
      ...n,
      client: a,
      tracingEnabled: o,
      project_name: i
    });
  }
  static fromDottedOrder(t) {
    return this.fromHeaders({ "langsmith-trace": t });
  }
  static fromHeaders(t, n) {
    const r = "get" in t && typeof t.get == "function" ? {
      "langsmith-trace": t.get("langsmith-trace"),
      baggage: t.get("baggage")
    } : t, s = r["langsmith-trace"];
    if (!s || typeof s != "string")
      return;
    const i = s.trim(), a = i.split(".").map((l) => {
      const [d, f] = l.split("Z");
      return { strTime: d, time: Date.parse(d + "Z"), uuid: f };
    }), o = a[0].uuid, u = {
      ...n,
      name: n?.name ?? "parent",
      run_type: n?.run_type ?? "chain",
      start_time: n?.start_time ?? Date.now(),
      id: a.at(-1)?.uuid,
      trace_id: o,
      dotted_order: i
    };
    if (r.baggage && typeof r.baggage == "string") {
      const l = Rc.fromHeader(r.baggage);
      u.metadata = l.metadata, u.tags = l.tags, u.project_name = l.project_name, u.replicas = l.replicas;
    }
    const c = new zt(u);
    return c.distributedParentId = c.id, c;
  }
  toHeaders(t) {
    const n = {
      "langsmith-trace": this.dotted_order,
      baggage: new Rc(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (t)
      for (const [r, s] of Object.entries(n))
        t.set(r, s);
    return n;
  }
}
Object.defineProperty(zt, "sharedClient", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: null
});
function zR(e) {
  return e != null && typeof e.createChild == "function" && typeof e.postRun == "function";
}
function fx(e) {
  return typeof e == "object" && e != null && typeof e.name == "string" && e.name === "langchain_tracer";
}
function Ww(e) {
  return Array.isArray(e) && e.some((t) => fx(t));
}
function qR(e) {
  return typeof e == "object" && e != null && Array.isArray(e.handlers);
}
function BR(e) {
  const t = e?.callbacks;
  return e != null && typeof t == "object" && // Callback manager with a langchain tracer
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (Ww(t?.handlers) || // Or it's an array with a LangChainTracerLike object within it
  Ww(t));
}
function ZR() {
  const e = Yn("LANGSMITH_RUNS_ENDPOINTS");
  if (!e)
    return [];
  try {
    const t = JSON.parse(e);
    if (Array.isArray(t)) {
      const n = [];
      for (const r of t) {
        if (typeof r != "object" || r === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof r}`);
          continue;
        }
        if (typeof r.api_url != "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof r.api_url}`);
          continue;
        }
        if (typeof r.api_key != "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof r.api_key}`);
          continue;
        }
        n.push({
          apiUrl: r.api_url.replace(/\/$/, ""),
          apiKey: r.api_key
        });
      }
      return n;
    } else if (typeof t == "object" && t !== null) {
      HR(t);
      const n = [];
      for (const [r, s] of Object.entries(t)) {
        const i = r.replace(/\/$/, "");
        if (typeof s == "string")
          n.push({
            apiUrl: i,
            apiKey: s
          });
        else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${r}: expected string, got ${typeof s}`);
          continue;
        }
      }
      return n;
    } else
      return console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof t}`), [];
  } catch (t) {
    if (SR(t))
      throw t;
    return console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey"), [];
  }
}
function VR(e) {
  return e ? e.map((t) => Array.isArray(t) ? {
    projectName: t[0],
    updates: t[1]
  } : t) : ZR();
}
function HR(e) {
  if (Object.keys(e).length > 0 && Bt("ENDPOINT"))
    throw new bR();
}
var GR = {};
$e(GR, {
  BaseTracer: () => _i,
  isBaseTracer: () => Vs
});
const WR = (e) => {
  if (e)
    return e.events = e.events ?? [], e.child_runs = e.child_runs ?? [], e;
};
function Hh(e, t) {
  if (e)
    return new zt({
      ...e,
      start_time: e._serialized_start_time ?? e.start_time,
      parent_run: Hh(t),
      child_runs: e.child_runs.map((n) => Hh(n)).filter((n) => n !== void 0),
      extra: {
        ...e.extra,
        runtime: DT()
      },
      tracingEnabled: !1
    });
}
function Kf(e, t) {
  return e && !Array.isArray(e) && typeof e == "object" ? e : { [t]: e };
}
function Vs(e) {
  return typeof e._addRunToRunMap == "function";
}
var _i = class extends jo {
  /** @deprecated Use `runTreeMap` instead. */
  runMap = /* @__PURE__ */ new Map();
  runTreeMap = /* @__PURE__ */ new Map();
  usesRunTreeMap = !1;
  constructor(e) {
    super(...arguments);
  }
  copy() {
    return this;
  }
  getRunById(e) {
    if (e !== void 0)
      return this.usesRunTreeMap ? WR(this.runTreeMap.get(e)) : this.runMap.get(e);
  }
  stringifyError(e) {
    return e instanceof Error ? e.message + (e?.stack ? `

${e.stack}` : "") : typeof e == "string" ? e : `${e}`;
  }
  _addChildRun(e, t) {
    e.child_runs.push(t);
  }
  _addRunToRunMap(e) {
    const { dottedOrder: t, microsecondPrecisionDatestring: n } = dx(new Date(e.start_time).getTime(), e.id, e.execution_order), r = { ...e }, s = this.getRunById(r.parent_run_id);
    if (r.parent_run_id !== void 0 ? s ? (this._addChildRun(s, r), s.child_execution_order = Math.max(s.child_execution_order, r.child_execution_order), r.trace_id = s.trace_id, s.dotted_order !== void 0 && (r.dotted_order = [s.dotted_order, t].join("."), r._serialized_start_time = n)) : r.parent_run_id = void 0 : (r.trace_id = r.id, r.dotted_order = t, r._serialized_start_time = n), this.usesRunTreeMap) {
      const i = Hh(r, s);
      i !== void 0 && this.runTreeMap.set(r.id, i);
    } else this.runMap.set(r.id, r);
    return r;
  }
  async _endTrace(e) {
    const t = e.parent_run_id !== void 0 && this.getRunById(e.parent_run_id);
    t ? t.child_execution_order = Math.max(t.child_execution_order, e.child_execution_order) : await this.persistRun(e), await this.onRunUpdate?.(e), this.usesRunTreeMap ? this.runTreeMap.delete(e.id) : this.runMap.delete(e.id);
  }
  _getExecutionOrder(e) {
    const t = e !== void 0 && this.getRunById(e);
    return t ? t.child_execution_order + 1 : 1;
  }
  /**
  * Create and add a run to the run map for LLM start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForLLMStart(e, t, n, r, s, i, a, o) {
    const u = this._getExecutionOrder(r), c = Date.now(), l = a ? {
      ...s,
      metadata: a
    } : s, d = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: c,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(c).toISOString()
      }],
      inputs: { prompts: t },
      execution_order: u,
      child_runs: [],
      child_execution_order: u,
      run_type: "llm",
      extra: l ?? {},
      tags: i || []
    };
    return this._addRunToRunMap(d);
  }
  async handleLLMStart(e, t, n, r, s, i, a, o) {
    const u = this.getRunById(n) ?? this._createRunForLLMStart(e, t, n, r, s, i, a, o);
    return await this.onRunCreate?.(u), await this.onLLMStart?.(u), u;
  }
  /**
  * Create and add a run to the run map for chat model start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChatModelStart(e, t, n, r, s, i, a, o) {
    const u = this._getExecutionOrder(r), c = Date.now(), l = a ? {
      ...s,
      metadata: a
    } : s, d = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: c,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(c).toISOString()
      }],
      inputs: { messages: t },
      execution_order: u,
      child_runs: [],
      child_execution_order: u,
      run_type: "llm",
      extra: l ?? {},
      tags: i || []
    };
    return this._addRunToRunMap(d);
  }
  async handleChatModelStart(e, t, n, r, s, i, a, o) {
    const u = this.getRunById(n) ?? this._createRunForChatModelStart(e, t, n, r, s, i, a, o);
    return await this.onRunCreate?.(u), await this.onLLMStart?.(u), u;
  }
  async handleLLMEnd(e, t, n, r, s) {
    const i = this.getRunById(t);
    if (!i || i?.run_type !== "llm") throw new Error("No LLM run to end.");
    return i.end_time = Date.now(), i.outputs = e, i.events.push({
      name: "end",
      time: new Date(i.end_time).toISOString()
    }), i.extra = {
      ...i.extra,
      ...s
    }, await this.onLLMEnd?.(i), await this._endTrace(i), i;
  }
  async handleLLMError(e, t, n, r, s) {
    const i = this.getRunById(t);
    if (!i || i?.run_type !== "llm") throw new Error("No LLM run to end.");
    return i.end_time = Date.now(), i.error = this.stringifyError(e), i.events.push({
      name: "error",
      time: new Date(i.end_time).toISOString()
    }), i.extra = {
      ...i.extra,
      ...s
    }, await this.onLLMError?.(i), await this._endTrace(i), i;
  }
  /**
  * Create and add a run to the run map for chain start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForChainStart(e, t, n, r, s, i, a, o, u) {
    const c = this._getExecutionOrder(r), l = Date.now(), d = {
      id: n,
      name: o ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: l,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(l).toISOString()
      }],
      inputs: t,
      execution_order: c,
      child_execution_order: c,
      run_type: a ?? "chain",
      child_runs: [],
      extra: i ? {
        ...u,
        metadata: i
      } : { ...u },
      tags: s || []
    };
    return this._addRunToRunMap(d);
  }
  async handleChainStart(e, t, n, r, s, i, a, o) {
    const u = this.getRunById(n) ?? this._createRunForChainStart(e, t, n, r, s, i, a, o);
    return await this.onRunCreate?.(u), await this.onChainStart?.(u), u;
  }
  async handleChainEnd(e, t, n, r, s) {
    const i = this.getRunById(t);
    if (!i) throw new Error("No chain run to end.");
    return i.end_time = Date.now(), i.outputs = Kf(e, "output"), i.events.push({
      name: "end",
      time: new Date(i.end_time).toISOString()
    }), s?.inputs !== void 0 && (i.inputs = Kf(s.inputs, "input")), await this.onChainEnd?.(i), await this._endTrace(i), i;
  }
  async handleChainError(e, t, n, r, s) {
    const i = this.getRunById(t);
    if (!i) throw new Error("No chain run to end.");
    return i.end_time = Date.now(), i.error = this.stringifyError(e), i.events.push({
      name: "error",
      time: new Date(i.end_time).toISOString()
    }), s?.inputs !== void 0 && (i.inputs = Kf(s.inputs, "input")), await this.onChainError?.(i), await this._endTrace(i), i;
  }
  /**
  * Create and add a run to the run map for tool start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForToolStart(e, t, n, r, s, i, a) {
    const o = this._getExecutionOrder(r), u = Date.now(), c = {
      id: n,
      name: a ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: u,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { input: t },
      execution_order: o,
      child_execution_order: o,
      run_type: "tool",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: s || []
    };
    return this._addRunToRunMap(c);
  }
  async handleToolStart(e, t, n, r, s, i, a) {
    const o = this.getRunById(n) ?? this._createRunForToolStart(e, t, n, r, s, i, a);
    return await this.onRunCreate?.(o), await this.onToolStart?.(o), o;
  }
  async handleToolEnd(e, t) {
    const n = this.getRunById(t);
    if (!n || n?.run_type !== "tool") throw new Error("No tool run to end");
    return n.end_time = Date.now(), n.outputs = { output: e }, n.events.push({
      name: "end",
      time: new Date(n.end_time).toISOString()
    }), await this.onToolEnd?.(n), await this._endTrace(n), n;
  }
  async handleToolError(e, t) {
    const n = this.getRunById(t);
    if (!n || n?.run_type !== "tool") throw new Error("No tool run to end");
    return n.end_time = Date.now(), n.error = this.stringifyError(e), n.events.push({
      name: "error",
      time: new Date(n.end_time).toISOString()
    }), await this.onToolError?.(n), await this._endTrace(n), n;
  }
  async handleAgentAction(e, t) {
    const n = this.getRunById(t);
    if (!n || n?.run_type !== "chain") return;
    const r = n;
    r.actions = r.actions || [], r.actions.push(e), r.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await this.onAgentAction?.(n);
  }
  async handleAgentEnd(e, t) {
    const n = this.getRunById(t);
    !n || n?.run_type !== "chain" || (n.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action: e }
    }), await this.onAgentEnd?.(n));
  }
  /**
  * Create and add a run to the run map for retriever start events.
  * This must sometimes be done synchronously to avoid race conditions
  * when callbacks are backgrounded, so we expose it as a separate method here.
  */
  _createRunForRetrieverStart(e, t, n, r, s, i, a) {
    const o = this._getExecutionOrder(r), u = Date.now(), c = {
      id: n,
      name: a ?? e.id[e.id.length - 1],
      parent_run_id: r,
      start_time: u,
      serialized: e,
      events: [{
        name: "start",
        time: new Date(u).toISOString()
      }],
      inputs: { query: t },
      execution_order: o,
      child_execution_order: o,
      run_type: "retriever",
      child_runs: [],
      extra: i ? { metadata: i } : {},
      tags: s || []
    };
    return this._addRunToRunMap(c);
  }
  async handleRetrieverStart(e, t, n, r, s, i, a) {
    const o = this.getRunById(n) ?? this._createRunForRetrieverStart(e, t, n, r, s, i, a);
    return await this.onRunCreate?.(o), await this.onRetrieverStart?.(o), o;
  }
  async handleRetrieverEnd(e, t) {
    const n = this.getRunById(t);
    if (!n || n?.run_type !== "retriever") throw new Error("No retriever run to end");
    return n.end_time = Date.now(), n.outputs = { documents: e }, n.events.push({
      name: "end",
      time: new Date(n.end_time).toISOString()
    }), await this.onRetrieverEnd?.(n), await this._endTrace(n), n;
  }
  async handleRetrieverError(e, t) {
    const n = this.getRunById(t);
    if (!n || n?.run_type !== "retriever") throw new Error("No retriever run to end");
    return n.end_time = Date.now(), n.error = this.stringifyError(e), n.events.push({
      name: "error",
      time: new Date(n.end_time).toISOString()
    }), await this.onRetrieverError?.(n), await this._endTrace(n), n;
  }
  async handleText(e, t) {
    const n = this.getRunById(t);
    !n || n?.run_type !== "chain" || (n.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: e }
    }), await this.onText?.(n));
  }
  async handleLLMNewToken(e, t, n, r, s, i) {
    const a = this.getRunById(n);
    if (!a || a?.run_type !== "llm") throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return a.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: {
        token: e,
        idx: t,
        chunk: i?.chunk
      }
    }), await this.onLLMNewToken?.(a, e, { chunk: i?.chunk }), a;
  }
}, dc = { exports: {} };
dc.exports;
var Jw;
function JR() {
  return Jw || (Jw = 1, (function(e) {
    const n = (i = 0) => (a) => `\x1B[${38 + i};5;${a}m`, r = (i = 0) => (a, o, u) => `\x1B[${38 + i};2;${a};${o};${u}m`;
    function s() {
      const i = /* @__PURE__ */ new Map(), a = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      a.color.gray = a.color.blackBright, a.bgColor.bgGray = a.bgColor.bgBlackBright, a.color.grey = a.color.blackBright, a.bgColor.bgGrey = a.bgColor.bgBlackBright;
      for (const [o, u] of Object.entries(a)) {
        for (const [c, l] of Object.entries(u))
          a[c] = {
            open: `\x1B[${l[0]}m`,
            close: `\x1B[${l[1]}m`
          }, u[c] = a[c], i.set(l[0], l[1]);
        Object.defineProperty(a, o, {
          value: u,
          enumerable: !1
        });
      }
      return Object.defineProperty(a, "codes", {
        value: i,
        enumerable: !1
      }), a.color.close = "\x1B[39m", a.bgColor.close = "\x1B[49m", a.color.ansi256 = n(), a.color.ansi16m = r(), a.bgColor.ansi256 = n(10), a.bgColor.ansi16m = r(10), Object.defineProperties(a, {
        rgbToAnsi256: {
          value: (o, u, c) => o === u && u === c ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(u / 255 * 5) + Math.round(c / 255 * 5),
          enumerable: !1
        },
        hexToRgb: {
          value: (o) => {
            const u = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(o.toString(16));
            if (!u)
              return [0, 0, 0];
            let { colorString: c } = u.groups;
            c.length === 3 && (c = c.split("").map((d) => d + d).join(""));
            const l = Number.parseInt(c, 16);
            return [
              l >> 16 & 255,
              l >> 8 & 255,
              l & 255
            ];
          },
          enumerable: !1
        },
        hexToAnsi256: {
          value: (o) => a.rgbToAnsi256(...a.hexToRgb(o)),
          enumerable: !1
        }
      }), a;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: s
    });
  })(dc)), dc.exports;
}
var KR = JR();
const hx = /* @__PURE__ */ Zr(KR);
var YR = {};
$e(YR, { ConsoleCallbackHandler: () => Gh });
function $t(e, t) {
  return `${e.open}${t}${e.close}`;
}
function pn(e, t) {
  try {
    return JSON.stringify(e, null, 2);
  } catch {
    return t;
  }
}
function Kw(e) {
  return typeof e == "string" ? e.trim() : e == null ? e : pn(e, e.toString());
}
function xr(e) {
  if (!e.end_time) return "";
  const t = e.end_time - e.start_time;
  return t < 1e3 ? `${t}ms` : `${(t / 1e3).toFixed(2)}s`;
}
const { color: Ut } = hx;
var Gh = class extends _i {
  name = "console_callback_handler";
  /**
  * Method used to persist the run. In this case, it simply returns a
  * resolved promise as there's no persistence logic.
  * @param _run The run to persist.
  * @returns A resolved promise.
  */
  persistRun(e) {
    return Promise.resolve();
  }
  /**
  * Method used to get all the parent runs of a given run.
  * @param run The run whose parents are to be retrieved.
  * @returns An array of parent runs.
  */
  getParents(e) {
    const t = [];
    let n = e;
    for (; n.parent_run_id; ) {
      const r = this.runMap.get(n.parent_run_id);
      if (r)
        t.push(r), n = r;
      else break;
    }
    return t;
  }
  /**
  * Method used to get a string representation of the run's lineage, which
  * is used in logging.
  * @param run The run whose lineage is to be retrieved.
  * @returns A string representation of the run's lineage.
  */
  getBreadcrumbs(e) {
    const n = [...this.getParents(e).reverse(), e].map((r, s, i) => {
      const a = `${r.execution_order}:${r.run_type}:${r.name}`;
      return s === i.length - 1 ? $t(hx.bold, a) : a;
    }).join(" > ");
    return $t(Ut.grey, n);
  }
  /**
  * Method used to log the start of a chain run.
  * @param run The chain run that has started.
  * @returns void
  */
  onChainStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.green, "[chain/start]")} [${t}] Entering Chain run with input: ${pn(e.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a chain run.
  * @param run The chain run that has ended.
  * @returns void
  */
  onChainEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.cyan, "[chain/end]")} [${t}] [${xr(e)}] Exiting Chain run with output: ${pn(e.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a chain run.
  * @param run The chain run that has errored.
  * @returns void
  */
  onChainError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.red, "[chain/error]")} [${t}] [${xr(e)}] Chain run errored with error: ${pn(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of an LLM run.
  * @param run The LLM run that has started.
  * @returns void
  */
  onLLMStart(e) {
    const t = this.getBreadcrumbs(e), n = "prompts" in e.inputs ? { prompts: e.inputs.prompts.map((r) => r.trim()) } : e.inputs;
    console.log(`${$t(Ut.green, "[llm/start]")} [${t}] Entering LLM run with input: ${pn(n, "[inputs]")}`);
  }
  /**
  * Method used to log the end of an LLM run.
  * @param run The LLM run that has ended.
  * @returns void
  */
  onLLMEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.cyan, "[llm/end]")} [${t}] [${xr(e)}] Exiting LLM run with output: ${pn(e.outputs, "[response]")}`);
  }
  /**
  * Method used to log any errors of an LLM run.
  * @param run The LLM run that has errored.
  * @returns void
  */
  onLLMError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.red, "[llm/error]")} [${t}] [${xr(e)}] LLM run errored with error: ${pn(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a tool run.
  * @param run The tool run that has started.
  * @returns void
  */
  onToolStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.green, "[tool/start]")} [${t}] Entering Tool run with input: "${Kw(e.inputs.input)}"`);
  }
  /**
  * Method used to log the end of a tool run.
  * @param run The tool run that has ended.
  * @returns void
  */
  onToolEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.cyan, "[tool/end]")} [${t}] [${xr(e)}] Exiting Tool run with output: "${Kw(e.outputs?.output)}"`);
  }
  /**
  * Method used to log any errors of a tool run.
  * @param run The tool run that has errored.
  * @returns void
  */
  onToolError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.red, "[tool/error]")} [${t}] [${xr(e)}] Tool run errored with error: ${pn(e.error, "[error]")}`);
  }
  /**
  * Method used to log the start of a retriever run.
  * @param run The retriever run that has started.
  * @returns void
  */
  onRetrieverStart(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.green, "[retriever/start]")} [${t}] Entering Retriever run with input: ${pn(e.inputs, "[inputs]")}`);
  }
  /**
  * Method used to log the end of a retriever run.
  * @param run The retriever run that has ended.
  * @returns void
  */
  onRetrieverEnd(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.cyan, "[retriever/end]")} [${t}] [${xr(e)}] Exiting Retriever run with output: ${pn(e.outputs, "[outputs]")}`);
  }
  /**
  * Method used to log any errors of a retriever run.
  * @param run The retriever run that has errored.
  * @returns void
  */
  onRetrieverError(e) {
    const t = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.red, "[retriever/error]")} [${t}] [${xr(e)}] Retriever run errored with error: ${pn(e.error, "[error]")}`);
  }
  /**
  * Method used to log the action selected by the agent.
  * @param run The run in which the agent action occurred.
  * @returns void
  */
  onAgentAction(e) {
    const t = e, n = this.getBreadcrumbs(e);
    console.log(`${$t(Ut.blue, "[agent/action]")} [${n}] Agent selected action: ${pn(t.actions[t.actions.length - 1], "[action]")}`);
  }
};
let Yf;
const px = () => {
  if (Yf === void 0) {
    const e = on("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: !0 } : {};
    Yf = new fo(e);
  }
  return Yf;
};
let XR = class {
  getStore() {
  }
  run(t, n) {
    return n();
  }
};
const Xf = /* @__PURE__ */ Symbol.for("ls:tracing_async_local_storage"), QR = new XR();
let eP = class {
  getInstance() {
    return globalThis[Xf] ?? QR;
  }
  initializeGlobalInstance(t) {
    globalThis[Xf] === void 0 && (globalThis[Xf] = t);
  }
};
const tP = new eP();
function nP(e = !1) {
  const t = tP.getInstance().getStore();
  if (!e && t === void 0)
    throw new Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  return t;
}
function Rm(e) {
  return typeof e == "function" && "langsmith:traceable" in e;
}
var rP = {};
$e(rP, { LangChainTracer: () => fc });
function sP(e) {
  let t;
  for (const n of e) for (const r of n) rt.isInstance(r.message) && r.message.usage_metadata !== void 0 && (t = pm(t, r.message.usage_metadata));
  return t;
}
var fc = class mx extends _i {
  name = "langchain_tracer";
  projectName;
  exampleId;
  client;
  replicas;
  usesRunTreeMap = !0;
  constructor(t = {}) {
    super(t);
    const { exampleId: n, projectName: r, client: s, replicas: i } = t;
    this.projectName = r ?? WT(), this.replicas = i, this.exampleId = n, this.client = s ?? px();
    const a = mx.getTraceableRunTree();
    a && this.updateFromRunTree(a);
  }
  async persistRun(t) {
  }
  async onRunCreate(t) {
    t.extra?.lc_defers_inputs || await this.getRunTreeWithTracingConfig(t.id)?.postRun();
  }
  async onRunUpdate(t) {
    const n = this.getRunTreeWithTracingConfig(t.id);
    t.extra?.lc_defers_inputs ? await n?.postRun() : await n?.patchRun();
  }
  onLLMEnd(t) {
    const n = t.outputs;
    if (n?.generations) {
      const r = sP(n.generations);
      if (r !== void 0) {
        t.extra = t.extra ?? {};
        const s = t.extra.metadata ?? {};
        s.usage_metadata = r, t.extra.metadata = s;
      }
    }
  }
  getRun(t) {
    return this.runTreeMap.get(t);
  }
  updateFromRunTree(t) {
    this.runTreeMap.set(t.id, t);
    let n = t;
    const r = /* @__PURE__ */ new Set();
    for (; n.parent_run && !(r.has(n.id) || (r.add(n.id), !n.parent_run)); )
      n = n.parent_run;
    r.clear();
    const s = [n];
    for (; s.length > 0; ) {
      const i = s.shift();
      !i || r.has(i.id) || (r.add(i.id), this.runTreeMap.set(i.id, i), i.child_runs && s.push(...i.child_runs));
    }
    this.client = t.client ?? this.client, this.replicas = t.replicas ?? this.replicas, this.projectName = t.project_name ?? this.projectName, this.exampleId = t.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(t) {
    const n = this.runTreeMap.get(t);
    if (n)
      return new zt({
        ...n,
        client: this.client,
        project_name: this.projectName,
        replicas: this.replicas,
        reference_example_id: this.exampleId,
        tracingEnabled: !0
      });
  }
  static getTraceableRunTree() {
    try {
      return nP(!0);
    } catch {
      return;
    }
  }
};
let ms;
function iP() {
  const e = "default" in cr ? cr.default : cr;
  return new e({
    autoStart: !0,
    concurrency: 1
  });
}
function aP() {
  return typeof ms > "u" && (ms = iP()), ms;
}
async function st(e, t) {
  if (t === !0) {
    const n = lo();
    n !== void 0 ? await n.run(void 0, async () => e()) : await e();
  } else
    ms = aP(), ms.add(async () => {
      const n = lo();
      n !== void 0 ? await n.run(void 0, async () => e()) : await e();
    });
}
async function oP() {
  const e = px();
  await Promise.allSettled([typeof ms < "u" ? ms.onIdle() : Promise.resolve(), e.awaitPendingTraceBatches()]);
}
var uP = {};
$e(uP, {
  awaitAllCallbacks: () => oP,
  consumeCallback: () => st
});
const cP = (e) => !![
  "LANGSMITH_TRACING_V2",
  "LANGCHAIN_TRACING_V2",
  "LANGSMITH_TRACING",
  "LANGCHAIN_TRACING"
].find((n) => on(n) === "true");
function gx(e) {
  const t = lo();
  return t === void 0 ? void 0 : t.getStore()?.[ro]?.[e];
}
const lP = /* @__PURE__ */ Symbol("lc:configure_hooks"), dP = () => gx(lP) || [];
var fP = {};
$e(fP, {
  BaseCallbackManager: () => _x,
  BaseRunManager: () => Do,
  CallbackManager: () => Vt,
  CallbackManagerForChainRun: () => wx,
  CallbackManagerForLLMRun: () => Wh,
  CallbackManagerForRetrieverRun: () => yx,
  CallbackManagerForToolRun: () => vx,
  ensureHandler: () => ho,
  parseCallbackConfigArg: () => Al
});
function Al(e) {
  return e ? Array.isArray(e) || "name" in e ? { callbacks: e } : e : {};
}
var _x = class {
  setHandler(e) {
    return this.setHandlers([e]);
  }
}, Do = class {
  constructor(e, t, n, r, s, i, a, o) {
    this.runId = e, this.handlers = t, this.inheritableHandlers = n, this.tags = r, this.inheritableTags = s, this.metadata = i, this.inheritableMetadata = a, this._parentRunId = o;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      try {
        await t.handleText?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleText: ${n}`), t.raiseError) throw n;
      }
    }, t.awaitHandlers)));
  }
  async handleCustomEvent(e, t, n, r, s) {
    await Promise.all(this.handlers.map((i) => st(async () => {
      try {
        await i.handleCustomEvent?.(e, t, this.runId, this.tags, this.metadata);
      } catch (a) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleCustomEvent: ${a}`), i.raiseError) throw a;
      }
    }, i.awaitHandlers)));
  }
}, yx = class extends Do {
  getChild(e) {
    const t = new Vt(this.runId);
    return t.setHandlers(this.inheritableHandlers), t.addTags(this.inheritableTags), t.addMetadata(this.inheritableMetadata), e && t.addTags([e], !1), t;
  }
  async handleRetrieverEnd(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      if (!t.ignoreRetriever) try {
        await t.handleRetrieverEnd?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleRetriever`), t.raiseError) throw n;
      }
    }, t.awaitHandlers)));
  }
  async handleRetrieverError(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      if (!t.ignoreRetriever) try {
        await t.handleRetrieverError?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleRetrieverError: ${n}`), t.raiseError) throw e;
      }
    }, t.awaitHandlers)));
  }
}, Wh = class extends Do {
  async handleLLMNewToken(e, t, n, r, s, i) {
    await Promise.all(this.handlers.map((a) => st(async () => {
      if (!a.ignoreLLM) try {
        await a.handleLLMNewToken?.(e, t ?? {
          prompt: 0,
          completion: 0
        }, this.runId, this._parentRunId, this.tags, i);
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMNewToken: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  async handleLLMError(e, t, n, r, s) {
    await Promise.all(this.handlers.map((i) => st(async () => {
      if (!i.ignoreLLM) try {
        await i.handleLLMError?.(e, this.runId, this._parentRunId, this.tags, s);
      } catch (a) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleLLMError: ${a}`), i.raiseError) throw a;
      }
    }, i.awaitHandlers)));
  }
  async handleLLMEnd(e, t, n, r, s) {
    await Promise.all(this.handlers.map((i) => st(async () => {
      if (!i.ignoreLLM) try {
        await i.handleLLMEnd?.(e, this.runId, this._parentRunId, this.tags, s);
      } catch (a) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleLLMEnd: ${a}`), i.raiseError) throw a;
      }
    }, i.awaitHandlers)));
  }
}, wx = class extends Do {
  getChild(e) {
    const t = new Vt(this.runId);
    return t.setHandlers(this.inheritableHandlers), t.addTags(this.inheritableTags), t.addMetadata(this.inheritableMetadata), e && t.addTags([e], !1), t;
  }
  async handleChainError(e, t, n, r, s) {
    await Promise.all(this.handlers.map((i) => st(async () => {
      if (!i.ignoreChain) try {
        await i.handleChainError?.(e, this.runId, this._parentRunId, this.tags, s);
      } catch (a) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleChainError: ${a}`), i.raiseError) throw a;
      }
    }, i.awaitHandlers)));
  }
  async handleChainEnd(e, t, n, r, s) {
    await Promise.all(this.handlers.map((i) => st(async () => {
      if (!i.ignoreChain) try {
        await i.handleChainEnd?.(e, this.runId, this._parentRunId, this.tags, s);
      } catch (a) {
        if ((i.raiseError ? console.error : console.warn)(`Error in handler ${i.constructor.name}, handleChainEnd: ${a}`), i.raiseError) throw a;
      }
    }, i.awaitHandlers)));
  }
  async handleAgentAction(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      if (!t.ignoreAgent) try {
        await t.handleAgentAction?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleAgentAction: ${n}`), t.raiseError) throw n;
      }
    }, t.awaitHandlers)));
  }
  async handleAgentEnd(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      if (!t.ignoreAgent) try {
        await t.handleAgentEnd?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleAgentEnd: ${n}`), t.raiseError) throw n;
      }
    }, t.awaitHandlers)));
  }
}, vx = class extends Do {
  getChild(e) {
    const t = new Vt(this.runId);
    return t.setHandlers(this.inheritableHandlers), t.addTags(this.inheritableTags), t.addMetadata(this.inheritableMetadata), e && t.addTags([e], !1), t;
  }
  async handleToolError(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      if (!t.ignoreAgent) try {
        await t.handleToolError?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleToolError: ${n}`), t.raiseError) throw n;
      }
    }, t.awaitHandlers)));
  }
  async handleToolEnd(e) {
    await Promise.all(this.handlers.map((t) => st(async () => {
      if (!t.ignoreAgent) try {
        await t.handleToolEnd?.(e, this.runId, this._parentRunId, this.tags);
      } catch (n) {
        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleToolEnd: ${n}`), t.raiseError) throw n;
      }
    }, t.awaitHandlers)));
  }
}, Vt = class Za extends _x {
  handlers = [];
  inheritableHandlers = [];
  tags = [];
  inheritableTags = [];
  metadata = {};
  inheritableMetadata = {};
  name = "callback_manager";
  _parentRunId;
  constructor(t, n) {
    super(), this.handlers = n?.handlers ?? this.handlers, this.inheritableHandlers = n?.inheritableHandlers ?? this.inheritableHandlers, this.tags = n?.tags ?? this.tags, this.inheritableTags = n?.inheritableTags ?? this.inheritableTags, this.metadata = n?.metadata ?? this.metadata, this.inheritableMetadata = n?.inheritableMetadata ?? this.inheritableMetadata, this._parentRunId = t;
  }
  /**
  * Gets the parent run ID, if any.
  *
  * @returns The parent run ID.
  */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(t, n, r = void 0, s = void 0, i = void 0, a = void 0, o = void 0, u = void 0) {
    return Promise.all(n.map(async (c, l) => {
      const d = l === 0 && r ? r : ss();
      return await Promise.all(this.handlers.map((f) => {
        if (!f.ignoreLLM)
          return Vs(f) && f._createRunForLLMStart(t, [c], d, this._parentRunId, i, this.tags, this.metadata, u), st(async () => {
            try {
              await f.handleLLMStart?.(t, [c], d, this._parentRunId, i, this.tags, this.metadata, u);
            } catch (h) {
              if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${h}`), f.raiseError) throw h;
            }
          }, f.awaitHandlers);
      })), new Wh(d, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(t, n, r = void 0, s = void 0, i = void 0, a = void 0, o = void 0, u = void 0) {
    return Promise.all(n.map(async (c, l) => {
      const d = l === 0 && r ? r : ss();
      return await Promise.all(this.handlers.map((f) => {
        if (!f.ignoreLLM)
          return Vs(f) && f._createRunForChatModelStart(t, [c], d, this._parentRunId, i, this.tags, this.metadata, u), st(async () => {
            try {
              if (f.handleChatModelStart) await f.handleChatModelStart?.(t, [c], d, this._parentRunId, i, this.tags, this.metadata, u);
              else if (f.handleLLMStart) {
                const h = wm(c);
                await f.handleLLMStart?.(t, [h], d, this._parentRunId, i, this.tags, this.metadata, u);
              }
            } catch (h) {
              if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${h}`), f.raiseError) throw h;
            }
          }, f.awaitHandlers);
      })), new Wh(d, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(t, n, r = ss(), s = void 0, i = void 0, a = void 0, o = void 0, u = void 0, c = void 0) {
    return await Promise.all(this.handlers.map((l) => {
      if (!l.ignoreChain)
        return Vs(l) && l._createRunForChainStart(t, n, r, this._parentRunId, this.tags, this.metadata, s, o, c), st(async () => {
          try {
            await l.handleChainStart?.(t, n, r, this._parentRunId, this.tags, this.metadata, s, o, c);
          } catch (d) {
            if ((l.raiseError ? console.error : console.warn)(`Error in handler ${l.constructor.name}, handleChainStart: ${d}`), l.raiseError) throw d;
          }
        }, l.awaitHandlers);
    })), new wx(r, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(t, n, r = ss(), s = void 0, i = void 0, a = void 0, o = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreAgent)
        return Vs(u) && u._createRunForToolStart(t, n, r, this._parentRunId, this.tags, this.metadata, o), st(async () => {
          try {
            await u.handleToolStart?.(t, n, r, this._parentRunId, this.tags, this.metadata, o);
          } catch (c) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleToolStart: ${c}`), u.raiseError) throw c;
          }
        }, u.awaitHandlers);
    })), new vx(r, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(t, n, r = ss(), s = void 0, i = void 0, a = void 0, o = void 0) {
    return await Promise.all(this.handlers.map((u) => {
      if (!u.ignoreRetriever)
        return Vs(u) && u._createRunForRetrieverStart(t, n, r, this._parentRunId, this.tags, this.metadata, o), st(async () => {
          try {
            await u.handleRetrieverStart?.(t, n, r, this._parentRunId, this.tags, this.metadata, o);
          } catch (c) {
            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleRetrieverStart: ${c}`), u.raiseError) throw c;
          }
        }, u.awaitHandlers);
    })), new yx(r, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(t, n, r, s, i) {
    await Promise.all(this.handlers.map((a) => st(async () => {
      if (!a.ignoreCustomEvent) try {
        await a.handleCustomEvent?.(t, n, r, this.tags, this.metadata);
      } catch (o) {
        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleCustomEvent: ${o}`), a.raiseError) throw o;
      }
    }, a.awaitHandlers)));
  }
  addHandler(t, n = !0) {
    this.handlers.push(t), n && this.inheritableHandlers.push(t);
  }
  removeHandler(t) {
    this.handlers = this.handlers.filter((n) => n !== t), this.inheritableHandlers = this.inheritableHandlers.filter((n) => n !== t);
  }
  setHandlers(t, n = !0) {
    this.handlers = [], this.inheritableHandlers = [];
    for (const r of t) this.addHandler(r, n);
  }
  addTags(t, n = !0) {
    this.removeTags(t), this.tags.push(...t), n && this.inheritableTags.push(...t);
  }
  removeTags(t) {
    this.tags = this.tags.filter((n) => !t.includes(n)), this.inheritableTags = this.inheritableTags.filter((n) => !t.includes(n));
  }
  addMetadata(t, n = !0) {
    this.metadata = {
      ...this.metadata,
      ...t
    }, n && (this.inheritableMetadata = {
      ...this.inheritableMetadata,
      ...t
    });
  }
  removeMetadata(t) {
    for (const n of Object.keys(t))
      delete this.metadata[n], delete this.inheritableMetadata[n];
  }
  copy(t = [], n = !0) {
    const r = new Za(this._parentRunId);
    for (const s of this.handlers) {
      const i = this.inheritableHandlers.includes(s);
      r.addHandler(s, i);
    }
    for (const s of this.tags) {
      const i = this.inheritableTags.includes(s);
      r.addTags([s], i);
    }
    for (const s of Object.keys(this.metadata)) {
      const i = Object.keys(this.inheritableMetadata).includes(s);
      r.addMetadata({ [s]: this.metadata[s] }, i);
    }
    for (const s of t)
      r.handlers.filter((i) => i.name === "console_callback_handler").some((i) => i.name === s.name) || r.addHandler(s, n);
    return r;
  }
  static fromHandlers(t) {
    class n extends jo {
      name = ss();
      constructor() {
        super(), Object.assign(this, t);
      }
    }
    const r = new this();
    return r.addHandler(new n()), r;
  }
  static configure(t, n, r, s, i, a, o) {
    return this._configureSync(t, n, r, s, i, a, o);
  }
  static _configureSync(t, n, r, s, i, a, o) {
    let u;
    (t || n) && (Array.isArray(t) || !t ? (u = new Za(), u.setHandlers(t?.map(ho) ?? [], !0)) : u = t, u = u.copy(Array.isArray(n) ? n.map(ho) : n?.handlers, !1));
    const c = on("LANGCHAIN_VERBOSE") === "true" || o?.verbose, l = fc.getTraceableRunTree()?.tracingEnabled || cP(), d = l || (on("LANGCHAIN_TRACING") ?? !1);
    if (c || d) {
      if (u || (u = new Za()), c && !u.handlers.some((f) => f.name === Gh.prototype.name)) {
        const f = new Gh();
        u.addHandler(f, !0);
      }
      if (d && !u.handlers.some((f) => f.name === "langchain_tracer") && l) {
        const f = new fc();
        u.addHandler(f, !0);
      }
      if (l) {
        const f = fc.getTraceableRunTree();
        f && u._parentRunId === void 0 && (u._parentRunId = f.id, u.handlers.find((p) => p.name === "langchain_tracer")?.updateFromRunTree(f));
      }
    }
    for (const { contextVar: f, inheritable: h = !0, handlerClass: p, envVar: g } of dP()) {
      const m = g && on(g) === "true" && p;
      let _;
      const y = f !== void 0 ? gx(f) : void 0;
      y && BT(y) ? _ = y : m && (_ = new p({})), _ !== void 0 && (u || (u = new Za()), u.handlers.some((b) => b.name === _.name) || u.addHandler(_, h));
    }
    return (r || s) && u && (u.addTags(r ?? []), u.addTags(s ?? [], !1)), (i || a) && u && (u.addMetadata(i ?? {}), u.addMetadata(a ?? {}, !1)), u;
  }
};
function ho(e) {
  return "name" in e ? e : jo.fromMethods(e);
}
var bx = class {
  getStore() {
  }
  run(e, t) {
    return t();
  }
  enterWith(e) {
  }
};
const hP = new bx(), Yw = /* @__PURE__ */ Symbol.for("lc:child_config");
var pP = class {
  getInstance() {
    return lo() ?? hP;
  }
  getRunnableConfig() {
    return this.getInstance().getStore()?.extra?.[Yw];
  }
  runWithConfig(e, t, n) {
    const r = Vt._configureSync(e?.callbacks, void 0, e?.tags, void 0, e?.metadata), s = this.getInstance(), i = s.getStore(), a = r?.getParentRunId(), o = r?.handlers?.find((c) => c?.name === "langchain_tracer");
    let u;
    return o && a ? u = o.getRunTreeWithTracingConfig(a) : n || (u = new zt({
      name: "<runnable_lambda>",
      tracingEnabled: !1
    })), u && (u.extra = {
      ...u.extra,
      [Yw]: e
    }), i !== void 0 && i[ro] !== void 0 && (u === void 0 && (u = {}), u[ro] = i[ro]), s.run(u, t);
  }
  initializeGlobalInstance(e) {
    lo() === void 0 && KA(e);
  }
};
const Mn = new pP();
var mP = {};
$e(mP, {
  AsyncLocalStorageProviderSingleton: () => Mn,
  MockAsyncLocalStorage: () => bx,
  _CONTEXT_VARIABLES_KEY: () => ro
});
const Qf = 25;
async function un(e) {
  return Vt._configureSync(e?.callbacks, void 0, e?.tags, void 0, e?.metadata);
}
function Pc(...e) {
  const t = {};
  for (const n of e.filter((r) => !!r)) for (const r of Object.keys(n)) if (r === "metadata") t[r] = {
    ...t[r],
    ...n[r]
  };
  else if (r === "tags") {
    const s = t[r] ?? [];
    t[r] = [...new Set(s.concat(n[r] ?? []))];
  } else if (r === "configurable") t[r] = {
    ...t[r],
    ...n[r]
  };
  else if (r === "timeout")
    t.timeout === void 0 ? t.timeout = n.timeout : n.timeout !== void 0 && (t.timeout = Math.min(t.timeout, n.timeout));
  else if (r === "signal")
    t.signal === void 0 ? t.signal = n.signal : n.signal !== void 0 && ("any" in AbortSignal ? t.signal = AbortSignal.any([t.signal, n.signal]) : t.signal = n.signal);
  else if (r === "callbacks") {
    const s = t.callbacks, i = n.callbacks;
    if (Array.isArray(i)) if (!s) t.callbacks = i;
    else if (Array.isArray(s)) t.callbacks = s.concat(i);
    else {
      const a = s.copy();
      for (const o of i) a.addHandler(ho(o), !0);
      t.callbacks = a;
    }
    else if (i) if (!s) t.callbacks = i;
    else if (Array.isArray(s)) {
      const a = i.copy();
      for (const o of s) a.addHandler(ho(o), !0);
      t.callbacks = a;
    } else t.callbacks = new Vt(i._parentRunId, {
      handlers: s.handlers.concat(i.handlers),
      inheritableHandlers: s.inheritableHandlers.concat(i.inheritableHandlers),
      tags: Array.from(new Set(s.tags.concat(i.tags))),
      inheritableTags: Array.from(new Set(s.inheritableTags.concat(i.inheritableTags))),
      metadata: {
        ...s.metadata,
        ...i.metadata
      }
    });
  } else {
    const s = r;
    t[s] = n[s] ?? t[s];
  }
  return t;
}
const gP = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean"
]);
function Ne(e) {
  const t = Mn.getRunnableConfig();
  let n = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (t) {
    const { runId: r, runName: s, ...i } = t;
    n = Object.entries(i).reduce((a, [o, u]) => (u !== void 0 && (a[o] = u), a), n);
  }
  if (e && (n = Object.entries(e).reduce((r, [s, i]) => (i !== void 0 && (r[s] = i), r), n)), n?.configurable)
    for (const r of Object.keys(n.configurable)) gP.has(typeof n.configurable[r]) && !n.metadata?.[r] && (n.metadata || (n.metadata = {}), n.metadata[r] = n.configurable[r]);
  if (n.timeout !== void 0) {
    if (n.timeout <= 0) throw new Error("Timeout must be a positive number");
    const r = n.timeout, s = AbortSignal.timeout(r);
    n.metadata || (n.metadata = {}), n.metadata.timeoutMs === void 0 && (n.metadata.timeoutMs = r), n.signal !== void 0 ? "any" in AbortSignal && (n.signal = AbortSignal.any([n.signal, s])) : n.signal = s, delete n.timeout;
  }
  return n;
}
function Ze(e = {}, { callbacks: t, maxConcurrency: n, recursionLimit: r, runName: s, configurable: i, runId: a } = {}) {
  const o = Ne(e);
  return t !== void 0 && (delete o.runName, o.callbacks = t), r !== void 0 && (o.recursionLimit = r), n !== void 0 && (o.maxConcurrency = n), s !== void 0 && (o.runName = s), i !== void 0 && (o.configurable = {
    ...o.configurable,
    ...i
  }), a !== void 0 && delete o.runId, o;
}
function dr(e) {
  if (e)
    return {
      configurable: e.configurable,
      recursionLimit: e.recursionLimit,
      callbacks: e.callbacks,
      tags: e.tags,
      metadata: e.metadata,
      maxConcurrency: e.maxConcurrency,
      timeout: e.timeout,
      signal: e.signal,
      store: e.store
    };
}
async function fr(e, t) {
  if (t === void 0) return e;
  let n;
  return Promise.race([e.catch((r) => {
    if (!t?.aborted)
      throw r;
  }), new Promise((r, s) => {
    n = () => {
      s(po(t));
    }, t.addEventListener("abort", n), t.aborted && s(po(t));
  })]).finally(() => t.removeEventListener("abort", n));
}
function po(e) {
  return e?.reason instanceof Error ? e.reason : typeof e?.reason == "string" ? new Error(e.reason) : /* @__PURE__ */ new Error("Aborted");
}
var _P = {};
$e(_P, {
  AsyncGeneratorWithSetup: () => Os,
  IterableReadableStream: () => jn,
  atee: () => Pm,
  concat: () => hr,
  pipeGeneratorWithSetup: () => Sx
});
var jn = class Jh extends ReadableStream {
  reader;
  ensureReader() {
    this.reader || (this.reader = this.getReader());
  }
  async next() {
    this.ensureReader();
    try {
      const t = await this.reader.read();
      return t.done ? (this.reader.releaseLock(), {
        done: !0,
        value: void 0
      }) : {
        done: !1,
        value: t.value
      };
    } catch (t) {
      throw this.reader.releaseLock(), t;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      const t = this.reader.cancel();
      this.reader.releaseLock(), await t;
    }
    return {
      done: !0,
      value: void 0
    };
  }
  async throw(t) {
    if (this.ensureReader(), this.locked) {
      const n = this.reader.cancel();
      this.reader.releaseLock(), await n;
    }
    throw t;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(t) {
    const n = t.getReader();
    return new Jh({
      start(r) {
        return s();
        function s() {
          return n.read().then(({ done: i, value: a }) => {
            if (i) {
              r.close();
              return;
            }
            return r.enqueue(a), s();
          });
        }
      },
      cancel() {
        n.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(t) {
    return new Jh({
      async pull(n) {
        const { value: r, done: s } = await t.next();
        s && n.close(), n.enqueue(r);
      },
      async cancel(n) {
        await t.return(n);
      }
    });
  }
};
function Pm(e, t = 2) {
  const n = Array.from({ length: t }, () => []);
  return n.map(async function* (s) {
    for (; ; ) if (s.length === 0) {
      const i = await e.next();
      for (const a of n) a.push(i);
    } else {
      if (s[0].done) return;
      yield s.shift().value;
    }
  });
}
function hr(e, t) {
  if (Array.isArray(e) && Array.isArray(t)) return e.concat(t);
  if (typeof e == "string" && typeof t == "string") return e + t;
  if (typeof e == "number" && typeof t == "number") return e + t;
  if ("concat" in e && typeof e.concat == "function") return e.concat(t);
  if (typeof e == "object" && typeof t == "object") {
    const n = { ...e };
    for (const [r, s] of Object.entries(t)) r in n && !Array.isArray(n[r]) ? n[r] = hr(n[r], s) : n[r] = s;
    return n;
  } else throw new Error(`Cannot concat ${typeof e} and ${typeof t}`);
}
var Os = class {
  generator;
  setup;
  config;
  signal;
  firstResult;
  firstResultUsed = !1;
  constructor(e) {
    this.generator = e.generator, this.config = e.config, this.signal = e.signal ?? this.config?.signal, this.setup = new Promise((t, n) => {
      Mn.runWithConfig(dr(e.config), async () => {
        this.firstResult = e.generator.next(), e.startSetup ? this.firstResult.then(e.startSetup).then(t, n) : this.firstResult.then((r) => t(void 0), n);
      }, !0);
    });
  }
  async next(...e) {
    return this.signal?.throwIfAborted(), this.firstResultUsed ? Mn.runWithConfig(dr(this.config), this.signal ? async () => fr(this.generator.next(...e), this.signal) : async () => this.generator.next(...e), !0) : (this.firstResultUsed = !0, this.firstResult);
  }
  async return(e) {
    return this.generator.return(e);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function Sx(e, t, n, r, ...s) {
  const i = new Os({
    generator: t,
    startSetup: n,
    signal: r
  }), a = await i.setup;
  return {
    output: e(i, a, ...s),
    setup: a
  };
}
const yP = Object.prototype.hasOwnProperty;
function Kh(e, t) {
  return yP.call(e, t);
}
function Yh(e) {
  if (Array.isArray(e)) {
    const n = new Array(e.length);
    for (let r = 0; r < n.length; r++) n[r] = "" + r;
    return n;
  }
  if (Object.keys) return Object.keys(e);
  let t = [];
  for (let n in e) Kh(e, n) && t.push(n);
  return t;
}
function $n(e) {
  switch (typeof e) {
    case "object":
      return JSON.parse(JSON.stringify(e));
    case "undefined":
      return null;
    default:
      return e;
  }
}
function Xh(e) {
  let t = 0;
  const n = e.length;
  let r;
  for (; t < n; ) {
    if (r = e.charCodeAt(t), r >= 48 && r <= 57) {
      t++;
      continue;
    }
    return !1;
  }
  return !0;
}
function js(e) {
  return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
function wP(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
function Qh(e) {
  if (e === void 0) return !0;
  if (e) {
    if (Array.isArray(e)) {
      for (let n = 0, r = e.length; n < r; n++) if (Qh(e[n])) return !0;
    } else if (typeof e == "object") {
      const n = Yh(e), r = n.length;
      for (var t = 0; t < r; t++) if (Qh(e[n[t]])) return !0;
    }
  }
  return !1;
}
function Xw(e, t) {
  const n = [e];
  for (const r in t) {
    const s = typeof t[r] == "object" ? JSON.stringify(t[r], null, 2) : t[r];
    typeof s < "u" && n.push(`${r}: ${s}`);
  }
  return n.join(`
`);
}
var vP = class extends Error {
  constructor(e, t, n, r, s) {
    super(Xw(e, {
      name: t,
      index: n,
      operation: r,
      tree: s
    })), this.name = t, this.index = n, this.operation = r, this.tree = s, Object.setPrototypeOf(this, new.target.prototype), this.message = Xw(e, {
      name: t,
      index: n,
      operation: r,
      tree: s
    });
  }
}, Tx = {};
$e(Tx, {
  JsonPatchError: () => et,
  _areEquals: () => mo,
  applyOperation: () => gs,
  applyPatch: () => si,
  applyReducer: () => TP,
  deepClone: () => bP,
  getValueByPointer: () => Nc,
  validate: () => xx,
  validator: () => Mc
});
const et = vP, bP = $n;
function eh(e) {
  return Object.getOwnPropertyNames(Object.prototype).includes(e);
}
const Xs = {
  add: function(e, t, n) {
    if (eh(t)) throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
    return e[t] = this.value, { newDocument: n };
  },
  remove: function(e, t, n) {
    if (eh(t)) throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
    var r = e[t];
    return delete e[t], {
      newDocument: n,
      removed: r
    };
  },
  replace: function(e, t, n) {
    if (eh(t)) throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
    var r = e[t];
    return e[t] = this.value, {
      newDocument: n,
      removed: r
    };
  },
  move: function(e, t, n) {
    let r = Nc(n, this.path);
    r && (r = $n(r));
    const s = gs(n, {
      op: "remove",
      path: this.from
    }).removed;
    return gs(n, {
      op: "add",
      path: this.path,
      value: s
    }), {
      newDocument: n,
      removed: r
    };
  },
  copy: function(e, t, n) {
    const r = Nc(n, this.from);
    return gs(n, {
      op: "add",
      path: this.path,
      value: $n(r)
    }), { newDocument: n };
  },
  test: function(e, t, n) {
    return {
      newDocument: n,
      test: mo(e[t], this.value)
    };
  },
  _get: function(e, t, n) {
    return this.value = e[t], { newDocument: n };
  }
};
var SP = {
  add: function(e, t, n) {
    return Xh(t) ? e.splice(t, 0, this.value) : e[t] = this.value, {
      newDocument: n,
      index: t
    };
  },
  remove: function(e, t, n) {
    var r = e.splice(t, 1);
    return {
      newDocument: n,
      removed: r[0]
    };
  },
  replace: function(e, t, n) {
    var r = e[t];
    return e[t] = this.value, {
      newDocument: n,
      removed: r
    };
  },
  move: Xs.move,
  copy: Xs.copy,
  test: Xs.test,
  _get: Xs._get
};
function Nc(e, t) {
  if (t == "") return e;
  var n = {
    op: "_get",
    path: t
  };
  return gs(e, n), n.value;
}
function gs(e, t, n = !1, r = !0, s = !0, i = 0) {
  if (n && (typeof n == "function" ? n(t, 0, e, t.path) : Mc(t, 0)), t.path === "") {
    let a = { newDocument: e };
    if (t.op === "add")
      return a.newDocument = t.value, a;
    if (t.op === "replace")
      return a.newDocument = t.value, a.removed = e, a;
    if (t.op === "move" || t.op === "copy")
      return a.newDocument = Nc(e, t.from), t.op === "move" && (a.removed = e), a;
    if (t.op === "test") {
      if (a.test = mo(e, t.value), a.test === !1) throw new et("Test operation failed", "TEST_OPERATION_FAILED", i, t, e);
      return a.newDocument = e, a;
    } else {
      if (t.op === "remove")
        return a.removed = e, a.newDocument = null, a;
      if (t.op === "_get")
        return t.value = e, a;
      if (n) throw new et("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", i, t, e);
      return a;
    }
  } else {
    r || (e = $n(e));
    const o = (t.path || "").split("/");
    let u = e, c = 1, l = o.length, d, f, h;
    for (typeof n == "function" ? h = n : h = Mc; ; ) {
      if (f = o[c], f && f.indexOf("~") != -1 && (f = wP(f)), s && (f == "__proto__" || f == "prototype" && c > 0 && o[c - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && d === void 0 && (u[f] === void 0 ? d = o.slice(0, c).join("/") : c == l - 1 && (d = t.path), d !== void 0 && h(t, 0, e, d)), c++, Array.isArray(u)) {
        if (f === "-") f = u.length;
        else {
          if (n && !Xh(f)) throw new et("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", i, t, e);
          Xh(f) && (f = ~~f);
        }
        if (c >= l) {
          if (n && t.op === "add" && f > u.length) throw new et("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", i, t, e);
          const p = SP[t.op].call(t, u, f, e);
          if (p.test === !1) throw new et("Test operation failed", "TEST_OPERATION_FAILED", i, t, e);
          return p;
        }
      } else if (c >= l) {
        const p = Xs[t.op].call(t, u, f, e);
        if (p.test === !1) throw new et("Test operation failed", "TEST_OPERATION_FAILED", i, t, e);
        return p;
      }
      if (u = u[f], n && c < l && (!u || typeof u != "object")) throw new et("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", i, t, e);
    }
  }
}
function si(e, t, n, r = !0, s = !0) {
  if (n && !Array.isArray(t))
    throw new et("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  r || (e = $n(e));
  const i = new Array(t.length);
  for (let a = 0, o = t.length; a < o; a++)
    i[a] = gs(e, t[a], n, !0, s, a), e = i[a].newDocument;
  return i.newDocument = e, i;
}
function TP(e, t, n) {
  const r = gs(e, t);
  if (r.test === !1) throw new et("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
  return r.newDocument;
}
function Mc(e, t, n, r) {
  if (typeof e != "object" || e === null || Array.isArray(e)) throw new et("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
  if (Xs[e.op]) {
    if (typeof e.path != "string") throw new et("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
    if (e.path.indexOf("/") !== 0 && e.path.length > 0) throw new et('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
    if ((e.op === "move" || e.op === "copy") && typeof e.from != "string") throw new et("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0) throw new et("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && Qh(e.value)) throw new et("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
    if (n) {
      if (e.op == "add") {
        var s = e.path.split("/").length, i = r.split("/").length;
        if (s !== i + 1 && s !== i) throw new et("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
      } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
        if (e.path !== r) throw new et("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
      } else if (e.op === "move" || e.op === "copy") {
        var a = {
          op: "_get",
          path: e.from,
          value: void 0
        }, o = xx([a], n);
        if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new et("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
      }
    }
  } else throw new et("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
}
function xx(e, t, n) {
  try {
    if (!Array.isArray(e)) throw new et("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (t) si($n(t), $n(e), n || !0);
    else {
      n = n || Mc;
      for (var r = 0; r < e.length; r++) n(e[r], r, t, void 0);
    }
  } catch (s) {
    if (s instanceof et) return s;
    throw s;
  }
}
function mo(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    var n = Array.isArray(e), r = Array.isArray(t), s, i, a;
    if (n && r) {
      if (i = e.length, i != t.length) return !1;
      for (s = i; s-- !== 0; ) if (!mo(e[s], t[s])) return !1;
      return !0;
    }
    if (n != r) return !1;
    var o = Object.keys(e);
    if (i = o.length, i !== Object.keys(t).length) return !1;
    for (s = i; s-- !== 0; ) if (!t.hasOwnProperty(o[s])) return !1;
    for (s = i; s-- !== 0; )
      if (a = o[s], !mo(e[a], t[a])) return !1;
    return !0;
  }
  return e !== e && t !== t;
}
function Ex(e, t, n, r, s) {
  if (t !== e) {
    typeof t.toJSON == "function" && (t = t.toJSON());
    for (var i = Yh(t), a = Yh(e), o = !1, u = a.length - 1; u >= 0; u--) {
      var c = a[u], l = e[c];
      if (Kh(t, c) && !(t[c] === void 0 && l !== void 0 && Array.isArray(t) === !1)) {
        var d = t[c];
        typeof l == "object" && l != null && typeof d == "object" && d != null && Array.isArray(l) === Array.isArray(d) ? Ex(l, d, n, r + "/" + js(c), s) : l !== d && (s && n.push({
          op: "test",
          path: r + "/" + js(c),
          value: $n(l)
        }), n.push({
          op: "replace",
          path: r + "/" + js(c),
          value: $n(d)
        }));
      } else Array.isArray(e) === Array.isArray(t) ? (s && n.push({
        op: "test",
        path: r + "/" + js(c),
        value: $n(l)
      }), n.push({
        op: "remove",
        path: r + "/" + js(c)
      }), o = !0) : (s && n.push({
        op: "test",
        path: r,
        value: e
      }), n.push({
        op: "replace",
        path: r,
        value: t
      }));
    }
    if (!(!o && i.length == a.length))
      for (var u = 0; u < i.length; u++) {
        var c = i[u];
        !Kh(e, c) && t[c] !== void 0 && n.push({
          op: "add",
          path: r + "/" + js(c),
          value: $n(t[c])
        });
      }
  }
}
function Nm(e, t, n = !1) {
  var r = [];
  return Ex(e, t, r, "", n), r;
}
({
  ...Tx
});
var xP = {};
$e(xP, {
  LogStreamCallbackHandler: () => tp,
  RunLog: () => Mm,
  RunLogPatch: () => ar,
  isLogStreamHandler: () => kx
});
var ar = class {
  ops;
  constructor(e) {
    this.ops = e.ops ?? [];
  }
  concat(e) {
    const t = this.ops.concat(e.ops), n = si({}, t);
    return new Mm({
      ops: t,
      state: n[n.length - 1].newDocument
    });
  }
}, Mm = class ep extends ar {
  state;
  constructor(t) {
    super(t), this.state = t.state;
  }
  concat(t) {
    const n = this.ops.concat(t.ops), r = si(this.state, t.ops);
    return new ep({
      ops: n,
      state: r[r.length - 1].newDocument
    });
  }
  static fromRunLogPatch(t) {
    const n = si({}, t.ops);
    return new ep({
      ops: t.ops,
      state: n[n.length - 1].newDocument
    });
  }
};
const kx = (e) => e.name === "log_stream_tracer";
async function Qw(e, t) {
  if (t === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs: n } = e;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(e.run_type)) return n;
  if (!(Object.keys(n).length === 1 && n?.input === ""))
    return n.input;
}
async function ev(e, t) {
  const { outputs: n } = e;
  return t === "original" || [
    "retriever",
    "llm",
    "prompt"
  ].includes(e.run_type) ? n : n !== void 0 && Object.keys(n).length === 1 && n?.output !== void 0 ? n.output : n;
}
function EP(e) {
  return e !== void 0 && e.message !== void 0;
}
var tp = class extends _i {
  autoClose = !0;
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  _schemaFormat = "original";
  rootId;
  keyMapByRunId = {};
  counterMapByRunName = {};
  transformStream;
  writer;
  receiveStream;
  name = "log_stream_tracer";
  lc_prefer_streaming = !0;
  constructor(e) {
    super({
      _awaitHandler: !0,
      ...e
    }), this.autoClose = e?.autoClose ?? !0, this.includeNames = e?.includeNames, this.includeTypes = e?.includeTypes, this.includeTags = e?.includeTags, this.excludeNames = e?.excludeNames, this.excludeTypes = e?.excludeTypes, this.excludeTags = e?.excludeTags, this._schemaFormat = e?._schemaFormat ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = jn.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    if (e.id === this.rootId) return !1;
    const t = e.tags ?? [];
    let n = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(e.run_type)), this.includeTags !== void 0 && (n = n || t.find((r) => this.includeTags?.includes(r)) !== void 0), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(e.run_type)), this.excludeTags !== void 0 && (n = n && t.every((r) => !this.excludeTags?.includes(r))), n;
  }
  async *tapOutputIterable(e, t) {
    for await (const n of t) {
      if (e !== this.rootId) {
        const r = this.keyMapByRunId[e];
        r && await this.writer.write(new ar({ ops: [{
          op: "add",
          path: `/logs/${r}/streamed_output/-`,
          value: n
        }] }));
      }
      yield n;
    }
  }
  async onRunCreate(e) {
    if (this.rootId === void 0 && (this.rootId = e.id, await this.writer.write(new ar({ ops: [{
      op: "replace",
      path: "",
      value: {
        id: e.id,
        name: e.name,
        type: e.run_type,
        streamed_output: [],
        final_output: void 0,
        logs: {}
      }
    }] }))), !this._includeRun(e)) return;
    this.counterMapByRunName[e.name] === void 0 && (this.counterMapByRunName[e.name] = 0), this.counterMapByRunName[e.name] += 1;
    const t = this.counterMapByRunName[e.name];
    this.keyMapByRunId[e.id] = t === 1 ? e.name : `${e.name}:${t}`;
    const n = {
      id: e.id,
      name: e.name,
      type: e.run_type,
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      start_time: new Date(e.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    this._schemaFormat === "streaming_events" && (n.inputs = await Qw(e, this._schemaFormat)), await this.writer.write(new ar({ ops: [{
      op: "add",
      path: `/logs/${this.keyMapByRunId[e.id]}`,
      value: n
    }] }));
  }
  async onRunUpdate(e) {
    try {
      const t = this.keyMapByRunId[e.id];
      if (t === void 0) return;
      const n = [];
      this._schemaFormat === "streaming_events" && n.push({
        op: "replace",
        path: `/logs/${t}/inputs`,
        value: await Qw(e, this._schemaFormat)
      }), n.push({
        op: "add",
        path: `/logs/${t}/final_output`,
        value: await ev(e, this._schemaFormat)
      }), e.end_time !== void 0 && n.push({
        op: "add",
        path: `/logs/${t}/end_time`,
        value: new Date(e.end_time).toISOString()
      });
      const r = new ar({ ops: n });
      await this.writer.write(r);
    } finally {
      if (e.id === this.rootId) {
        const t = new ar({ ops: [{
          op: "replace",
          path: "/final_output",
          value: await ev(e, this._schemaFormat)
        }] });
        await this.writer.write(t), this.autoClose && await this.writer.close();
      }
    }
  }
  async onLLMNewToken(e, t, n) {
    const r = this.keyMapByRunId[e.id];
    if (r === void 0) return;
    const s = e.inputs.messages !== void 0;
    let i;
    s ? EP(n?.chunk) ? i = n?.chunk : i = new We({
      id: `run-${e.id}`,
      content: t
    }) : i = t;
    const a = new ar({ ops: [{
      op: "add",
      path: `/logs/${r}/streamed_output_str/-`,
      value: t
    }, {
      op: "add",
      path: `/logs/${r}/streamed_output/-`,
      value: i
    }] });
    await this.writer.write(a);
  }
}, kP = {};
$e(kP, {
  ChatGenerationChunk: () => Xn,
  GenerationChunk: () => ii,
  RUN_KEY: () => go
});
const go = "__run";
var ii = class Ox {
  text;
  generationInfo;
  constructor(t) {
    this.text = t.text, this.generationInfo = t.generationInfo;
  }
  concat(t) {
    return new Ox({
      text: this.text + t.text,
      generationInfo: {
        ...this.generationInfo,
        ...t.generationInfo
      }
    });
  }
}, Xn = class Ix extends ii {
  message;
  constructor(t) {
    super(t), this.message = t.message;
  }
  concat(t) {
    return new Ix({
      text: this.text + t.text,
      generationInfo: {
        ...this.generationInfo,
        ...t.generationInfo
      },
      message: this.message.concat(t.message)
    });
  }
};
function Tu({ name: e, serialized: t }) {
  return e !== void 0 ? e : t?.name !== void 0 ? t.name : t?.id !== void 0 && Array.isArray(t?.id) ? t.id[t.id.length - 1] : "Unnamed";
}
const OP = (e) => e.name === "event_stream_tracer";
var IP = class extends _i {
  autoClose = !0;
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  runInfoMap = /* @__PURE__ */ new Map();
  tappedPromises = /* @__PURE__ */ new Map();
  transformStream;
  writer;
  receiveStream;
  readableStreamClosed = !1;
  name = "event_stream_tracer";
  lc_prefer_streaming = !0;
  constructor(e) {
    super({
      _awaitHandler: !0,
      ...e
    }), this.autoClose = e?.autoClose ?? !0, this.includeNames = e?.includeNames, this.includeTypes = e?.includeTypes, this.includeTags = e?.includeTags, this.excludeNames = e?.excludeNames, this.excludeTypes = e?.excludeTypes, this.excludeTags = e?.excludeTags, this.transformStream = new TransformStream({ flush: () => {
      this.readableStreamClosed = !0;
    } }), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = jn.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(e) {
  }
  _includeRun(e) {
    const t = e.tags ?? [];
    let n = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(e.runType)), this.includeTags !== void 0 && (n = n || t.find((r) => this.includeTags?.includes(r)) !== void 0), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(e.runType)), this.excludeTags !== void 0 && (n = n && t.every((r) => !this.excludeTags?.includes(r))), n;
  }
  async *tapOutputIterable(e, t) {
    const n = await t.next();
    if (n.done) return;
    const r = this.runInfoMap.get(e);
    if (r === void 0) {
      yield n.value;
      return;
    }
    function s(a, o) {
      return a === "llm" && typeof o == "string" ? new ii({ text: o }) : o;
    }
    let i = this.tappedPromises.get(e);
    if (i === void 0) {
      let a;
      i = new Promise((o) => {
        a = o;
      }), this.tappedPromises.set(e, i);
      try {
        const o = {
          event: `on_${r.runType}_stream`,
          run_id: e,
          name: r.name,
          tags: r.tags,
          metadata: r.metadata,
          data: {}
        };
        await this.send({
          ...o,
          data: { chunk: s(r.runType, n.value) }
        }, r), yield n.value;
        for await (const u of t)
          r.runType !== "tool" && r.runType !== "retriever" && await this.send({
            ...o,
            data: { chunk: s(r.runType, u) }
          }, r), yield u;
      } finally {
        a?.();
      }
    } else {
      yield n.value;
      for await (const a of t) yield a;
    }
  }
  async send(e, t) {
    this.readableStreamClosed || this._includeRun(t) && await this.writer.write(e);
  }
  async sendEndEvent(e, t) {
    const n = this.tappedPromises.get(e.run_id);
    n !== void 0 ? n.then(() => {
      this.send(e, t);
    }) : await this.send(e, t);
  }
  async onLLMStart(e) {
    const t = Tu(e), n = e.inputs.messages !== void 0 ? "chat_model" : "llm", r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: t,
      runType: n,
      inputs: e.inputs
    };
    this.runInfoMap.set(e.id, r);
    const s = `on_${n}_start`;
    await this.send({
      event: s,
      data: { input: e.inputs },
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onLLMNewToken(e, t, n) {
    const r = this.runInfoMap.get(e.id);
    let s, i;
    if (r === void 0) throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);
    if (this.runInfoMap.size !== 1) {
      if (r.runType === "chat_model")
        i = "on_chat_model_stream", n?.chunk === void 0 ? s = new We({
          content: t,
          id: `run-${e.id}`
        }) : s = n.chunk.message;
      else if (r.runType === "llm")
        i = "on_llm_stream", n?.chunk === void 0 ? s = new ii({ text: t }) : s = n.chunk;
      else throw new Error(`Unexpected run type ${r.runType}`);
      await this.send({
        event: i,
        data: { chunk: s },
        run_id: e.id,
        name: r.name,
        tags: r.tags,
        metadata: r.metadata
      }, r);
    }
  }
  async onLLMEnd(e) {
    const t = this.runInfoMap.get(e.id);
    this.runInfoMap.delete(e.id);
    let n;
    if (t === void 0) throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);
    const r = e.outputs?.generations;
    let s;
    if (t.runType === "chat_model") {
      for (const i of r ?? []) {
        if (s !== void 0) break;
        s = i[0]?.message;
      }
      n = "on_chat_model_end";
    } else if (t.runType === "llm")
      s = {
        generations: r?.map((i) => i.map((a) => ({
          text: a.text,
          generationInfo: a.generationInfo
        }))),
        llmOutput: e.outputs?.llmOutput ?? {}
      }, n = "on_llm_end";
    else throw new Error(`onLLMEnd: Unexpected run type: ${t.runType}`);
    await this.sendEndEvent({
      event: n,
      data: {
        output: s,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async onChainStart(e) {
    const t = Tu(e), n = e.run_type ?? "chain", r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: t,
      runType: e.run_type
    };
    let s = {};
    e.inputs.input === "" && Object.keys(e.inputs).length === 1 ? (s = {}, r.inputs = {}) : e.inputs.input !== void 0 ? (s.input = e.inputs.input, r.inputs = e.inputs.input) : (s.input = e.inputs, r.inputs = e.inputs), this.runInfoMap.set(e.id, r), await this.send({
      event: `on_${n}_start`,
      data: s,
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onChainEnd(e) {
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);
    const n = `on_${e.run_type}_end`, r = e.inputs ?? t.inputs ?? {}, i = {
      output: e.outputs?.output ?? e.outputs,
      input: r
    };
    r.input && Object.keys(r).length === 1 && (i.input = r.input, t.inputs = r.input), await this.sendEndEvent({
      event: n,
      data: i,
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata ?? {}
    }, t);
  }
  async onToolStart(e) {
    const t = Tu(e), n = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: t,
      runType: "tool",
      inputs: e.inputs ?? {}
    };
    this.runInfoMap.set(e.id, n), await this.send({
      event: "on_tool_start",
      data: { input: e.inputs ?? {} },
      name: t,
      run_id: e.id,
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {}
    }, n);
  }
  async onToolEnd(e) {
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);
    if (t.inputs === void 0) throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);
    const n = e.outputs?.output === void 0 ? e.outputs : e.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output: n,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async onRetrieverStart(e) {
    const t = Tu(e), r = {
      tags: e.tags ?? [],
      metadata: e.extra?.metadata ?? {},
      name: t,
      runType: "retriever",
      inputs: { query: e.inputs.query }
    };
    this.runInfoMap.set(e.id, r), await this.send({
      event: "on_retriever_start",
      data: { input: { query: e.inputs.query } },
      name: t,
      tags: e.tags ?? [],
      run_id: e.id,
      metadata: e.extra?.metadata ?? {}
    }, r);
  }
  async onRetrieverEnd(e) {
    const t = this.runInfoMap.get(e.id);
    if (this.runInfoMap.delete(e.id), t === void 0) throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: e.outputs?.documents ?? e.outputs,
        input: t.inputs
      },
      run_id: e.id,
      name: t.name,
      tags: t.tags,
      metadata: t.metadata
    }, t);
  }
  async handleCustomEvent(e, t, n) {
    const r = this.runInfoMap.get(n);
    if (r === void 0) throw new Error(`handleCustomEvent: Run ID ${n} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: n,
      name: e,
      tags: r.tags,
      metadata: r.metadata,
      data: t
    }, r);
  }
  async finish() {
    const e = [...this.tappedPromises.values()];
    Promise.all(e).finally(() => {
      this.writer.close();
    });
  }
};
const AP = Object.prototype.toString, CP = (e) => AP.call(e) === "[object Error]", $P = /* @__PURE__ */ new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function RP(e) {
  if (!(e && CP(e) && e.name === "TypeError" && typeof e.message == "string")) return !1;
  const { message: n, stack: r } = e;
  return n === "Load failed" ? r === void 0 || "__sentry_captured__" in e : n.startsWith("error sending request for url") ? !0 : $P.has(n);
}
function PP(e) {
  if (typeof e == "number") {
    if (e < 0) throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(e)) throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (e !== void 0) throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function xu(e, t, { min: n = 0, allowInfinity: r = !1 } = {}) {
  if (t !== void 0) {
    if (typeof t != "number" || Number.isNaN(t)) throw new TypeError(`Expected \`${e}\` to be a number${r ? " or Infinity" : ""}.`);
    if (!r && !Number.isFinite(t)) throw new TypeError(`Expected \`${e}\` to be a finite number.`);
    if (t < n) throw new TypeError(`Expected \`${e}\` to be  ${n}.`);
  }
}
var NP = class extends Error {
  constructor(e) {
    super(), e instanceof Error ? (this.originalError = e, { message: e } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e;
  }
};
function MP(e, t) {
  const n = Math.max(1, e + 1), r = t.randomize ? Math.random() + 1 : 1;
  let s = Math.round(r * t.minTimeout * t.factor ** (n - 1));
  return s = Math.min(s, t.maxTimeout), s;
}
function tv(e, t) {
  return Number.isFinite(t) ? t - (performance.now() - e) : t;
}
async function jP({ error: e, attemptNumber: t, retriesConsumed: n, startTime: r, options: s }) {
  const i = e instanceof Error ? e : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`);
  if (i instanceof NP) throw i.originalError;
  const a = Number.isFinite(s.retries) ? Math.max(0, s.retries - n) : s.retries, o = s.maxRetryTime ?? Number.POSITIVE_INFINITY, u = Object.freeze({
    error: i,
    attemptNumber: t,
    retriesLeft: a,
    retriesConsumed: n
  });
  if (await s.onFailedAttempt(u), tv(r, o) <= 0) throw i;
  const c = await s.shouldConsumeRetry(u), l = tv(r, o);
  if (l <= 0 || a <= 0) throw i;
  if (i instanceof TypeError && !RP(i)) {
    if (c) throw i;
    return s.signal?.throwIfAborted(), !1;
  }
  if (!await s.shouldRetry(u)) throw i;
  if (!c)
    return s.signal?.throwIfAborted(), !1;
  const d = MP(n, s), f = Math.min(d, l);
  return f > 0 && await new Promise((h, p) => {
    const g = () => {
      clearTimeout(m), s.signal?.removeEventListener("abort", g), p(s.signal.reason);
    }, m = setTimeout(() => {
      s.signal?.removeEventListener("abort", g), h();
    }, f);
    s.unref && m.unref?.(), s.signal?.addEventListener("abort", g, { once: !0 });
  }), s.signal?.throwIfAborted(), !0;
}
async function np(e, t = {}) {
  if (t = { ...t }, PP(t.retries), Object.hasOwn(t, "forever")) throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  t.retries ??= 10, t.factor ??= 2, t.minTimeout ??= 1e3, t.maxTimeout ??= Number.POSITIVE_INFINITY, t.maxRetryTime ??= Number.POSITIVE_INFINITY, t.randomize ??= !1, t.onFailedAttempt ??= () => {
  }, t.shouldRetry ??= () => !0, t.shouldConsumeRetry ??= () => !0, xu("factor", t.factor, {
    min: 0,
    allowInfinity: !1
  }), xu("minTimeout", t.minTimeout, {
    min: 0,
    allowInfinity: !1
  }), xu("maxTimeout", t.maxTimeout, {
    min: 0,
    allowInfinity: !0
  }), xu("maxRetryTime", t.maxRetryTime, {
    min: 0,
    allowInfinity: !0
  }), t.factor > 0 || (t.factor = 1), t.signal?.throwIfAborted();
  let n = 0, r = 0;
  const s = performance.now();
  for (; !Number.isFinite(t.retries) || r <= t.retries; ) {
    n++;
    try {
      t.signal?.throwIfAborted();
      const i = await e(n);
      return t.signal?.throwIfAborted(), i;
    } catch (i) {
      await jP({
        error: i,
        attemptNumber: n,
        retriesConsumed: r,
        startTime: s,
        options: t
      }) && r++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
var LP = {};
$e(LP, { AsyncCaller: () => Uo });
const DP = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
], UP = (e) => {
  if (e.message.startsWith("Cancel") || e.message.startsWith("AbortError") || e.name === "AbortError" || e?.code === "ECONNABORTED") throw e;
  const t = e?.response?.status ?? e?.status;
  if (t && DP.includes(+t)) throw e;
  if (e?.error?.code === "insufficient_quota") {
    const n = new Error(e?.message);
    throw n.name = "InsufficientQuotaError", n;
  }
};
var Uo = class {
  maxConcurrency;
  maxRetries;
  onFailedAttempt;
  queue;
  constructor(e) {
    this.maxConcurrency = e.maxConcurrency ?? 1 / 0, this.maxRetries = e.maxRetries ?? 6, this.onFailedAttempt = e.onFailedAttempt ?? UP;
    const t = "default" in cr ? cr.default : cr;
    this.queue = new t({ concurrency: this.maxConcurrency });
  }
  async call(e, ...t) {
    return this.queue.add(() => np(() => e(...t).catch((n) => {
      throw n instanceof Error ? n : new Error(n);
    }), {
      onFailedAttempt: ({ error: n }) => this.onFailedAttempt?.(n),
      retries: this.maxRetries,
      randomize: !0
    }), { throwOnTimeout: !0 });
  }
  callWithOptions(e, t, ...n) {
    if (e.signal) {
      let r;
      return Promise.race([this.call(t, ...n), new Promise((s, i) => {
        r = () => {
          i(po(e.signal));
        }, e.signal?.addEventListener("abort", r);
      })]).finally(() => {
        e.signal && r && e.signal.removeEventListener("abort", r);
      });
    }
    return this.call(t, ...n);
  }
  fetch(...e) {
    return this.call(() => fetch(...e).then((t) => t.ok ? t : Promise.reject(t)));
  }
}, Ax = class extends _i {
  name = "RootListenersTracer";
  /** The Run's ID. Type UUID */
  rootId;
  config;
  argOnStart;
  argOnEnd;
  argOnError;
  constructor({ config: e, onStart: t, onEnd: n, onError: r }) {
    super({ _awaitHandler: !0 }), this.config = e, this.argOnStart = t, this.argOnEnd = n, this.argOnError = r;
  }
  /**
  * This is a legacy method only called once for an entire run tree
  * therefore not useful here
  * @param {Run} _ Not used
  */
  persistRun(e) {
    return Promise.resolve();
  }
  async onRunCreate(e) {
    this.rootId || (this.rootId = e.id, this.argOnStart && await this.argOnStart(e, this.config));
  }
  async onRunUpdate(e) {
    e.id === this.rootId && (e.error ? this.argOnError && await this.argOnError(e, this.config) : this.argOnEnd && await this.argOnEnd(e, this.config));
  }
};
function jm(e) {
  return e ? e.lc_runnable : !1;
}
var FP = class {
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  constructor(e) {
    this.includeNames = e.includeNames, this.includeTypes = e.includeTypes, this.includeTags = e.includeTags, this.excludeNames = e.excludeNames, this.excludeTypes = e.excludeTypes, this.excludeTags = e.excludeTags;
  }
  includeEvent(e, t) {
    let n = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const r = e.tags ?? [];
    return this.includeNames !== void 0 && (n = n || this.includeNames.includes(e.name)), this.includeTypes !== void 0 && (n = n || this.includeTypes.includes(t)), this.includeTags !== void 0 && (n = n || r.some((s) => this.includeTags?.includes(s))), this.excludeNames !== void 0 && (n = n && !this.excludeNames.includes(e.name)), this.excludeTypes !== void 0 && (n = n && !this.excludeTypes.includes(t)), this.excludeTags !== void 0 && (n = n && r.every((s) => !this.excludeTags?.includes(s))), n;
  }
};
const zP = (e) => btoa(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
function R(e, t, n) {
  function r(o, u) {
    if (o._zod || Object.defineProperty(o, "_zod", {
      value: {
        def: u,
        constr: a,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), o._zod.traits.has(e))
      return;
    o._zod.traits.add(e), t(o, u);
    const c = a.prototype, l = Object.keys(c);
    for (let d = 0; d < l.length; d++) {
      const f = l[d];
      f in o || (o[f] = c[f].bind(o));
    }
  }
  const s = n?.Parent ?? Object;
  class i extends s {
  }
  Object.defineProperty(i, "name", { value: e });
  function a(o) {
    var u;
    const c = n?.Parent ? new i() : this;
    r(c, o), (u = c._zod).deferred ?? (u.deferred = []);
    for (const l of c._zod.deferred)
      l();
    return c;
  }
  return Object.defineProperty(a, "init", { value: r }), Object.defineProperty(a, Symbol.hasInstance, {
    value: (o) => n?.Parent && o instanceof n.Parent ? !0 : o?._zod?.traits?.has(e)
  }), Object.defineProperty(a, "name", { value: e }), a;
}
class ti extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class Cx extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const $x = {};
function Ur(e) {
  return $x;
}
function Rx(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, s]) => t.indexOf(+r) === -1).map(([r, s]) => s);
}
function rp(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Cl(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function Lm(e) {
  return e == null;
}
function Dm(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function qP(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = t.toString();
  let s = (r.split(".")[1] || "").length;
  if (s === 0 && /\d?e-\d?/.test(r)) {
    const u = r.match(/\d?e-(\d?)/);
    u?.[1] && (s = Number.parseInt(u[1]));
  }
  const i = n > s ? n : s, a = Number.parseInt(e.toFixed(i).replace(".", "")), o = Number.parseInt(t.toFixed(i).replace(".", ""));
  return a % o / 10 ** i;
}
const nv = /* @__PURE__ */ Symbol("evaluating");
function Le(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== nv)
        return r === void 0 && (r = nv, r = n()), r;
    },
    set(s) {
      Object.defineProperty(e, t, {
        value: s
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Is(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Jr(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function rv(e) {
  return JSON.stringify(e);
}
function BP(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const Px = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function _o(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const ZP = Cl(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function ai(e) {
  if (_o(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(_o(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function Nx(e) {
  return ai(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const VP = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function oi(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Et(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function te(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function HP(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const GP = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function WP(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const i = Jr(e._zod.def, {
    get shape() {
      const a = {};
      for (const o in t) {
        if (!(o in n.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && (a[o] = n.shape[o]);
      }
      return Is(this, "shape", a), a;
    },
    checks: []
  });
  return Et(e, i);
}
function JP(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const i = Jr(e._zod.def, {
    get shape() {
      const a = { ...e._zod.def.shape };
      for (const o in t) {
        if (!(o in n.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && delete a[o];
      }
      return Is(this, "shape", a), a;
    },
    checks: []
  });
  return Et(e, i);
}
function Mx(e, t) {
  if (!ai(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const i = e._zod.def.shape;
    for (const a in t)
      if (Object.getOwnPropertyDescriptor(i, a) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const s = Jr(e._zod.def, {
    get shape() {
      const i = { ...e._zod.def.shape, ...t };
      return Is(this, "shape", i), i;
    }
  });
  return Et(e, s);
}
function KP(e, t) {
  if (!ai(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = Jr(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return Is(this, "shape", r), r;
    }
  });
  return Et(e, n);
}
function YP(e, t) {
  const n = Jr(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return Is(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Et(e, n);
}
function jx(e, t, n) {
  const s = t._zod.def.checks;
  if (s && s.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const a = Jr(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape, u = { ...o };
      if (n)
        for (const c in n) {
          if (!(c in o))
            throw new Error(`Unrecognized key: "${c}"`);
          n[c] && (u[c] = e ? new e({
            type: "optional",
            innerType: o[c]
          }) : o[c]);
        }
      else
        for (const c in o)
          u[c] = e ? new e({
            type: "optional",
            innerType: o[c]
          }) : o[c];
      return Is(this, "shape", u), u;
    },
    checks: []
  });
  return Et(t, a);
}
function XP(e, t, n) {
  const r = Jr(t._zod.def, {
    get shape() {
      const s = t._zod.def.shape, i = { ...s };
      if (n)
        for (const a in n) {
          if (!(a in i))
            throw new Error(`Unrecognized key: "${a}"`);
          n[a] && (i[a] = new e({
            type: "nonoptional",
            innerType: s[a]
          }));
        }
      else
        for (const a in s)
          i[a] = new e({
            type: "nonoptional",
            innerType: s[a]
          });
      return Is(this, "shape", i), i;
    }
  });
  return Et(t, r);
}
function Qs(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function ps(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function Eu(e) {
  return typeof e == "string" ? e : e?.message;
}
function Fr(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const s = Eu(e.inst?._zod.def?.error?.(e)) ?? Eu(t?.error?.(e)) ?? Eu(n.customError?.(e)) ?? Eu(n.localeError?.(e)) ?? "Invalid input";
    r.message = s;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function Um(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function yo(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const Lx = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, rp, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, Dx = R("$ZodError", Lx), $l = R("$ZodError", Lx, { Parent: Error });
function QP(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const s of e.issues)
    s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(t(s))) : r.push(t(s));
  return { formErrors: r, fieldErrors: n };
}
function eN(e, t = (n) => n.message) {
  const n = { _errors: [] }, r = (s) => {
    for (const i of s.issues)
      if (i.code === "invalid_union" && i.errors.length)
        i.errors.map((a) => r({ issues: a }));
      else if (i.code === "invalid_key")
        r({ issues: i.issues });
      else if (i.code === "invalid_element")
        r({ issues: i.issues });
      else if (i.path.length === 0)
        n._errors.push(t(i));
      else {
        let a = n, o = 0;
        for (; o < i.path.length; ) {
          const u = i.path[o];
          o === i.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(t(i))) : a[u] = a[u] || { _errors: [] }, a = a[u], o++;
        }
      }
  };
  return r(e), n;
}
function tN(e) {
  const t = [], n = e.map((r) => typeof r == "object" ? r.key : r);
  for (const r of n)
    typeof r == "number" ? t.push(`[${r}]`) : typeof r == "symbol" ? t.push(`[${JSON.stringify(String(r))}]`) : /[^\w$]/.test(r) ? t.push(`[${JSON.stringify(r)}]`) : (t.length && t.push("."), t.push(r));
  return t.join("");
}
function nN(e) {
  const t = [], n = [...e.issues].sort((r, s) => (r.path ?? []).length - (s.path ?? []).length);
  for (const r of n)
    t.push(` ${r.message}`), r.path?.length && t.push(`   at ${tN(r.path)}`);
  return t.join(`
`);
}
const Rl = (e) => (t, n, r, s) => {
  const i = r ? Object.assign(r, { async: !1 }) : { async: !1 }, a = t._zod.run({ value: n, issues: [] }, i);
  if (a instanceof Promise)
    throw new ti();
  if (a.issues.length) {
    const o = new (s?.Err ?? e)(a.issues.map((u) => Fr(u, i, Ur())));
    throw Px(o, s?.callee), o;
  }
  return a.value;
}, Pl = /* @__PURE__ */ Rl($l), Nl = (e) => async (t, n, r, s) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let a = t._zod.run({ value: n, issues: [] }, i);
  if (a instanceof Promise && (a = await a), a.issues.length) {
    const o = new (s?.Err ?? e)(a.issues.map((u) => Fr(u, i, Ur())));
    throw Px(o, s?.callee), o;
  }
  return a.value;
}, Ux = /* @__PURE__ */ Nl($l), Ml = (e) => (t, n, r) => {
  const s = r ? { ...r, async: !1 } : { async: !1 }, i = t._zod.run({ value: n, issues: [] }, s);
  if (i instanceof Promise)
    throw new ti();
  return i.issues.length ? {
    success: !1,
    error: new (e ?? Dx)(i.issues.map((a) => Fr(a, s, Ur())))
  } : { success: !0, data: i.value };
}, rN = /* @__PURE__ */ Ml($l), jl = (e) => async (t, n, r) => {
  const s = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let i = t._zod.run({ value: n, issues: [] }, s);
  return i instanceof Promise && (i = await i), i.issues.length ? {
    success: !1,
    error: new e(i.issues.map((a) => Fr(a, s, Ur())))
  } : { success: !0, data: i.value };
}, sN = /* @__PURE__ */ jl($l), iN = (e) => (t, n, r) => {
  const s = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Rl(e)(t, n, s);
}, aN = (e) => (t, n, r) => Rl(e)(t, n, r), oN = (e) => async (t, n, r) => {
  const s = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Nl(e)(t, n, s);
}, uN = (e) => async (t, n, r) => Nl(e)(t, n, r), cN = (e) => (t, n, r) => {
  const s = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Ml(e)(t, n, s);
}, lN = (e) => (t, n, r) => Ml(e)(t, n, r), dN = (e) => async (t, n, r) => {
  const s = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return jl(e)(t, n, s);
}, fN = (e) => async (t, n, r) => jl(e)(t, n, r), hN = /^[cC][^\s-]{8,}$/, pN = /^[0-9a-z]+$/, mN = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, gN = /^[0-9a-vA-V]{20}$/, _N = /^[A-Za-z0-9]{27}$/, yN = /^[a-zA-Z0-9_-]{21}$/, wN = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, vN = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, sv = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, bN = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, SN = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function TN() {
  return new RegExp(SN, "u");
}
const xN = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, EN = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, kN = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, ON = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, IN = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Fx = /^[A-Za-z0-9_-]*$/, AN = /^\+[1-9]\d{6,14}$/, zx = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", CN = /* @__PURE__ */ new RegExp(`^${zx}$`);
function qx(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function $N(e) {
  return new RegExp(`^${qx(e)}$`);
}
function RN(e) {
  const t = qx({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${zx}T(?:${r})$`);
}
const PN = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, NN = /^-?\d+$/, Bx = /^-?\d+(?:\.\d+)?$/, MN = /^(?:true|false)$/i, jN = /^[^A-Z]*$/, LN = /^[^a-z]*$/, Kt = /* @__PURE__ */ R("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), Zx = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Vx = /* @__PURE__ */ R("$ZodCheckLessThan", (e, t) => {
  Kt.init(e, t);
  const n = Zx[typeof t.value];
  e._zod.onattach.push((r) => {
    const s = r._zod.bag, i = (t.inclusive ? s.maximum : s.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < i && (t.inclusive ? s.maximum = t.value : s.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: n,
      code: "too_big",
      maximum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Hx = /* @__PURE__ */ R("$ZodCheckGreaterThan", (e, t) => {
  Kt.init(e, t);
  const n = Zx[typeof t.value];
  e._zod.onattach.push((r) => {
    const s = r._zod.bag, i = (t.inclusive ? s.minimum : s.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > i && (t.inclusive ? s.minimum = t.value : s.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: n,
      code: "too_small",
      minimum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), DN = /* @__PURE__ */ R("$ZodCheckMultipleOf", (e, t) => {
  Kt.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : qP(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), UN = /* @__PURE__ */ R("$ZodCheckNumberFormat", (e, t) => {
  Kt.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), r = n ? "int" : "number", [s, i] = GP[t.format];
  e._zod.onattach.push((a) => {
    const o = a._zod.bag;
    o.format = t.format, o.minimum = s, o.maximum = i, n && (o.pattern = NN);
  }), e._zod.check = (a) => {
    const o = a.value;
    if (n) {
      if (!Number.isInteger(o)) {
        a.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: o,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(o)) {
        o > 0 ? a.issues.push({
          input: o,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        }) : a.issues.push({
          input: o,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        });
        return;
      }
    }
    o < s && a.issues.push({
      origin: "number",
      input: o,
      code: "too_small",
      minimum: s,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), o > i && a.issues.push({
      origin: "number",
      input: o,
      code: "too_big",
      maximum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    });
  };
}), FN = /* @__PURE__ */ R("$ZodCheckMaxLength", (e, t) => {
  var n;
  Kt.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const s = r.value;
    return !Lm(s) && s.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const s = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < s && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const s = r.value;
    if (s.length <= t.maximum)
      return;
    const a = Um(s);
    r.issues.push({
      origin: a,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: s,
      inst: e,
      continue: !t.abort
    });
  };
}), zN = /* @__PURE__ */ R("$ZodCheckMinLength", (e, t) => {
  var n;
  Kt.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const s = r.value;
    return !Lm(s) && s.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const s = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > s && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const s = r.value;
    if (s.length >= t.minimum)
      return;
    const a = Um(s);
    r.issues.push({
      origin: a,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: s,
      inst: e,
      continue: !t.abort
    });
  };
}), qN = /* @__PURE__ */ R("$ZodCheckLengthEquals", (e, t) => {
  var n;
  Kt.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const s = r.value;
    return !Lm(s) && s.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.minimum = t.length, s.maximum = t.length, s.length = t.length;
  }), e._zod.check = (r) => {
    const s = r.value, i = s.length;
    if (i === t.length)
      return;
    const a = Um(s), o = i > t.length;
    r.issues.push({
      origin: a,
      ...o ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Ll = /* @__PURE__ */ R("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  Kt.init(e, t), e._zod.onattach.push((s) => {
    const i = s._zod.bag;
    i.format = t.format, t.pattern && (i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (s) => {
    t.pattern.lastIndex = 0, !t.pattern.test(s.value) && s.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: s.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), BN = /* @__PURE__ */ R("$ZodCheckRegex", (e, t) => {
  Ll.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), ZN = /* @__PURE__ */ R("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = jN), Ll.init(e, t);
}), VN = /* @__PURE__ */ R("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = LN), Ll.init(e, t);
}), HN = /* @__PURE__ */ R("$ZodCheckIncludes", (e, t) => {
  Kt.init(e, t);
  const n = oi(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((s) => {
    const i = s._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(r);
  }), e._zod.check = (s) => {
    s.value.includes(t.includes, t.position) || s.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: s.value,
      inst: e,
      continue: !t.abort
    });
  };
}), GN = /* @__PURE__ */ R("$ZodCheckStartsWith", (e, t) => {
  Kt.init(e, t);
  const n = new RegExp(`^${oi(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), WN = /* @__PURE__ */ R("$ZodCheckEndsWith", (e, t) => {
  Kt.init(e, t);
  const n = new RegExp(`.*${oi(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const s = r._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), JN = /* @__PURE__ */ R("$ZodCheckOverwrite", (e, t) => {
  Kt.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class KN {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((a) => a), s = Math.min(...r.map((a) => a.length - a.trimStart().length)), i = r.map((a) => a.slice(s)).map((a) => " ".repeat(this.indent * 2) + a);
    for (const a of i)
      this.content.push(a);
  }
  compile() {
    const t = Function, n = this?.args, s = [...(this?.content ?? [""]).map((i) => `  ${i}`)];
    return new t(...n, s.join(`
`));
  }
}
const YN = {
  major: 4,
  minor: 3,
  patch: 5
}, Ve = /* @__PURE__ */ R("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = YN;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const s of r)
    for (const i of s._zod.onattach)
      i(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const s = (a, o, u) => {
      let c = Qs(a), l;
      for (const d of o) {
        if (d._zod.def.when) {
          if (!d._zod.def.when(a))
            continue;
        } else if (c)
          continue;
        const f = a.issues.length, h = d._zod.check(a);
        if (h instanceof Promise && u?.async === !1)
          throw new ti();
        if (l || h instanceof Promise)
          l = (l ?? Promise.resolve()).then(async () => {
            await h, a.issues.length !== f && (c || (c = Qs(a, f)));
          });
        else {
          if (a.issues.length === f)
            continue;
          c || (c = Qs(a, f));
        }
      }
      return l ? l.then(() => a) : a;
    }, i = (a, o, u) => {
      if (Qs(a))
        return a.aborted = !0, a;
      const c = s(o, r, u);
      if (c instanceof Promise) {
        if (u.async === !1)
          throw new ti();
        return c.then((l) => e._zod.parse(l, u));
      }
      return e._zod.parse(c, u);
    };
    e._zod.run = (a, o) => {
      if (o.skipChecks)
        return e._zod.parse(a, o);
      if (o.direction === "backward") {
        const c = e._zod.parse({ value: a.value, issues: [] }, { ...o, skipChecks: !0 });
        return c instanceof Promise ? c.then((l) => i(l, a, o)) : i(c, a, o);
      }
      const u = e._zod.parse(a, o);
      if (u instanceof Promise) {
        if (o.async === !1)
          throw new ti();
        return u.then((c) => s(c, r, o));
      }
      return s(u, r, o);
    };
  }
  Le(e, "~standard", () => ({
    validate: (s) => {
      try {
        const i = rN(e, s);
        return i.success ? { value: i.data } : { issues: i.error?.issues };
      } catch {
        return sN(e, s).then((a) => a.success ? { value: a.data } : { issues: a.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), Fm = /* @__PURE__ */ R("$ZodString", (e, t) => {
  Ve.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? PN(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), Je = /* @__PURE__ */ R("$ZodStringFormat", (e, t) => {
  Ll.init(e, t), Fm.init(e, t);
}), XN = /* @__PURE__ */ R("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = vN), Je.init(e, t);
}), QN = /* @__PURE__ */ R("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = sv(r));
  } else
    t.pattern ?? (t.pattern = sv());
  Je.init(e, t);
}), eM = /* @__PURE__ */ R("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = bN), Je.init(e, t);
}), tM = /* @__PURE__ */ R("$ZodURL", (e, t) => {
  Je.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), s = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(s.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(s.protocol.endsWith(":") ? s.protocol.slice(0, -1) : s.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = s.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), nM = /* @__PURE__ */ R("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = TN()), Je.init(e, t);
}), rM = /* @__PURE__ */ R("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = yN), Je.init(e, t);
}), sM = /* @__PURE__ */ R("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = hN), Je.init(e, t);
}), iM = /* @__PURE__ */ R("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = pN), Je.init(e, t);
}), aM = /* @__PURE__ */ R("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = mN), Je.init(e, t);
}), oM = /* @__PURE__ */ R("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = gN), Je.init(e, t);
}), uM = /* @__PURE__ */ R("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = _N), Je.init(e, t);
}), cM = /* @__PURE__ */ R("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = RN(t)), Je.init(e, t);
}), lM = /* @__PURE__ */ R("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = CN), Je.init(e, t);
}), dM = /* @__PURE__ */ R("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = $N(t)), Je.init(e, t);
}), fM = /* @__PURE__ */ R("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = wN), Je.init(e, t);
}), hM = /* @__PURE__ */ R("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = xN), Je.init(e, t), e._zod.bag.format = "ipv4";
}), pM = /* @__PURE__ */ R("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = EN), Je.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), mM = /* @__PURE__ */ R("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = kN), Je.init(e, t);
}), gM = /* @__PURE__ */ R("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = ON), Je.init(e, t), e._zod.check = (n) => {
    const r = n.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [s, i] = r;
      if (!i)
        throw new Error();
      const a = Number(i);
      if (`${a}` !== i)
        throw new Error();
      if (a < 0 || a > 128)
        throw new Error();
      new URL(`http://[${s}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function Gx(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const _M = /* @__PURE__ */ R("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = IN), Je.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    Gx(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function yM(e) {
  if (!Fx.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Gx(n);
}
const wM = /* @__PURE__ */ R("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = Fx), Je.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    yM(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), vM = /* @__PURE__ */ R("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = AN), Je.init(e, t);
});
function bM(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const s = JSON.parse(atob(r));
    return !("typ" in s && s?.typ !== "JWT" || !s.alg || t && (!("alg" in s) || s.alg !== t));
  } catch {
    return !1;
  }
}
const SM = /* @__PURE__ */ R("$ZodJWT", (e, t) => {
  Je.init(e, t), e._zod.check = (n) => {
    bM(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Wx = /* @__PURE__ */ R("$ZodNumber", (e, t) => {
  Ve.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? Bx, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const s = n.value;
    if (typeof s == "number" && !Number.isNaN(s) && Number.isFinite(s))
      return n;
    const i = typeof s == "number" ? Number.isNaN(s) ? "NaN" : Number.isFinite(s) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: s,
      inst: e,
      ...i ? { received: i } : {}
    }), n;
  };
}), TM = /* @__PURE__ */ R("$ZodNumberFormat", (e, t) => {
  UN.init(e, t), Wx.init(e, t);
}), xM = /* @__PURE__ */ R("$ZodBoolean", (e, t) => {
  Ve.init(e, t), e._zod.pattern = MN, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const s = n.value;
    return typeof s == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: s,
      inst: e
    }), n;
  };
}), Jx = /* @__PURE__ */ R("$ZodUnknown", (e, t) => {
  Ve.init(e, t), e._zod.parse = (n) => n;
}), Kx = /* @__PURE__ */ R("$ZodNever", (e, t) => {
  Ve.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function iv(e, t, n) {
  e.issues.length && t.issues.push(...ps(n, e.issues)), t.value[n] = e.value;
}
const EM = /* @__PURE__ */ R("$ZodArray", (e, t) => {
  Ve.init(e, t), e._zod.parse = (n, r) => {
    const s = n.value;
    if (!Array.isArray(s))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: s,
        inst: e
      }), n;
    n.value = Array(s.length);
    const i = [];
    for (let a = 0; a < s.length; a++) {
      const o = s[a], u = t.element._zod.run({
        value: o,
        issues: []
      }, r);
      u instanceof Promise ? i.push(u.then((c) => iv(c, n, a))) : iv(u, n, a);
    }
    return i.length ? Promise.all(i).then(() => n) : n;
  };
});
function jc(e, t, n, r, s) {
  if (e.issues.length) {
    if (s && !(n in r))
      return;
    t.issues.push(...ps(n, e.issues));
  }
  e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
function Yx(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const n = HP(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function Xx(e, t, n, r, s, i) {
  const a = [], o = s.keySet, u = s.catchall._zod, c = u.def.type, l = u.optout === "optional";
  for (const d in t) {
    if (o.has(d))
      continue;
    if (c === "never") {
      a.push(d);
      continue;
    }
    const f = u.run({ value: t[d], issues: [] }, r);
    f instanceof Promise ? e.push(f.then((h) => jc(h, n, d, t, l))) : jc(f, n, d, t, l);
  }
  return a.length && n.issues.push({
    code: "unrecognized_keys",
    keys: a,
    input: t,
    inst: i
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const kM = /* @__PURE__ */ R("$ZodObject", (e, t) => {
  if (Ve.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const o = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const u = { ...o };
        return Object.defineProperty(t, "shape", {
          value: u
        }), u;
      }
    });
  }
  const r = Cl(() => Yx(t));
  Le(e._zod, "propValues", () => {
    const o = t.shape, u = {};
    for (const c in o) {
      const l = o[c]._zod;
      if (l.values) {
        u[c] ?? (u[c] = /* @__PURE__ */ new Set());
        for (const d of l.values)
          u[c].add(d);
      }
    }
    return u;
  });
  const s = _o, i = t.catchall;
  let a;
  e._zod.parse = (o, u) => {
    a ?? (a = r.value);
    const c = o.value;
    if (!s(c))
      return o.issues.push({
        expected: "object",
        code: "invalid_type",
        input: c,
        inst: e
      }), o;
    o.value = {};
    const l = [], d = a.shape;
    for (const f of a.keys) {
      const h = d[f], p = h._zod.optout === "optional", g = h._zod.run({ value: c[f], issues: [] }, u);
      g instanceof Promise ? l.push(g.then((m) => jc(m, o, f, c, p))) : jc(g, o, f, c, p);
    }
    return i ? Xx(l, c, o, u, r.value, e) : l.length ? Promise.all(l).then(() => o) : o;
  };
}), OM = /* @__PURE__ */ R("$ZodObjectJIT", (e, t) => {
  kM.init(e, t);
  const n = e._zod.parse, r = Cl(() => Yx(t)), s = (f) => {
    const h = new KN(["shape", "payload", "ctx"]), p = r.value, g = (b) => {
      const T = rv(b);
      return `shape[${T}]._zod.run({ value: input[${T}], issues: [] }, ctx)`;
    };
    h.write("const input = payload.value;");
    const m = /* @__PURE__ */ Object.create(null);
    let _ = 0;
    for (const b of p.keys)
      m[b] = `key_${_++}`;
    h.write("const newResult = {};");
    for (const b of p.keys) {
      const T = m[b], x = rv(b), O = f[b]?._zod?.optout === "optional";
      h.write(`const ${T} = ${g(b)};`), O ? h.write(`
        if (${T}.issues.length) {
          if (${x} in input) {
            payload.issues = payload.issues.concat(${T}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${x}, ...iss.path] : [${x}]
            })));
          }
        }
        
        if (${T}.value === undefined) {
          if (${x} in input) {
            newResult[${x}] = undefined;
          }
        } else {
          newResult[${x}] = ${T}.value;
        }
        
      `) : h.write(`
        if (${T}.issues.length) {
          payload.issues = payload.issues.concat(${T}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${x}, ...iss.path] : [${x}]
          })));
        }
        
        if (${T}.value === undefined) {
          if (${x} in input) {
            newResult[${x}] = undefined;
          }
        } else {
          newResult[${x}] = ${T}.value;
        }
        
      `);
    }
    h.write("payload.value = newResult;"), h.write("return payload;");
    const y = h.compile();
    return (b, T) => y(f, b, T);
  };
  let i;
  const a = _o, o = !$x.jitless, c = o && ZP.value, l = t.catchall;
  let d;
  e._zod.parse = (f, h) => {
    d ?? (d = r.value);
    const p = f.value;
    return a(p) ? o && c && h?.async === !1 && h.jitless !== !0 ? (i || (i = s(t.shape)), f = i(f, h), l ? Xx([], p, f, h, d, e) : f) : n(f, h) : (f.issues.push({
      expected: "object",
      code: "invalid_type",
      input: p,
      inst: e
    }), f);
  };
});
function av(e, t, n, r) {
  for (const i of e)
    if (i.issues.length === 0)
      return t.value = i.value, t;
  const s = e.filter((i) => !Qs(i));
  return s.length === 1 ? (t.value = s[0].value, s[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((i) => i.issues.map((a) => Fr(a, r, Ur())))
  }), t);
}
const Qx = /* @__PURE__ */ R("$ZodUnion", (e, t) => {
  Ve.init(e, t), Le(e._zod, "optin", () => t.options.some((s) => s._zod.optin === "optional") ? "optional" : void 0), Le(e._zod, "optout", () => t.options.some((s) => s._zod.optout === "optional") ? "optional" : void 0), Le(e._zod, "values", () => {
    if (t.options.every((s) => s._zod.values))
      return new Set(t.options.flatMap((s) => Array.from(s._zod.values)));
  }), Le(e._zod, "pattern", () => {
    if (t.options.every((s) => s._zod.pattern)) {
      const s = t.options.map((i) => i._zod.pattern);
      return new RegExp(`^(${s.map((i) => Dm(i.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (s, i) => {
    if (n)
      return r(s, i);
    let a = !1;
    const o = [];
    for (const u of t.options) {
      const c = u._zod.run({
        value: s.value,
        issues: []
      }, i);
      if (c instanceof Promise)
        o.push(c), a = !0;
      else {
        if (c.issues.length === 0)
          return c;
        o.push(c);
      }
    }
    return a ? Promise.all(o).then((u) => av(u, s, e, i)) : av(o, s, e, i);
  };
}), IM = /* @__PURE__ */ R("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, Qx.init(e, t);
  const n = e._zod.parse;
  Le(e._zod, "propValues", () => {
    const s = {};
    for (const i of t.options) {
      const a = i._zod.propValues;
      if (!a || Object.keys(a).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(i)}"`);
      for (const [o, u] of Object.entries(a)) {
        s[o] || (s[o] = /* @__PURE__ */ new Set());
        for (const c of u)
          s[o].add(c);
      }
    }
    return s;
  });
  const r = Cl(() => {
    const s = t.options, i = /* @__PURE__ */ new Map();
    for (const a of s) {
      const o = a._zod.propValues?.[t.discriminator];
      if (!o || o.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(a)}"`);
      for (const u of o) {
        if (i.has(u))
          throw new Error(`Duplicate discriminator value "${String(u)}"`);
        i.set(u, a);
      }
    }
    return i;
  });
  e._zod.parse = (s, i) => {
    const a = s.value;
    if (!_o(a))
      return s.issues.push({
        code: "invalid_type",
        expected: "object",
        input: a,
        inst: e
      }), s;
    const o = r.value.get(a?.[t.discriminator]);
    return o ? o._zod.run(s, i) : t.unionFallback ? n(s, i) : (s.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: a,
      path: [t.discriminator],
      inst: e
    }), s);
  };
}), AM = /* @__PURE__ */ R("$ZodIntersection", (e, t) => {
  Ve.init(e, t), e._zod.parse = (n, r) => {
    const s = n.value, i = t.left._zod.run({ value: s, issues: [] }, r), a = t.right._zod.run({ value: s, issues: [] }, r);
    return i instanceof Promise || a instanceof Promise ? Promise.all([i, a]).then(([u, c]) => ov(n, u, c)) : ov(n, i, a);
  };
});
function sp(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (ai(e) && ai(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((i) => n.indexOf(i) !== -1), s = { ...e, ...t };
    for (const i of r) {
      const a = sp(e[i], t[i]);
      if (!a.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...a.mergeErrorPath]
        };
      s[i] = a.data;
    }
    return { valid: !0, data: s };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const s = e[r], i = t[r], a = sp(s, i);
      if (!a.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...a.mergeErrorPath]
        };
      n.push(a.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function ov(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  let s;
  for (const o of t.issues)
    if (o.code === "unrecognized_keys") {
      s ?? (s = o);
      for (const u of o.keys)
        r.has(u) || r.set(u, {}), r.get(u).l = !0;
    } else
      e.issues.push(o);
  for (const o of n.issues)
    if (o.code === "unrecognized_keys")
      for (const u of o.keys)
        r.has(u) || r.set(u, {}), r.get(u).r = !0;
    else
      e.issues.push(o);
  const i = [...r].filter(([, o]) => o.l && o.r).map(([o]) => o);
  if (i.length && s && e.issues.push({ ...s, keys: i }), Qs(e))
    return e;
  const a = sp(t.value, n.value);
  if (!a.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(a.mergeErrorPath)}`);
  return e.value = a.data, e;
}
const CM = /* @__PURE__ */ R("$ZodTuple", (e, t) => {
  Ve.init(e, t);
  const n = t.items;
  e._zod.parse = (r, s) => {
    const i = r.value;
    if (!Array.isArray(i))
      return r.issues.push({
        input: i,
        inst: e,
        expected: "tuple",
        code: "invalid_type"
      }), r;
    r.value = [];
    const a = [], o = [...n].reverse().findIndex((l) => l._zod.optin !== "optional"), u = o === -1 ? 0 : n.length - o;
    if (!t.rest) {
      const l = i.length > n.length, d = i.length < u - 1;
      if (l || d)
        return r.issues.push({
          ...l ? { code: "too_big", maximum: n.length, inclusive: !0 } : { code: "too_small", minimum: n.length },
          input: i,
          inst: e,
          origin: "array"
        }), r;
    }
    let c = -1;
    for (const l of n) {
      if (c++, c >= i.length && c >= u)
        continue;
      const d = l._zod.run({
        value: i[c],
        issues: []
      }, s);
      d instanceof Promise ? a.push(d.then((f) => ku(f, r, c))) : ku(d, r, c);
    }
    if (t.rest) {
      const l = i.slice(n.length);
      for (const d of l) {
        c++;
        const f = t.rest._zod.run({
          value: d,
          issues: []
        }, s);
        f instanceof Promise ? a.push(f.then((h) => ku(h, r, c))) : ku(f, r, c);
      }
    }
    return a.length ? Promise.all(a).then(() => r) : r;
  };
});
function ku(e, t, n) {
  e.issues.length && t.issues.push(...ps(n, e.issues)), t.value[n] = e.value;
}
const $M = /* @__PURE__ */ R("$ZodRecord", (e, t) => {
  Ve.init(e, t), e._zod.parse = (n, r) => {
    const s = n.value;
    if (!ai(s))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: s,
        inst: e
      }), n;
    const i = [], a = t.keyType._zod.values;
    if (a) {
      n.value = {};
      const o = /* @__PURE__ */ new Set();
      for (const c of a)
        if (typeof c == "string" || typeof c == "number" || typeof c == "symbol") {
          o.add(typeof c == "number" ? c.toString() : c);
          const l = t.valueType._zod.run({ value: s[c], issues: [] }, r);
          l instanceof Promise ? i.push(l.then((d) => {
            d.issues.length && n.issues.push(...ps(c, d.issues)), n.value[c] = d.value;
          })) : (l.issues.length && n.issues.push(...ps(c, l.issues)), n.value[c] = l.value);
        }
      let u;
      for (const c in s)
        o.has(c) || (u = u ?? [], u.push(c));
      u && u.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: s,
        inst: e,
        keys: u
      });
    } else {
      n.value = {};
      for (const o of Reflect.ownKeys(s)) {
        if (o === "__proto__")
          continue;
        let u = t.keyType._zod.run({ value: o, issues: [] }, r);
        if (u instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof o == "string" && Bx.test(o) && u.issues.length && u.issues.some((d) => d.code === "invalid_type" && d.expected === "number")) {
          const d = t.keyType._zod.run({ value: Number(o), issues: [] }, r);
          if (d instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          d.issues.length === 0 && (u = d);
        }
        if (u.issues.length) {
          t.mode === "loose" ? n.value[o] = s[o] : n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: u.issues.map((d) => Fr(d, r, Ur())),
            input: o,
            path: [o],
            inst: e
          });
          continue;
        }
        const l = t.valueType._zod.run({ value: s[o], issues: [] }, r);
        l instanceof Promise ? i.push(l.then((d) => {
          d.issues.length && n.issues.push(...ps(o, d.issues)), n.value[u.value] = d.value;
        })) : (l.issues.length && n.issues.push(...ps(o, l.issues)), n.value[u.value] = l.value);
      }
    }
    return i.length ? Promise.all(i).then(() => n) : n;
  };
}), RM = /* @__PURE__ */ R("$ZodEnum", (e, t) => {
  Ve.init(e, t);
  const n = Rx(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((s) => VP.has(typeof s)).map((s) => typeof s == "string" ? oi(s) : s.toString()).join("|")})$`), e._zod.parse = (s, i) => {
    const a = s.value;
    return r.has(a) || s.issues.push({
      code: "invalid_value",
      values: n,
      input: a,
      inst: e
    }), s;
  };
}), PM = /* @__PURE__ */ R("$ZodLiteral", (e, t) => {
  if (Ve.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? oi(r) : r ? oi(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, s) => {
    const i = r.value;
    return n.has(i) || r.issues.push({
      code: "invalid_value",
      values: t.values,
      input: i,
      inst: e
    }), r;
  };
}), NM = /* @__PURE__ */ R("$ZodTransform", (e, t) => {
  Ve.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new Cx(e.constructor.name);
    const s = t.transform(n.value, n);
    if (r.async)
      return (s instanceof Promise ? s : Promise.resolve(s)).then((a) => (n.value = a, n));
    if (s instanceof Promise)
      throw new ti();
    return n.value = s, n;
  };
});
function uv(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const Dl = /* @__PURE__ */ R("$ZodOptional", (e, t) => {
  Ve.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", Le(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), Le(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Dm(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      const s = t.innerType._zod.run(n, r);
      return s instanceof Promise ? s.then((i) => uv(i, n.value)) : uv(s, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), MM = /* @__PURE__ */ R("$ZodExactOptional", (e, t) => {
  Dl.init(e, t), Le(e._zod, "values", () => t.innerType._zod.values), Le(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, r) => t.innerType._zod.run(n, r);
}), jM = /* @__PURE__ */ R("$ZodNullable", (e, t) => {
  Ve.init(e, t), Le(e._zod, "optin", () => t.innerType._zod.optin), Le(e._zod, "optout", () => t.innerType._zod.optout), Le(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Dm(n.source)}|null)$`) : void 0;
  }), Le(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), LM = /* @__PURE__ */ R("$ZodDefault", (e, t) => {
  Ve.init(e, t), e._zod.optin = "optional", Le(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const s = t.innerType._zod.run(n, r);
    return s instanceof Promise ? s.then((i) => cv(i, t)) : cv(s, t);
  };
});
function cv(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const DM = /* @__PURE__ */ R("$ZodPrefault", (e, t) => {
  Ve.init(e, t), e._zod.optin = "optional", Le(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), UM = /* @__PURE__ */ R("$ZodNonOptional", (e, t) => {
  Ve.init(e, t), Le(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const s = t.innerType._zod.run(n, r);
    return s instanceof Promise ? s.then((i) => lv(i, e)) : lv(s, e);
  };
});
function lv(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const FM = /* @__PURE__ */ R("$ZodCatch", (e, t) => {
  Ve.init(e, t), Le(e._zod, "optin", () => t.innerType._zod.optin), Le(e._zod, "optout", () => t.innerType._zod.optout), Le(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const s = t.innerType._zod.run(n, r);
    return s instanceof Promise ? s.then((i) => (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((a) => Fr(a, r, Ur()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = s.value, s.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: s.issues.map((i) => Fr(i, r, Ur()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), zM = /* @__PURE__ */ R("$ZodPipe", (e, t) => {
  Ve.init(e, t), Le(e._zod, "values", () => t.in._zod.values), Le(e._zod, "optin", () => t.in._zod.optin), Le(e._zod, "optout", () => t.out._zod.optout), Le(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if (r.direction === "backward") {
      const i = t.out._zod.run(n, r);
      return i instanceof Promise ? i.then((a) => Ou(a, t.in, r)) : Ou(i, t.in, r);
    }
    const s = t.in._zod.run(n, r);
    return s instanceof Promise ? s.then((i) => Ou(i, t.out, r)) : Ou(s, t.out, r);
  };
});
function Ou(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const qM = /* @__PURE__ */ R("$ZodReadonly", (e, t) => {
  Ve.init(e, t), Le(e._zod, "propValues", () => t.innerType._zod.propValues), Le(e._zod, "values", () => t.innerType._zod.values), Le(e._zod, "optin", () => t.innerType?._zod?.optin), Le(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const s = t.innerType._zod.run(n, r);
    return s instanceof Promise ? s.then(dv) : dv(s);
  };
});
function dv(e) {
  return e.value = Object.freeze(e.value), e;
}
const BM = /* @__PURE__ */ R("$ZodCustom", (e, t) => {
  Kt.init(e, t), Ve.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, s = t.fn(r);
    if (s instanceof Promise)
      return s.then((i) => fv(i, n, r, e));
    fv(s, n, r, e);
  };
});
function fv(e, t, n, r) {
  if (!e) {
    const s = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (s.params = r._zod.def.params), t.issues.push(yo(s));
  }
}
var hv;
class ZM {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    return this._map.set(t, r), r && typeof r == "object" && "id" in r && this._idmap.set(r.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const s = { ...r, ...this._map.get(t) };
      return Object.keys(s).length ? s : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function VM() {
  return new ZM();
}
(hv = globalThis).__zod_globalRegistry ?? (hv.__zod_globalRegistry = VM());
const gt = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function HM(e, t) {
  return new e({
    type: "string",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function GM(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function pv(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function WM(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function JM(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function KM(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function YM(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function XM(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function QM(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function e2(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function t2(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function n2(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function r2(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function s2(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function i2(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function a2(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function o2(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function u2(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function c2(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function l2(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function d2(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function f2(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function h2(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function p2(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function m2(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function g2(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function _2(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function y2(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function w2(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function v2(e, t) {
  return new e({
    type: "boolean",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function eE(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function tE(e, t) {
  return new e({
    type: "never",
    ...te(t)
  });
}
// @__NO_SIDE_EFFECTS__
function mv(e, t) {
  return new Vx({
    check: "less_than",
    ...te(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function th(e, t) {
  return new Vx({
    check: "less_than",
    ...te(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function gv(e, t) {
  return new Hx({
    check: "greater_than",
    ...te(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function nh(e, t) {
  return new Hx({
    check: "greater_than",
    ...te(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _v(e, t) {
  return new DN({
    check: "multiple_of",
    ...te(t),
    value: e
  });
}
// @__NO_SIDE_EFFECTS__
function nE(e, t) {
  return new FN({
    check: "max_length",
    ...te(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function Lc(e, t) {
  return new zN({
    check: "min_length",
    ...te(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function rE(e, t) {
  return new qN({
    check: "length_equals",
    ...te(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function b2(e, t) {
  return new BN({
    check: "string_format",
    format: "regex",
    ...te(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function S2(e) {
  return new ZN({
    check: "string_format",
    format: "lowercase",
    ...te(e)
  });
}
// @__NO_SIDE_EFFECTS__
function T2(e) {
  return new VN({
    check: "string_format",
    format: "uppercase",
    ...te(e)
  });
}
// @__NO_SIDE_EFFECTS__
function x2(e, t) {
  return new HN({
    check: "string_format",
    format: "includes",
    ...te(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function E2(e, t) {
  return new GN({
    check: "string_format",
    format: "starts_with",
    ...te(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function k2(e, t) {
  return new WN({
    check: "string_format",
    format: "ends_with",
    ...te(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function yi(e) {
  return new JN({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function O2(e) {
  return /* @__PURE__ */ yi((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function I2() {
  return /* @__PURE__ */ yi((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function A2() {
  return /* @__PURE__ */ yi((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function C2() {
  return /* @__PURE__ */ yi((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function $2() {
  return /* @__PURE__ */ yi((e) => BP(e));
}
// @__NO_SIDE_EFFECTS__
function R2(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...te(n)
  });
}
// @__NO_SIDE_EFFECTS__
function P2(e, t, n) {
  const r = te(n);
  return r.abort ?? (r.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...r
  });
}
// @__NO_SIDE_EFFECTS__
function N2(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...te(n)
  });
}
// @__NO_SIDE_EFFECTS__
function M2(e) {
  const t = /* @__PURE__ */ j2((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(yo(r, n.value, t._zod.def));
    else {
      const s = r;
      s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = n.value), s.inst ?? (s.inst = t), s.continue ?? (s.continue = !t._zod.def.abort), n.issues.push(yo(s));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function j2(e, t) {
  const n = new Kt({
    check: "custom",
    ...te(t)
  });
  return n._zod.check = e, n;
}
function Dc(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? gt,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function qe(e, t, n = { path: [], schemaPath: [] }) {
  var r;
  const s = e._zod.def, i = t.seen.get(e);
  if (i)
    return i.count++, n.schemaPath.includes(e) && (i.cycle = n.path), i.schema;
  const a = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, a);
  const o = e._zod.toJSONSchema?.();
  if (o)
    a.schema = o;
  else {
    const l = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, a.schema, l);
    else {
      const f = a.schema, h = t.processors[s.type];
      if (!h)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${s.type}`);
      h(e, t, f, l);
    }
    const d = e._zod.parent;
    d && (a.ref || (a.ref = d), qe(d, t, l), t.seen.get(d).isParent = !0);
  }
  const u = t.metadataRegistry.get(e);
  return u && Object.assign(a.schema, u), t.io === "input" && Pt(e) && (delete a.schema.examples, delete a.schema.default), t.io === "input" && a.schema._prefault && ((r = a.schema).default ?? (r.default = a.schema._prefault)), delete a.schema._prefault, t.seen.get(e).schema;
}
function Uc(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = /* @__PURE__ */ new Map();
  for (const a of e.seen.entries()) {
    const o = e.metadataRegistry.get(a[0])?.id;
    if (o) {
      const u = r.get(o);
      if (u && u !== a[0])
        throw new Error(`Duplicate schema id "${o}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      r.set(o, a[0]);
    }
  }
  const s = (a) => {
    const o = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const d = e.external.registry.get(a[0])?.id, f = e.external.uri ?? ((p) => p);
      if (d)
        return { ref: f(d) };
      const h = a[1].defId ?? a[1].schema.id ?? `schema${e.counter++}`;
      return a[1].defId = h, { defId: h, ref: `${f("__shared")}#/${o}/${h}` };
    }
    if (a[1] === n)
      return { ref: "#" };
    const c = `#/${o}/`, l = a[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: l, ref: c + l };
  }, i = (a) => {
    if (a[1].schema.$ref)
      return;
    const o = a[1], { ref: u, defId: c } = s(a);
    o.def = { ...o.schema }, c && (o.defId = c);
    const l = o.schema;
    for (const d in l)
      delete l[d];
    l.$ref = u;
  };
  if (e.cycles === "throw")
    for (const a of e.seen.entries()) {
      const o = a[1];
      if (o.cycle)
        throw new Error(`Cycle detected: #/${o.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const a of e.seen.entries()) {
    const o = a[1];
    if (t === a[0]) {
      i(a);
      continue;
    }
    if (e.external) {
      const c = e.external.registry.get(a[0])?.id;
      if (t !== a[0] && c) {
        i(a);
        continue;
      }
    }
    if (e.metadataRegistry.get(a[0])?.id) {
      i(a);
      continue;
    }
    if (o.cycle) {
      i(a);
      continue;
    }
    if (o.count > 1 && e.reused === "ref") {
      i(a);
      continue;
    }
  }
}
function Fc(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (a) => {
    const o = e.seen.get(a);
    if (o.ref === null)
      return;
    const u = o.def ?? o.schema, c = { ...u }, l = o.ref;
    if (o.ref = null, l) {
      r(l);
      const f = e.seen.get(l), h = f.schema;
      if (h.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (u.allOf = u.allOf ?? [], u.allOf.push(h)) : Object.assign(u, h), Object.assign(u, c), a._zod.parent === l)
        for (const g in u)
          g === "$ref" || g === "allOf" || g in c || delete u[g];
      if (h.$ref)
        for (const g in u)
          g === "$ref" || g === "allOf" || g in f.def && JSON.stringify(u[g]) === JSON.stringify(f.def[g]) && delete u[g];
    }
    const d = a._zod.parent;
    if (d && d !== l) {
      r(d);
      const f = e.seen.get(d);
      if (f?.schema.$ref && (u.$ref = f.schema.$ref, f.def))
        for (const h in u)
          h === "$ref" || h === "allOf" || h in f.def && JSON.stringify(u[h]) === JSON.stringify(f.def[h]) && delete u[h];
    }
    e.override({
      zodSchema: a,
      jsonSchema: u,
      path: o.path ?? []
    });
  };
  for (const a of [...e.seen.entries()].reverse())
    r(a[0]);
  const s = {};
  if (e.target === "draft-2020-12" ? s.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? s.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? s.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const a = e.external.registry.get(t)?.id;
    if (!a)
      throw new Error("Schema is missing an `id` property");
    s.$id = e.external.uri(a);
  }
  Object.assign(s, n.def ?? n.schema);
  const i = e.external?.defs ?? {};
  for (const a of e.seen.entries()) {
    const o = a[1];
    o.def && o.defId && (i[o.defId] = o.def);
  }
  e.external || Object.keys(i).length > 0 && (e.target === "draft-2020-12" ? s.$defs = i : s.definitions = i);
  try {
    const a = JSON.parse(JSON.stringify(s));
    return Object.defineProperty(a, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: zc(t, "input", e.processors),
          output: zc(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), a;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function Pt(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return Pt(r.element, n);
  if (r.type === "set")
    return Pt(r.valueType, n);
  if (r.type === "lazy")
    return Pt(r.getter(), n);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return Pt(r.innerType, n);
  if (r.type === "intersection")
    return Pt(r.left, n) || Pt(r.right, n);
  if (r.type === "record" || r.type === "map")
    return Pt(r.keyType, n) || Pt(r.valueType, n);
  if (r.type === "pipe")
    return Pt(r.in, n) || Pt(r.out, n);
  if (r.type === "object") {
    for (const s in r.shape)
      if (Pt(r.shape[s], n))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const s of r.options)
      if (Pt(s, n))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const s of r.items)
      if (Pt(s, n))
        return !0;
    return !!(r.rest && Pt(r.rest, n));
  }
  return !1;
}
const L2 = (e, t = {}) => (n) => {
  const r = Dc({ ...n, processors: t });
  return qe(e, r), Uc(r, e), Fc(r, e);
}, zc = (e, t, n = {}) => (r) => {
  const { libraryOptions: s, target: i } = r ?? {}, a = Dc({ ...s ?? {}, target: i, io: t, processors: n });
  return qe(e, a), Uc(a, e), Fc(a, e);
}, D2 = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, sE = (e, t, n, r) => {
  const s = n;
  s.type = "string";
  const { minimum: i, maximum: a, format: o, patterns: u, contentEncoding: c } = e._zod.bag;
  if (typeof i == "number" && (s.minLength = i), typeof a == "number" && (s.maxLength = a), o && (s.format = D2[o] ?? o, s.format === "" && delete s.format, o === "time" && delete s.format), c && (s.contentEncoding = c), u && u.size > 0) {
    const l = [...u];
    l.length === 1 ? s.pattern = l[0].source : l.length > 1 && (s.allOf = [
      ...l.map((d) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: d.source
      }))
    ]);
  }
}, iE = (e, t, n, r) => {
  const s = n, { minimum: i, maximum: a, format: o, multipleOf: u, exclusiveMaximum: c, exclusiveMinimum: l } = e._zod.bag;
  typeof o == "string" && o.includes("int") ? s.type = "integer" : s.type = "number", typeof l == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (s.minimum = l, s.exclusiveMinimum = !0) : s.exclusiveMinimum = l), typeof i == "number" && (s.minimum = i, typeof l == "number" && t.target !== "draft-04" && (l >= i ? delete s.minimum : delete s.exclusiveMinimum)), typeof c == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (s.maximum = c, s.exclusiveMaximum = !0) : s.exclusiveMaximum = c), typeof a == "number" && (s.maximum = a, typeof c == "number" && t.target !== "draft-04" && (c <= a ? delete s.maximum : delete s.exclusiveMaximum)), typeof u == "number" && (s.multipleOf = u);
}, aE = (e, t, n, r) => {
  n.type = "boolean";
}, U2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, F2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, z2 = (e, t, n, r) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, q2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, B2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, oE = (e, t, n, r) => {
  n.not = {};
}, Z2 = (e, t, n, r) => {
}, uE = (e, t, n, r) => {
}, V2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, cE = (e, t, n, r) => {
  const s = e._zod.def, i = Rx(s.entries);
  i.every((a) => typeof a == "number") && (n.type = "number"), i.every((a) => typeof a == "string") && (n.type = "string"), n.enum = i;
}, lE = (e, t, n, r) => {
  const s = e._zod.def, i = [];
  for (const a of s.values)
    if (a === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof a == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      i.push(Number(a));
    } else
      i.push(a);
  if (i.length !== 0) if (i.length === 1) {
    const a = i[0];
    n.type = a === null ? "null" : typeof a, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [a] : n.const = a;
  } else
    i.every((a) => typeof a == "number") && (n.type = "number"), i.every((a) => typeof a == "string") && (n.type = "string"), i.every((a) => typeof a == "boolean") && (n.type = "boolean"), i.every((a) => a === null) && (n.type = "null"), n.enum = i;
}, H2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, G2 = (e, t, n, r) => {
  const s = n, i = e._zod.pattern;
  if (!i)
    throw new Error("Pattern not found in template literal");
  s.type = "string", s.pattern = i.source;
}, W2 = (e, t, n, r) => {
  const s = n, i = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: a, maximum: o, mime: u } = e._zod.bag;
  a !== void 0 && (i.minLength = a), o !== void 0 && (i.maxLength = o), u ? u.length === 1 ? (i.contentMediaType = u[0], Object.assign(s, i)) : (Object.assign(s, i), s.anyOf = u.map((c) => ({ contentMediaType: c }))) : Object.assign(s, i);
}, J2 = (e, t, n, r) => {
  n.type = "boolean";
}, dE = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, K2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, fE = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, Y2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, X2 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, hE = (e, t, n, r) => {
  const s = n, i = e._zod.def, { minimum: a, maximum: o } = e._zod.bag;
  typeof a == "number" && (s.minItems = a), typeof o == "number" && (s.maxItems = o), s.type = "array", s.items = qe(i.element, t, { ...r, path: [...r.path, "items"] });
}, pE = (e, t, n, r) => {
  const s = n, i = e._zod.def;
  s.type = "object", s.properties = {};
  const a = i.shape;
  for (const c in a)
    s.properties[c] = qe(a[c], t, {
      ...r,
      path: [...r.path, "properties", c]
    });
  const o = new Set(Object.keys(a)), u = new Set([...o].filter((c) => {
    const l = i.shape[c]._zod;
    return t.io === "input" ? l.optin === void 0 : l.optout === void 0;
  }));
  u.size > 0 && (s.required = Array.from(u)), i.catchall?._zod.def.type === "never" ? s.additionalProperties = !1 : i.catchall ? i.catchall && (s.additionalProperties = qe(i.catchall, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  })) : t.io === "output" && (s.additionalProperties = !1);
}, mE = (e, t, n, r) => {
  const s = e._zod.def, i = s.inclusive === !1, a = s.options.map((o, u) => qe(o, t, {
    ...r,
    path: [...r.path, i ? "oneOf" : "anyOf", u]
  }));
  i ? n.oneOf = a : n.anyOf = a;
}, gE = (e, t, n, r) => {
  const s = e._zod.def, i = qe(s.left, t, {
    ...r,
    path: [...r.path, "allOf", 0]
  }), a = qe(s.right, t, {
    ...r,
    path: [...r.path, "allOf", 1]
  }), o = (c) => "allOf" in c && Object.keys(c).length === 1, u = [
    ...o(i) ? i.allOf : [i],
    ...o(a) ? a.allOf : [a]
  ];
  n.allOf = u;
}, _E = (e, t, n, r) => {
  const s = n, i = e._zod.def;
  s.type = "array";
  const a = t.target === "draft-2020-12" ? "prefixItems" : "items", o = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", u = i.items.map((f, h) => qe(f, t, {
    ...r,
    path: [...r.path, a, h]
  })), c = i.rest ? qe(i.rest, t, {
    ...r,
    path: [...r.path, o, ...t.target === "openapi-3.0" ? [i.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (s.prefixItems = u, c && (s.items = c)) : t.target === "openapi-3.0" ? (s.items = {
    anyOf: u
  }, c && s.items.anyOf.push(c), s.minItems = u.length, c || (s.maxItems = u.length)) : (s.items = u, c && (s.additionalItems = c));
  const { minimum: l, maximum: d } = e._zod.bag;
  typeof l == "number" && (s.minItems = l), typeof d == "number" && (s.maxItems = d);
}, yE = (e, t, n, r) => {
  const s = n, i = e._zod.def;
  s.type = "object";
  const a = i.keyType, u = a._zod.bag?.patterns;
  if (i.mode === "loose" && u && u.size > 0) {
    const l = qe(i.valueType, t, {
      ...r,
      path: [...r.path, "patternProperties", "*"]
    });
    s.patternProperties = {};
    for (const d of u)
      s.patternProperties[d.source] = l;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (s.propertyNames = qe(i.keyType, t, {
      ...r,
      path: [...r.path, "propertyNames"]
    })), s.additionalProperties = qe(i.valueType, t, {
      ...r,
      path: [...r.path, "additionalProperties"]
    });
  const c = a._zod.values;
  if (c) {
    const l = [...c].filter((d) => typeof d == "string" || typeof d == "number");
    l.length > 0 && (s.required = l);
  }
}, wE = (e, t, n, r) => {
  const s = e._zod.def, i = qe(s.innerType, t, r), a = t.seen.get(e);
  t.target === "openapi-3.0" ? (a.ref = s.innerType, n.nullable = !0) : n.anyOf = [i, { type: "null" }];
}, vE = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType;
}, bE = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType, n.default = JSON.parse(JSON.stringify(s.defaultValue));
}, SE = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(s.defaultValue)));
}, TE = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType;
  let a;
  try {
    a = s.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = a;
}, xE = (e, t, n, r) => {
  const s = e._zod.def, i = t.io === "input" ? s.in._zod.def.type === "transform" ? s.out : s.in : s.out;
  qe(i, t, r);
  const a = t.seen.get(e);
  a.ref = i;
}, EE = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType, n.readOnly = !0;
}, Q2 = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType;
}, zm = (e, t, n, r) => {
  const s = e._zod.def;
  qe(s.innerType, t, r);
  const i = t.seen.get(e);
  i.ref = s.innerType;
}, ej = (e, t, n, r) => {
  const s = e._zod.innerType;
  qe(s, t, r);
  const i = t.seen.get(e);
  i.ref = s;
}, yv = {
  string: sE,
  number: iE,
  boolean: aE,
  bigint: U2,
  symbol: F2,
  null: z2,
  undefined: q2,
  void: B2,
  never: oE,
  any: Z2,
  unknown: uE,
  date: V2,
  enum: cE,
  literal: lE,
  nan: H2,
  template_literal: G2,
  file: W2,
  success: J2,
  custom: dE,
  function: K2,
  transform: fE,
  map: Y2,
  set: X2,
  array: hE,
  object: pE,
  union: mE,
  intersection: gE,
  tuple: _E,
  record: yE,
  nullable: wE,
  nonoptional: vE,
  default: bE,
  prefault: SE,
  catch: TE,
  pipe: xE,
  readonly: EE,
  promise: Q2,
  optional: zm,
  lazy: ej
};
function ip(e, t) {
  if ("_idmap" in e) {
    const r = e, s = Dc({ ...t, processors: yv }), i = {};
    for (const u of r._idmap.entries()) {
      const [c, l] = u;
      qe(l, s);
    }
    const a = {}, o = {
      registry: r,
      uri: t?.uri,
      defs: i
    };
    s.external = o;
    for (const u of r._idmap.entries()) {
      const [c, l] = u;
      Uc(s, l), a[c] = Fc(s, l);
    }
    if (Object.keys(i).length > 0) {
      const u = s.target === "draft-2020-12" ? "$defs" : "definitions";
      a.__shared = {
        [u]: i
      };
    }
    return { schemas: a };
  }
  const n = Dc({ ...t, processors: yv });
  return qe(e, n), Uc(n, e), Fc(n, e);
}
function Ke(e) {
  if (typeof e != "object" || e === null) return !1;
  const t = e;
  if (!("_zod" in t)) return !1;
  const n = t._zod;
  return typeof n == "object" && n !== null && "def" in n;
}
function ot(e) {
  if (typeof e != "object" || e === null) return !1;
  const t = e;
  if (!("_def" in t) || "_zod" in t) return !1;
  const n = t._def;
  return typeof n == "object" && n != null && "typeName" in n;
}
function tj(e) {
  return Ke(e) && console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior."), ot(e);
}
function _t(e) {
  return !e || typeof e != "object" || Array.isArray(e) ? !1 : !!(Ke(e) || ot(e));
}
function kE(e) {
  return typeof e == "object" && e !== null && "_def" in e && typeof e._def == "object" && e._def !== null && "typeName" in e._def && e._def.typeName === "ZodLiteral";
}
function OE(e) {
  return Ke(e) ? typeof e == "object" && e !== null && "_zod" in e && typeof e._zod == "object" && e._zod !== null && "def" in e._zod && typeof e._zod.def == "object" && e._zod.def !== null && "type" in e._zod.def && e._zod.def.type === "literal" : !1;
}
function nj(e) {
  return !!(kE(e) || OE(e));
}
async function Ul(e, t) {
  if (Ke(e)) try {
    return {
      success: !0,
      data: await Ux(e, t)
    };
  } catch (n) {
    return {
      success: !1,
      error: n
    };
  }
  if (ot(e)) return await e.safeParseAsync(t);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
async function Fl(e, t) {
  if (Ke(e)) return await Ux(e, t);
  if (ot(e)) return await e.parseAsync(t);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function rj(e, t) {
  if (Ke(e)) try {
    return {
      success: !0,
      data: Pl(e, t)
    };
  } catch (n) {
    return {
      success: !1,
      error: n
    };
  }
  if (ot(e)) return e.safeParse(t);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function sj(e, t) {
  if (Ke(e)) return Pl(e, t);
  if (ot(e)) return e.parse(t);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function zl(e) {
  if (Ke(e)) return gt.get(e)?.description;
  if (ot(e) || "description" in e && typeof e.description == "string") return e.description;
}
function ij(e) {
  if (!_t(e)) return !1;
  if (ot(e)) {
    const t = e._def;
    if (t.typeName === "ZodObject") {
      const n = e;
      return !n.shape || Object.keys(n.shape).length === 0;
    }
    if (t.typeName === "ZodRecord") return !0;
  }
  if (Ke(e)) {
    const t = e._zod.def;
    if (t.type === "object") {
      const n = e;
      return !n.shape || Object.keys(n.shape).length === 0;
    }
    if (t.type === "record") return !0;
  }
  return typeof e == "object" && e !== null && !("shape" in e);
}
function qm(e) {
  return _t(e) ? ot(e) ? e._def.typeName === "ZodString" : Ke(e) ? e._zod.def.type === "string" : !1 : !1;
}
function Bm(e) {
  return typeof e == "object" && e !== null && "_def" in e && typeof e._def == "object" && e._def !== null && "typeName" in e._def && e._def.typeName === "ZodObject";
}
function Wn(e) {
  return Ke(e) ? typeof e == "object" && e !== null && "_zod" in e && typeof e._zod == "object" && e._zod !== null && "def" in e._zod && typeof e._zod.def == "object" && e._zod.def !== null && "type" in e._zod.def && e._zod.def.type === "object" : !1;
}
function ql(e) {
  return Ke(e) ? typeof e == "object" && e !== null && "_zod" in e && typeof e._zod == "object" && e._zod !== null && "def" in e._zod && typeof e._zod.def == "object" && e._zod.def !== null && "type" in e._zod.def && e._zod.def.type === "array" : !1;
}
function IE(e) {
  return Ke(e) ? typeof e == "object" && e !== null && "_zod" in e && typeof e._zod == "object" && e._zod !== null && "def" in e._zod && typeof e._zod.def == "object" && e._zod.def !== null && "type" in e._zod.def && e._zod.def.type === "optional" : !1;
}
function AE(e) {
  return Ke(e) ? typeof e == "object" && e !== null && "_zod" in e && typeof e._zod == "object" && e._zod !== null && "def" in e._zod && typeof e._zod.def == "object" && e._zod.def !== null && "type" in e._zod.def && e._zod.def.type === "nullable" : !1;
}
function aj(e) {
  return !!(Bm(e) || Wn(e));
}
function ap(e) {
  if (ot(e)) return e.shape;
  if (Ke(e)) return e._zod.def.shape;
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function oj(e, t) {
  if (ot(e)) return e.extend(t);
  if (Ke(e)) return Mx(e, t);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function uj(e) {
  if (ot(e)) return e.partial();
  if (Ke(e)) return jx(Dl, e, void 0);
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function qc(e, t = !1) {
  if (ot(e)) return e.strict();
  if (Wn(e)) {
    const n = e._zod.def.shape;
    if (t) for (const [i, a] of Object.entries(e._zod.def.shape)) {
      if (Wn(a)) {
        const u = qc(a, t);
        n[i] = u;
      } else if (ql(a)) {
        let u = a._zod.def.element;
        Wn(u) && (u = qc(u, t)), n[i] = Et(a, {
          ...a._zod.def,
          element: u
        });
      } else n[i] = a;
      const o = gt.get(a);
      o && gt.add(n[i], o);
    }
    const r = Et(e, {
      ...e._zod.def,
      shape: n,
      catchall: /* @__PURE__ */ tE(Kx)
    }), s = gt.get(e);
    return s && gt.add(r, s), r;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function op(e, t = !1) {
  if (Bm(e)) return e.passthrough();
  if (Wn(e)) {
    const n = e._zod.def.shape;
    if (t) for (const [i, a] of Object.entries(e._zod.def.shape)) {
      if (Wn(a)) {
        const u = op(a, t);
        n[i] = u;
      } else if (ql(a)) {
        let u = a._zod.def.element;
        Wn(u) && (u = op(u, t)), n[i] = Et(a, {
          ...a._zod.def,
          element: u
        });
      } else n[i] = a;
      const o = gt.get(a);
      o && gt.add(n[i], o);
    }
    const r = Et(e, {
      ...e._zod.def,
      shape: n,
      catchall: /* @__PURE__ */ eE(Jx)
    }), s = gt.get(e);
    return s && gt.add(r, s), r;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function cj(e) {
  if (ot(e)) try {
    const t = e.parse(void 0);
    return () => t;
  } catch {
    return;
  }
  if (Ke(e)) try {
    const t = Pl(e, void 0);
    return () => t;
  } catch {
    return;
  }
}
function lj(e) {
  return ot(e) && "typeName" in e._def && e._def.typeName === "ZodEffects";
}
function dj(e) {
  return Ke(e) && e._zod.def.type === "pipe";
}
function is(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (ot(e))
    return lj(e) ? is(e._def.schema, t, n) : e;
  if (Ke(e)) {
    let s = e;
    if (dj(e) && (s = is(e._zod.def.in, t, n)), t) {
      if (Wn(s)) {
        const a = {};
        for (const [o, u] of Object.entries(s._zod.def.shape)) a[o] = is(u, t, n);
        s = Et(s, {
          ...s._zod.def,
          shape: a
        });
      } else if (ql(s)) {
        const a = is(s._zod.def.element, t, n);
        s = Et(s, {
          ...s._zod.def,
          element: a
        });
      } else if (IE(s)) {
        const a = is(s._zod.def.innerType, t, n);
        s = Et(s, {
          ...s._zod.def,
          innerType: a
        });
      } else if (AE(s)) {
        const a = is(s._zod.def.innerType, t, n);
        s = Et(s, {
          ...s._zod.def,
          innerType: a
        });
      }
    }
    const i = gt.get(e);
    return i && gt.add(s, i), n.set(e, s), s;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function CE(e, t = !1) {
  return is(e, t, /* @__PURE__ */ new WeakMap());
}
function fj(e, t) {
  if (ot(e)) {
    const n = ap(e), r = {};
    for (const [s, i] of Object.entries(n)) t(s, i) ? r[s] = i.optional() : r[s] = i;
    return e.extend(r);
  }
  if (Ke(e)) {
    const n = ap(e), r = { ...e._zod.def.shape };
    for (const [a, o] of Object.entries(n)) t(a, o) && (r[a] = new Dl({
      type: "optional",
      innerType: o
    }));
    const s = Et(e, {
      ...e._zod.def,
      shape: r
    }), i = gt.get(e);
    return i && gt.add(s, i), s;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function $E(e) {
  return e instanceof Error && (e.constructor.name === "ZodError" || e.constructor.name === "$ZodError");
}
function rh(e) {
  return e.replace(/[^a-zA-Z-_0-9]/g, "_");
}
const hj = [
  "*",
  "_",
  "`"
];
function pj(e) {
  let t = "";
  for (const [n, r] of Object.entries(e)) t += `	classDef ${n} ${r};
`;
  return t;
}
function mj(e, t, n) {
  const { firstNode: r, lastNode: s, nodeColors: i, withStyles: a = !0, curveStyle: o = "linear", wrapLabelNWords: u = 9 } = n ?? {};
  let c = a ? `%%{init: {'flowchart': {'curve': '${o}'}}}%%
graph TD;
` : `graph TD;
`;
  if (a) {
    const p = "default", g = { [p]: "{0}({1})" };
    r !== void 0 && (g[r] = "{0}([{1}]):::first"), s !== void 0 && (g[s] = "{0}([{1}]):::last");
    for (const [m, _] of Object.entries(e)) {
      const y = _.name.split(":").pop() ?? "";
      let T = hj.some((k) => y.startsWith(k) && y.endsWith(k)) ? `<p>${y}</p>` : y;
      Object.keys(_.metadata ?? {}).length && (T += `<hr/><small><em>${Object.entries(_.metadata ?? {}).map(([k, O]) => `${k} = ${O}`).join(`
`)}</em></small>`);
      const x = (g[m] ?? g[p]).replace("{0}", rh(m)).replace("{1}", T);
      c += `	${x}
`;
    }
  }
  const l = {};
  for (const p of t) {
    const g = p.source.split(":"), m = p.target.split(":"), _ = g.filter((y, b) => y === m[b]).join(":");
    l[_] || (l[_] = []), l[_].push(p);
  }
  const d = /* @__PURE__ */ new Set();
  function f(p) {
    return [...p].sort((g, m) => g.split(":").length - m.split(":").length);
  }
  function h(p, g) {
    const m = p.length === 1 && p[0].source === p[0].target;
    if (g && !m) {
      const y = g.split(":").pop();
      if (d.has(g)) throw new Error(`Found duplicate subgraph '${y}' at '${g} -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      d.add(g), c += `	subgraph ${y}
`;
    }
    const _ = f(Object.keys(l).filter((y) => y.startsWith(`${g}:`) && y !== g && y.split(":").length === g.split(":").length + 1));
    for (const y of _) h(l[y], y);
    for (const y of p) {
      const { source: b, target: T, data: x, conditional: k } = y;
      let O = "";
      if (x !== void 0) {
        let S = x;
        const j = S.split(" ");
        j.length > u && (S = Array.from({ length: Math.ceil(j.length / u) }, (U, G) => j.slice(G * u, (G + 1) * u).join(" ")).join("&nbsp;<br>&nbsp;")), O = k ? ` -. &nbsp;${S}&nbsp; .-> ` : ` -- &nbsp;${S}&nbsp; --> `;
      } else O = k ? " -.-> " : " --> ";
      c += `	${rh(b)}${O}${rh(T)};
`;
    }
    g && !m && (c += `	end
`);
  }
  h(l[""] ?? [], "");
  for (const p in l) !p.includes(":") && p !== "" && h(l[p], p);
  return a && (c += pj(i ?? {})), c;
}
async function gj(e, t) {
  let n = t?.backgroundColor ?? "white";
  const r = t?.imageType ?? "png", s = zP(e);
  n !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(n) || (n = `!${n}`));
  const i = `https://mermaid.ink/img/${s}?bgColor=${n}&type=${r}`, a = await fetch(i);
  if (!a.ok) throw new Error([
    "Failed to render the graph using the Mermaid.INK API.",
    `Status code: ${a.status}`,
    `Status text: ${a.statusText}`
  ].join(`
`));
  return await a.blob();
}
const _j = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use"), yj = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
}, wj = (e) => ({
  ...yj,
  ...e
}), vj = (e) => {
  const t = wj(e), n = t.name !== void 0 ? [
    ...t.basePath,
    t.definitionPath,
    t.name
  ] : t.basePath;
  return {
    ...t,
    flags: { hasReferencedOpenAiAnyType: !1 },
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(Object.entries(t.definitions).map(([r, s]) => [s._def, {
      def: s._def,
      path: [
        ...t.basePath,
        t.definitionPath,
        r
      ],
      jsonSchema: void 0
    }]))
  };
}, RE = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++) ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
};
function cn(e) {
  if (e.target !== "openAi") return {};
  const t = [
    ...e.basePath,
    e.definitionPath,
    e.openAiAnyTypeName
  ];
  return e.flags.hasReferencedOpenAiAnyType = !0, { $ref: e.$refStrategy === "relative" ? RE(t, e.currentPath) : t.join("/") };
}
function PE(e, t, n, r) {
  r?.errorMessages && n && (e.errorMessage = {
    ...e.errorMessage,
    [t]: n
  });
}
function Ue(e, t, n, r, s) {
  e[t] = n, PE(e, t, r, s);
}
var Me;
(function(e) {
  e.assertEqual = (s) => {
  };
  function t(s) {
  }
  e.assertIs = t;
  function n(s) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, e.getValidEnumValues = (s) => {
    const i = e.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), a = {};
    for (const o of i)
      a[o] = s[o];
    return e.objectValues(a);
  }, e.objectValues = (s) => e.objectKeys(s).map(function(i) {
    return s[i];
  }), e.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, e.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, e.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;
  function r(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(Me || (Me = {}));
var wv;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(wv || (wv = {}));
const X = Me.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), $r = (e) => {
  switch (typeof e) {
    case "undefined":
      return X.undefined;
    case "string":
      return X.string;
    case "number":
      return Number.isNaN(e) ? X.nan : X.number;
    case "boolean":
      return X.boolean;
    case "function":
      return X.function;
    case "bigint":
      return X.bigint;
    case "symbol":
      return X.symbol;
    case "object":
      return Array.isArray(e) ? X.array : e === null ? X.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? X.promise : typeof Map < "u" && e instanceof Map ? X.map : typeof Set < "u" && e instanceof Set ? X.set : typeof Date < "u" && e instanceof Date ? X.date : X.object;
    default:
      return X.unknown;
  }
}, M = Me.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class pr extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(i) {
      return i.message;
    }, r = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          r._errors.push(n(a));
        else {
          let o = r, u = 0;
          for (; u < a.path.length; ) {
            const c = a.path[u];
            u === a.path.length - 1 ? (o[c] = o[c] || { _errors: [] }, o[c]._errors.push(n(a))) : o[c] = o[c] || { _errors: [] }, o = o[c], u++;
          }
        }
    };
    return s(this), r;
  }
  static assert(t) {
    if (!(t instanceof pr))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Me.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = /* @__PURE__ */ Object.create(null), r = [];
    for (const s of this.issues)
      if (s.path.length > 0) {
        const i = s.path[0];
        n[i] = n[i] || [], n[i].push(t(s));
      } else
        r.push(t(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
pr.create = (e) => new pr(e);
const up = (e, t) => {
  let n;
  switch (e.code) {
    case M.invalid_type:
      e.received === X.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case M.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, Me.jsonStringifyReplacer)}`;
      break;
    case M.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Me.joinValues(e.keys, ", ")}`;
      break;
    case M.invalid_union:
      n = "Invalid input";
      break;
    case M.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Me.joinValues(e.options)}`;
      break;
    case M.invalid_enum_value:
      n = `Invalid enum value. Expected ${Me.joinValues(e.options)}, received '${e.received}'`;
      break;
    case M.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case M.invalid_return_type:
      n = "Invalid function return type";
      break;
    case M.invalid_date:
      n = "Invalid date";
      break;
    case M.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : Me.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case M.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "bigint" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case M.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case M.custom:
      n = "Invalid input";
      break;
    case M.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case M.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case M.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, Me.assertNever(e);
  }
  return { message: n };
};
let bj = up;
function Sj() {
  return bj;
}
const Tj = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: s } = e, i = [...n, ...s.path || []], a = {
    ...s,
    path: i
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: i,
      message: s.message
    };
  let o = "";
  const u = r.filter((c) => !!c).slice().reverse();
  for (const c of u)
    o = c(a, { data: t, defaultError: o }).message;
  return {
    ...s,
    path: i,
    message: o
  };
};
function H(e, t) {
  const n = Sj(), r = Tj({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === up ? void 0 : up
      // then global default map
    ].filter((s) => !!s)
  });
  e.common.issues.push(r);
}
class ln {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return be;
      s.status === "dirty" && t.dirty(), r.push(s.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const s of n) {
      const i = await s.key, a = await s.value;
      r.push({
        key: i,
        value: a
      });
    }
    return ln.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const s of n) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return be;
      i.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), i.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) && (r[i.value] = a.value);
    }
    return { status: t.value, value: r };
  }
}
const be = Object.freeze({
  status: "aborted"
}), Va = (e) => ({ status: "dirty", value: e }), vn = (e) => ({ status: "valid", value: e }), vv = (e) => e.status === "aborted", bv = (e) => e.status === "dirty", ui = (e) => e.status === "valid", Bc = (e) => typeof Promise < "u" && e instanceof Promise;
var Q;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(Q || (Q = {}));
class zr {
  constructor(t, n, r, s) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Sv = (e, t) => {
  if (ui(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new pr(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function ke(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: s } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: s } : { errorMap: (a, o) => {
    const { message: u } = e;
    return a.code === "invalid_enum_value" ? { message: u ?? o.defaultError } : typeof o.data > "u" ? { message: u ?? r ?? o.defaultError } : a.code !== "invalid_type" ? { message: o.defaultError } : { message: u ?? n ?? o.defaultError };
  }, description: s };
}
let Pe = class {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return $r(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: $r(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new ln(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: $r(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Bc(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    const r = {
      common: {
        issues: [],
        async: n?.async ?? !1,
        contextualErrorMap: n?.errorMap
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: $r(t)
    }, s = this._parseSync({ data: t, path: r.path, parent: r });
    return Sv(r, s);
  }
  "~validate"(t) {
    const n = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: $r(t)
    };
    if (!this["~standard"].async)
      try {
        const r = this._parseSync({ data: t, path: [], parent: n });
        return ui(r) ? {
          value: r.value
        } : {
          issues: n.common.issues
        };
      } catch (r) {
        r?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), n.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: t, path: [], parent: n }).then((r) => ui(r) ? {
      value: r.value
    } : {
      issues: n.common.issues
    });
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n?.errorMap,
        async: !0
      },
      path: n?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: $r(t)
    }, s = this._parse({ data: t, path: r.path, parent: r }), i = await (Bc(s) ? s : Promise.resolve(s));
    return Sv(r, i);
  }
  refine(t, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, i) => {
      const a = t(s), o = () => i.addIssue({
        code: M.custom,
        ...r(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((u) => u ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, s) => t(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(t) {
    return new li({
      schema: this,
      typeName: $.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return Mr.create(this, this._def);
  }
  nullable() {
    return di.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ci.create(this);
  }
  promise() {
    return Gc.create(this, this._def);
  }
  or(t) {
    return Vc.create([this, t], this._def);
  }
  and(t) {
    return Hc.create(this, t, this._def);
  }
  transform(t) {
    return new li({
      ...ke(this._def),
      schema: this,
      typeName: $.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new pp({
      ...ke(this._def),
      innerType: this,
      defaultValue: n,
      typeName: $.ZodDefault
    });
  }
  brand() {
    return new Hj({
      typeName: $.ZodBranded,
      type: this,
      ...ke(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new mp({
      ...ke(this._def),
      innerType: this,
      catchValue: n,
      typeName: $.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Vm.create(this, t);
  }
  readonly() {
    return gp.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const xj = /^c[^\s-]{8,}$/i, Ej = /^[0-9a-z]+$/, kj = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Oj = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Ij = /^[a-z0-9_-]{21}$/i, Aj = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, Cj = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, $j = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Rj = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let sh;
const Pj = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Nj = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Mj = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, jj = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Lj = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Dj = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, NE = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Uj = new RegExp(`^${NE}$`);
function ME(e) {
  let t = "[0-5]\\d";
  e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`);
  const n = e.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${t})${n}`;
}
function Fj(e) {
  return new RegExp(`^${ME(e)}$`);
}
function zj(e) {
  let t = `${NE}T${ME(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
}
function qj(e, t) {
  return !!((t === "v4" || !t) && Pj.test(e) || (t === "v6" || !t) && Mj.test(e));
}
function Bj(e, t) {
  if (!Aj.test(e))
    return !1;
  try {
    const [n] = e.split(".");
    if (!n)
      return !1;
    const r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), s = JSON.parse(atob(r));
    return !(typeof s != "object" || s === null || "typ" in s && s?.typ !== "JWT" || !s.alg || t && s.alg !== t);
  } catch {
    return !1;
  }
}
function Zj(e, t) {
  return !!((t === "v4" || !t) && Nj.test(e) || (t === "v6" || !t) && jj.test(e));
}
let cp = class Ha extends Pe {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== X.string) {
      const i = this._getOrReturnCtx(t);
      return H(i, {
        code: M.invalid_type,
        expected: X.string,
        received: i.parsedType
      }), be;
    }
    const r = new ln();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        t.data.length < i.value && (s = this._getOrReturnCtx(t, s), H(s, {
          code: M.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        t.data.length > i.value && (s = this._getOrReturnCtx(t, s), H(s, {
          code: M.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const a = t.data.length > i.value, o = t.data.length < i.value;
        (a || o) && (s = this._getOrReturnCtx(t, s), a ? H(s, {
          code: M.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && H(s, {
          code: M.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        $j.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "email",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        sh || (sh = new RegExp(Rj, "u")), sh.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "emoji",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        Oj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "uuid",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "nanoid")
        Ij.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "nanoid",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        xj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "cuid",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        Ej.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "cuid2",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        kj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
          validation: "ulid",
          code: M.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(t.data);
        } catch {
          s = this._getOrReturnCtx(t, s), H(s, {
            validation: "url",
            code: M.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "regex",
        code: M.invalid_string,
        message: i.message
      }), r.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), r.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "datetime" ? zj(i).test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.invalid_string,
        validation: "datetime",
        message: i.message
      }), r.dirty()) : i.kind === "date" ? Uj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.invalid_string,
        validation: "date",
        message: i.message
      }), r.dirty()) : i.kind === "time" ? Fj(i).test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.invalid_string,
        validation: "time",
        message: i.message
      }), r.dirty()) : i.kind === "duration" ? Cj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "duration",
        code: M.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "ip" ? qj(t.data, i.version) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "ip",
        code: M.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "jwt" ? Bj(t.data, i.alg) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "jwt",
        code: M.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "cidr" ? Zj(t.data, i.version) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "cidr",
        code: M.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64" ? Lj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "base64",
        code: M.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64url" ? Dj.test(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        validation: "base64url",
        code: M.invalid_string,
        message: i.message
      }), r.dirty()) : Me.assertNever(i);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((s) => t.test(s), {
      validation: n,
      code: M.invalid_string,
      ...Q.errToObj(r)
    });
  }
  _addCheck(t) {
    return new Ha({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Q.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Q.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Q.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Q.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...Q.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Q.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Q.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Q.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...Q.errToObj(t) });
  }
  base64url(t) {
    return this._addCheck({
      kind: "base64url",
      ...Q.errToObj(t)
    });
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...Q.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Q.errToObj(t) });
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...Q.errToObj(t) });
  }
  datetime(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: t?.offset ?? !1,
      local: t?.local ?? !1,
      ...Q.errToObj(t?.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      ...Q.errToObj(t?.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...Q.errToObj(t) });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Q.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n?.position,
      ...Q.errToObj(n?.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Q.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Q.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Q.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Q.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Q.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(t) {
    return this.min(1, Q.errToObj(t));
  }
  trim() {
    return new Ha({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Ha({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Ha({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
cp.create = (e) => new cp({
  checks: [],
  typeName: $.ZodString,
  coerce: e?.coerce ?? !1,
  ...ke(e)
});
function Vj(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, s = n > r ? n : r, i = Number.parseInt(e.toFixed(s).replace(".", "")), a = Number.parseInt(t.toFixed(s).replace(".", ""));
  return i % a / 10 ** s;
}
let Tv = class lp extends Pe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== X.number) {
      const i = this._getOrReturnCtx(t);
      return H(i, {
        code: M.invalid_type,
        expected: X.number,
        received: i.parsedType
      }), be;
    }
    let r;
    const s = new ln();
    for (const i of this._def.checks)
      i.kind === "int" ? Me.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? Vj(t.data, i.value) !== 0 && (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.not_finite,
        message: i.message
      }), s.dirty()) : Me.assertNever(i);
    return { status: s.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Q.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Q.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Q.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Q.toString(n));
  }
  setLimit(t, n, r, s) {
    return new lp({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Q.toString(s)
        }
      ]
    });
  }
  _addCheck(t) {
    return new lp({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Q.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Q.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Q.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Q.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Q.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Q.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Q.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Q.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Q.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Me.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
Tv.create = (e) => new Tv({
  checks: [],
  typeName: $.ZodNumber,
  coerce: e?.coerce || !1,
  ...ke(e)
});
class wo extends Pe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data);
      } catch {
        return this._getInvalidInput(t);
      }
    if (this._getType(t) !== X.bigint)
      return this._getInvalidInput(t);
    let r;
    const s = new ln();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), H(r, {
        code: M.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : Me.assertNever(i);
    return { status: s.value, value: t.data };
  }
  _getInvalidInput(t) {
    const n = this._getOrReturnCtx(t);
    return H(n, {
      code: M.invalid_type,
      expected: X.bigint,
      received: n.parsedType
    }), be;
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Q.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Q.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Q.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Q.toString(n));
  }
  setLimit(t, n, r, s) {
    return new wo({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Q.toString(s)
        }
      ]
    });
  }
  _addCheck(t) {
    return new wo({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Q.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Q.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Q.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Q.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Q.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
wo.create = (e) => new wo({
  checks: [],
  typeName: $.ZodBigInt,
  coerce: e?.coerce ?? !1,
  ...ke(e)
});
let xv = class extends Pe {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== X.boolean) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: M.invalid_type,
        expected: X.boolean,
        received: r.parsedType
      }), be;
    }
    return vn(t.data);
  }
};
xv.create = (e) => new xv({
  typeName: $.ZodBoolean,
  coerce: e?.coerce || !1,
  ...ke(e)
});
class Zc extends Pe {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== X.date) {
      const i = this._getOrReturnCtx(t);
      return H(i, {
        code: M.invalid_type,
        expected: X.date,
        received: i.parsedType
      }), be;
    }
    if (Number.isNaN(t.data.getTime())) {
      const i = this._getOrReturnCtx(t);
      return H(i, {
        code: M.invalid_date
      }), be;
    }
    const r = new ln();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? t.data.getTime() < i.value && (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (s = this._getOrReturnCtx(t, s), H(s, {
        code: M.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : Me.assertNever(i);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Zc({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Q.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Q.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
Zc.create = (e) => new Zc({
  checks: [],
  coerce: e?.coerce || !1,
  typeName: $.ZodDate,
  ...ke(e)
});
class Ev extends Pe {
  _parse(t) {
    if (this._getType(t) !== X.symbol) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: M.invalid_type,
        expected: X.symbol,
        received: r.parsedType
      }), be;
    }
    return vn(t.data);
  }
}
Ev.create = (e) => new Ev({
  typeName: $.ZodSymbol,
  ...ke(e)
});
class kv extends Pe {
  _parse(t) {
    if (this._getType(t) !== X.undefined) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: M.invalid_type,
        expected: X.undefined,
        received: r.parsedType
      }), be;
    }
    return vn(t.data);
  }
}
kv.create = (e) => new kv({
  typeName: $.ZodUndefined,
  ...ke(e)
});
class Ov extends Pe {
  _parse(t) {
    if (this._getType(t) !== X.null) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: M.invalid_type,
        expected: X.null,
        received: r.parsedType
      }), be;
    }
    return vn(t.data);
  }
}
Ov.create = (e) => new Ov({
  typeName: $.ZodNull,
  ...ke(e)
});
class dp extends Pe {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return vn(t.data);
  }
}
dp.create = (e) => new dp({
  typeName: $.ZodAny,
  ...ke(e)
});
let Iv = class extends Pe {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return vn(t.data);
  }
};
Iv.create = (e) => new Iv({
  typeName: $.ZodUnknown,
  ...ke(e)
});
let qr = class extends Pe {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return H(n, {
      code: M.invalid_type,
      expected: X.never,
      received: n.parsedType
    }), be;
  }
};
qr.create = (e) => new qr({
  typeName: $.ZodNever,
  ...ke(e)
});
class Av extends Pe {
  _parse(t) {
    if (this._getType(t) !== X.undefined) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: M.invalid_type,
        expected: X.void,
        received: r.parsedType
      }), be;
    }
    return vn(t.data);
  }
}
Av.create = (e) => new Av({
  typeName: $.ZodVoid,
  ...ke(e)
});
let ci = class hc extends Pe {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), s = this._def;
    if (n.parsedType !== X.array)
      return H(n, {
        code: M.invalid_type,
        expected: X.array,
        received: n.parsedType
      }), be;
    if (s.exactLength !== null) {
      const a = n.data.length > s.exactLength.value, o = n.data.length < s.exactLength.value;
      (a || o) && (H(n, {
        code: a ? M.too_big : M.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (H(n, {
      code: M.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (H(n, {
      code: M.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((a, o) => s.type._parseAsync(new zr(n, a, n.path, o)))).then((a) => ln.mergeArray(r, a));
    const i = [...n.data].map((a, o) => s.type._parseSync(new zr(n, a, n.path, o)));
    return ln.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new hc({
      ...this._def,
      minLength: { value: t, message: Q.toString(n) }
    });
  }
  max(t, n) {
    return new hc({
      ...this._def,
      maxLength: { value: t, message: Q.toString(n) }
    });
  }
  length(t, n) {
    return new hc({
      ...this._def,
      exactLength: { value: t, message: Q.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
ci.create = (e, t) => new ci({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: $.ZodArray,
  ...ke(t)
});
function Hs(e) {
  if (e instanceof mr) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Mr.create(Hs(r));
    }
    return new mr({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof ci ? new ci({
    ...e._def,
    type: Hs(e.element)
  }) : e instanceof Mr ? Mr.create(Hs(e.unwrap())) : e instanceof di ? di.create(Hs(e.unwrap())) : e instanceof vo ? vo.create(e.items.map((t) => Hs(t))) : e;
}
let mr = class On extends Pe {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = Me.objectKeys(t);
    return this._cached = { shape: t, keys: n }, this._cached;
  }
  _parse(t) {
    if (this._getType(t) !== X.object) {
      const c = this._getOrReturnCtx(t);
      return H(c, {
        code: M.invalid_type,
        expected: X.object,
        received: c.parsedType
      }), be;
    }
    const { status: r, ctx: s } = this._processInputParams(t), { shape: i, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof qr && this._def.unknownKeys === "strip"))
      for (const c in s.data)
        a.includes(c) || o.push(c);
    const u = [];
    for (const c of a) {
      const l = i[c], d = s.data[c];
      u.push({
        key: { status: "valid", value: c },
        value: l._parse(new zr(s, d, s.path, c)),
        alwaysSet: c in s.data
      });
    }
    if (this._def.catchall instanceof qr) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const l of o)
          u.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (c === "strict")
        o.length > 0 && (H(s, {
          code: M.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const l of o) {
        const d = s.data[l];
        u.push({
          key: { status: "valid", value: l },
          value: c._parse(
            new zr(s, d, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const l of u) {
        const d = await l.key, f = await l.value;
        c.push({
          key: d,
          value: f,
          alwaysSet: l.alwaysSet
        });
      }
      return c;
    }).then((c) => ln.mergeObjectSync(r, c)) : ln.mergeObjectSync(r, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Q.errToObj, new On({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          const s = this._def.errorMap?.(n, r).message ?? r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: Q.errToObj(t).message ?? s
          } : {
            message: s
          };
        }
      } : {}
    });
  }
  strip() {
    return new On({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new On({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new On({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new On({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: $.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new On({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    for (const r of Me.objectKeys(t))
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    return new On({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    for (const r of Me.objectKeys(this.shape))
      t[r] || (n[r] = this.shape[r]);
    return new On({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Hs(this);
  }
  partial(t) {
    const n = {};
    for (const r of Me.objectKeys(this.shape)) {
      const s = this.shape[r];
      t && !t[r] ? n[r] = s : n[r] = s.optional();
    }
    return new On({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    for (const r of Me.objectKeys(this.shape))
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof Mr; )
          i = i._def.innerType;
        n[r] = i;
      }
    return new On({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return LE(Me.objectKeys(this.shape));
  }
};
mr.create = (e, t) => new mr({
  shape: () => e,
  unknownKeys: "strip",
  catchall: qr.create(),
  typeName: $.ZodObject,
  ...ke(t)
});
mr.strictCreate = (e, t) => new mr({
  shape: () => e,
  unknownKeys: "strict",
  catchall: qr.create(),
  typeName: $.ZodObject,
  ...ke(t)
});
mr.lazycreate = (e, t) => new mr({
  shape: e,
  unknownKeys: "strip",
  catchall: qr.create(),
  typeName: $.ZodObject,
  ...ke(t)
});
let Vc = class extends Pe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function s(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((o) => new pr(o.ctx.common.issues));
      return H(n, {
        code: M.invalid_union,
        unionErrors: a
      }), be;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const a = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const u of r) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, l = u._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: c }), c.common.issues.length && a.push(c.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map((u) => new pr(u));
      return H(n, {
        code: M.invalid_union,
        unionErrors: o
      }), be;
    }
  }
  get options() {
    return this._def.options;
  }
};
Vc.create = (e, t) => new Vc({
  options: e,
  typeName: $.ZodUnion,
  ...ke(t)
});
function fp(e, t) {
  const n = $r(e), r = $r(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === X.object && r === X.object) {
    const s = Me.objectKeys(t), i = Me.objectKeys(e).filter((o) => s.indexOf(o) !== -1), a = { ...e, ...t };
    for (const o of i) {
      const u = fp(e[o], t[o]);
      if (!u.valid)
        return { valid: !1 };
      a[o] = u.data;
    }
    return { valid: !0, data: a };
  } else if (n === X.array && r === X.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < e.length; i++) {
      const a = e[i], o = t[i], u = fp(a, o);
      if (!u.valid)
        return { valid: !1 };
      s.push(u.data);
    }
    return { valid: !0, data: s };
  } else return n === X.date && r === X.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
let Hc = class extends Pe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), s = (i, a) => {
      if (vv(i) || vv(a))
        return be;
      const o = fp(i.value, a.value);
      return o.valid ? ((bv(i) || bv(a)) && n.dirty(), { status: n.value, value: o.data }) : (H(r, {
        code: M.invalid_intersection_types
      }), be);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
Hc.create = (e, t, n) => new Hc({
  left: e,
  right: t,
  typeName: $.ZodIntersection,
  ...ke(n)
});
let vo = class jE extends Pe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== X.array)
      return H(r, {
        code: M.invalid_type,
        expected: X.array,
        received: r.parsedType
      }), be;
    if (r.data.length < this._def.items.length)
      return H(r, {
        code: M.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), be;
    !this._def.rest && r.data.length > this._def.items.length && (H(r, {
      code: M.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...r.data].map((a, o) => {
      const u = this._def.items[o] || this._def.rest;
      return u ? u._parse(new zr(r, a, r.path, o)) : null;
    }).filter((a) => !!a);
    return r.common.async ? Promise.all(i).then((a) => ln.mergeArray(n, a)) : ln.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new jE({
      ...this._def,
      rest: t
    });
  }
};
vo.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new vo({
    items: e,
    typeName: $.ZodTuple,
    rest: null,
    ...ke(t)
  });
};
class Cv extends Pe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== X.map)
      return H(r, {
        code: M.invalid_type,
        expected: X.map,
        received: r.parsedType
      }), be;
    const s = this._def.keyType, i = this._def.valueType, a = [...r.data.entries()].map(([o, u], c) => ({
      key: s._parse(new zr(r, o, r.path, [c, "key"])),
      value: i._parse(new zr(r, u, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of a) {
          const c = await u.key, l = await u.value;
          if (c.status === "aborted" || l.status === "aborted")
            return be;
          (c.status === "dirty" || l.status === "dirty") && n.dirty(), o.set(c.value, l.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const u of a) {
        const c = u.key, l = u.value;
        if (c.status === "aborted" || l.status === "aborted")
          return be;
        (c.status === "dirty" || l.status === "dirty") && n.dirty(), o.set(c.value, l.value);
      }
      return { status: n.value, value: o };
    }
  }
}
Cv.create = (e, t, n) => new Cv({
  valueType: t,
  keyType: e,
  typeName: $.ZodMap,
  ...ke(n)
});
class bo extends Pe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== X.set)
      return H(r, {
        code: M.invalid_type,
        expected: X.set,
        received: r.parsedType
      }), be;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (H(r, {
      code: M.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (H(r, {
      code: M.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function a(u) {
      const c = /* @__PURE__ */ new Set();
      for (const l of u) {
        if (l.status === "aborted")
          return be;
        l.status === "dirty" && n.dirty(), c.add(l.value);
      }
      return { status: n.value, value: c };
    }
    const o = [...r.data.values()].map((u, c) => i._parse(new zr(r, u, r.path, c)));
    return r.common.async ? Promise.all(o).then((u) => a(u)) : a(o);
  }
  min(t, n) {
    return new bo({
      ...this._def,
      minSize: { value: t, message: Q.toString(n) }
    });
  }
  max(t, n) {
    return new bo({
      ...this._def,
      maxSize: { value: t, message: Q.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
bo.create = (e, t) => new bo({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: $.ZodSet,
  ...ke(t)
});
class $v extends Pe {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
$v.create = (e, t) => new $v({
  getter: e,
  typeName: $.ZodLazy,
  ...ke(t)
});
let Rv = class extends Pe {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return H(n, {
        received: n.data,
        code: M.invalid_literal,
        expected: this._def.value
      }), be;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Rv.create = (e, t) => new Rv({
  value: e,
  typeName: $.ZodLiteral,
  ...ke(t)
});
function LE(e, t) {
  return new Zm({
    values: e,
    typeName: $.ZodEnum,
    ...ke(t)
  });
}
let Zm = class hp extends Pe {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return H(n, {
        expected: Me.joinValues(r),
        received: n.parsedType,
        code: M.invalid_type
      }), be;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(t.data)) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return H(n, {
        received: n.data,
        code: M.invalid_enum_value,
        options: r
      }), be;
    }
    return vn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return hp.create(t, {
      ...this._def,
      ...n
    });
  }
  exclude(t, n = this._def) {
    return hp.create(this.options.filter((r) => !t.includes(r)), {
      ...this._def,
      ...n
    });
  }
};
Zm.create = LE;
class Pv extends Pe {
  _parse(t) {
    const n = Me.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== X.string && r.parsedType !== X.number) {
      const s = Me.objectValues(n);
      return H(r, {
        expected: Me.joinValues(s),
        received: r.parsedType,
        code: M.invalid_type
      }), be;
    }
    if (this._cache || (this._cache = new Set(Me.getValidEnumValues(this._def.values))), !this._cache.has(t.data)) {
      const s = Me.objectValues(n);
      return H(r, {
        received: r.data,
        code: M.invalid_enum_value,
        options: s
      }), be;
    }
    return vn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Pv.create = (e, t) => new Pv({
  values: e,
  typeName: $.ZodNativeEnum,
  ...ke(t)
});
class Gc extends Pe {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== X.promise && n.common.async === !1)
      return H(n, {
        code: M.invalid_type,
        expected: X.promise,
        received: n.parsedType
      }), be;
    const r = n.parsedType === X.promise ? n.data : Promise.resolve(n.data);
    return vn(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Gc.create = (e, t) => new Gc({
  type: e,
  typeName: $.ZodPromise,
  ...ke(t)
});
class li extends Pe {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === $.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), s = this._def.effect || null, i = {
      addIssue: (a) => {
        H(r, a), a.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const a = s.transform(r.data, i);
      if (r.common.async)
        return Promise.resolve(a).then(async (o) => {
          if (n.value === "aborted")
            return be;
          const u = await this._def.schema._parseAsync({
            data: o,
            path: r.path,
            parent: r
          });
          return u.status === "aborted" ? be : u.status === "dirty" || n.value === "dirty" ? Va(u.value) : u;
        });
      {
        if (n.value === "aborted")
          return be;
        const o = this._def.schema._parseSync({
          data: a,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? be : o.status === "dirty" || n.value === "dirty" ? Va(o.value) : o;
      }
    }
    if (s.type === "refinement") {
      const a = (o) => {
        const u = s.refinement(o, i);
        if (r.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? be : (o.status === "dirty" && n.dirty(), a(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? be : (o.status === "dirty" && n.dirty(), a(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!ui(a))
          return be;
        const o = s.transform(a.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => ui(a) ? Promise.resolve(s.transform(a.value, i)).then((o) => ({
          status: n.value,
          value: o
        })) : be);
    Me.assertNever(s);
  }
}
li.create = (e, t, n) => new li({
  schema: e,
  typeName: $.ZodEffects,
  effect: t,
  ...ke(n)
});
li.createWithPreprocess = (e, t, n) => new li({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: $.ZodEffects,
  ...ke(n)
});
let Mr = class extends Pe {
  _parse(t) {
    return this._getType(t) === X.undefined ? vn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Mr.create = (e, t) => new Mr({
  innerType: e,
  typeName: $.ZodOptional,
  ...ke(t)
});
let di = class extends Pe {
  _parse(t) {
    return this._getType(t) === X.null ? vn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
di.create = (e, t) => new di({
  innerType: e,
  typeName: $.ZodNullable,
  ...ke(t)
});
let pp = class extends Pe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === X.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
pp.create = (e, t) => new pp({
  innerType: e,
  typeName: $.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...ke(t)
});
let mp = class extends Pe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Bc(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new pr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new pr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
mp.create = (e, t) => new mp({
  innerType: e,
  typeName: $.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...ke(t)
});
class Nv extends Pe {
  _parse(t) {
    if (this._getType(t) !== X.nan) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: M.invalid_type,
        expected: X.nan,
        received: r.parsedType
      }), be;
    }
    return { status: "valid", value: t.data };
  }
}
Nv.create = (e) => new Nv({
  typeName: $.ZodNaN,
  ...ke(e)
});
class Hj extends Pe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Vm extends Pe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? be : i.status === "dirty" ? (n.dirty(), Va(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? be : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Vm({
      in: t,
      out: n,
      typeName: $.ZodPipeline
    });
  }
}
let gp = class extends Pe {
  _parse(t) {
    const n = this._def.innerType._parse(t), r = (s) => (ui(s) && (s.value = Object.freeze(s.value)), s);
    return Bc(n) ? n.then((s) => r(s)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
};
gp.create = (e, t) => new gp({
  innerType: e,
  typeName: $.ZodReadonly,
  ...ke(t)
});
var $;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})($ || ($ = {}));
const Bl = cp.create, Mv = dp.create;
qr.create;
ci.create;
const Zl = mr.create;
Vc.create;
Hc.create;
vo.create;
Zm.create;
Gc.create;
Mr.create;
di.create;
function Gj(e, t) {
  const n = { type: "array" };
  return e.type?._def && e.type?._def?.typeName !== $.ZodAny && (n.items = De(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && Ue(n, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && Ue(n, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (Ue(n, "minItems", e.exactLength.value, e.exactLength.message, t), Ue(n, "maxItems", e.exactLength.value, e.exactLength.message, t)), n;
}
function Wj(e, t) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks) return n;
  for (const r of e.checks) switch (r.kind) {
    case "min":
      t.target === "jsonSchema7" ? r.inclusive ? Ue(n, "minimum", r.value, r.message, t) : Ue(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Ue(n, "minimum", r.value, r.message, t));
      break;
    case "max":
      t.target === "jsonSchema7" ? r.inclusive ? Ue(n, "maximum", r.value, r.message, t) : Ue(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Ue(n, "maximum", r.value, r.message, t));
      break;
    case "multipleOf":
      Ue(n, "multipleOf", r.value, r.message, t);
      break;
  }
  return n;
}
function Jj() {
  return { type: "boolean" };
}
function DE(e, t) {
  return De(e.type._def, t);
}
const Kj = (e, t) => De(e.innerType._def, t);
function UE(e, t, n) {
  const r = n ?? t.dateStrategy;
  if (Array.isArray(r)) return { anyOf: r.map((s) => UE(e, t, s)) };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return Yj(e, t);
  }
}
const Yj = (e, t) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (t.target === "openApi3") return n;
  for (const r of e.checks) switch (r.kind) {
    case "min":
      Ue(n, "minimum", r.value, r.message, t);
      break;
    case "max":
      Ue(n, "maximum", r.value, r.message, t);
      break;
  }
  return n;
};
function Xj(e, t) {
  return {
    ...De(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function Qj(e, t) {
  return t.effectStrategy === "input" ? De(e.schema._def, t) : cn(t);
}
function eL(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
const tL = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function nL(e, t) {
  const n = [De(e.left._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "allOf",
      "0"
    ]
  }), De(e.right._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "allOf",
      "1"
    ]
  })].filter((i) => !!i);
  let r = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return n.forEach((i) => {
    if (tL(i))
      s.push(...i.allOf), i.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let a = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: o, ...u } = i;
        a = u;
      } else r = void 0;
      s.push(a);
    }
  }), s.length ? {
    allOf: s,
    ...r
  } : void 0;
}
function rL(e, t) {
  const n = typeof e.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? { type: Array.isArray(e.value) ? "array" : "object" } : t.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [e.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: e.value
  };
}
let ih;
const Sn = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => (ih === void 0 && (ih = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), ih),
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function FE(e, t) {
  const n = { type: "string" };
  if (e.checks) for (const r of e.checks) switch (r.kind) {
    case "min":
      Ue(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, t);
      break;
    case "max":
      Ue(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, t);
      break;
    case "email":
      switch (t.emailStrategy) {
        case "format:email":
          Tn(n, "email", r.message, t);
          break;
        case "format:idn-email":
          Tn(n, "idn-email", r.message, t);
          break;
        case "pattern:zod":
          Rt(n, Sn.email, r.message, t);
          break;
      }
      break;
    case "url":
      Tn(n, "uri", r.message, t);
      break;
    case "uuid":
      Tn(n, "uuid", r.message, t);
      break;
    case "regex":
      Rt(n, r.regex, r.message, t);
      break;
    case "cuid":
      Rt(n, Sn.cuid, r.message, t);
      break;
    case "cuid2":
      Rt(n, Sn.cuid2, r.message, t);
      break;
    case "startsWith":
      Rt(n, RegExp(`^${ah(r.value, t)}`), r.message, t);
      break;
    case "endsWith":
      Rt(n, RegExp(`${ah(r.value, t)}$`), r.message, t);
      break;
    case "datetime":
      Tn(n, "date-time", r.message, t);
      break;
    case "date":
      Tn(n, "date", r.message, t);
      break;
    case "time":
      Tn(n, "time", r.message, t);
      break;
    case "duration":
      Tn(n, "duration", r.message, t);
      break;
    case "length":
      Ue(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, r.message, t), Ue(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value, r.message, t);
      break;
    case "includes":
      Rt(n, RegExp(ah(r.value, t)), r.message, t);
      break;
    case "ip":
      r.version !== "v6" && Tn(n, "ipv4", r.message, t), r.version !== "v4" && Tn(n, "ipv6", r.message, t);
      break;
    case "base64url":
      Rt(n, Sn.base64url, r.message, t);
      break;
    case "jwt":
      Rt(n, Sn.jwt, r.message, t);
      break;
    case "cidr":
      r.version !== "v6" && Rt(n, Sn.ipv4Cidr, r.message, t), r.version !== "v4" && Rt(n, Sn.ipv6Cidr, r.message, t);
      break;
    case "emoji":
      Rt(n, Sn.emoji(), r.message, t);
      break;
    case "ulid":
      Rt(n, Sn.ulid, r.message, t);
      break;
    case "base64":
      switch (t.base64Strategy) {
        case "format:binary":
          Tn(n, "binary", r.message, t);
          break;
        case "contentEncoding:base64":
          Ue(n, "contentEncoding", "base64", r.message, t);
          break;
        case "pattern:zod":
          Rt(n, Sn.base64, r.message, t);
          break;
      }
      break;
    case "nanoid":
      Rt(n, Sn.nanoid, r.message, t);
      break;
  }
  return n;
}
function ah(e, t) {
  return t.patternStrategy === "escape" ? iL(e) : e;
}
const sL = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function iL(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    sL.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function Tn(e, t, n, r) {
  e.format || e.anyOf?.some((s) => s.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format,
    ...e.errorMessage && r.errorMessages && { errorMessage: { format: e.errorMessage.format } }
  }), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push({
    format: t,
    ...n && r.errorMessages && { errorMessage: { format: n } }
  })) : Ue(e, "format", t, n, r);
}
function Rt(e, t, n, r) {
  e.pattern || e.allOf?.some((s) => s.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern,
    ...e.errorMessage && r.errorMessages && { errorMessage: { pattern: e.errorMessage.pattern } }
  }), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push({
    pattern: jv(t, r),
    ...n && r.errorMessages && { errorMessage: { pattern: n } }
  })) : Ue(e, "pattern", jv(t, r), n, r);
}
function jv(e, t) {
  if (!t.applyRegexFlags || !e.flags) return e.source;
  const n = {
    i: e.flags.includes("i"),
    m: e.flags.includes("m"),
    s: e.flags.includes("s")
  }, r = n.i ? e.source.toLowerCase() : e.source;
  let s = "", i = !1, a = !1, o = !1;
  for (let u = 0; u < r.length; u++) {
    if (i) {
      s += r[u], i = !1;
      continue;
    }
    if (n.i) {
      if (a) {
        if (r[u].match(/[a-z]/)) {
          o ? (s += r[u], s += `${r[u - 2]}-${r[u]}`.toUpperCase(), o = !1) : r[u + 1] === "-" && r[u + 2]?.match(/[a-z]/) ? (s += r[u], o = !0) : s += `${r[u]}${r[u].toUpperCase()}`;
          continue;
        }
      } else if (r[u].match(/[a-z]/)) {
        s += `[${r[u]}${r[u].toUpperCase()}]`;
        continue;
      }
    }
    if (n.m) {
      if (r[u] === "^") {
        s += `(^|(?<=[\r
]))`;
        continue;
      } else if (r[u] === "$") {
        s += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (n.s && r[u] === ".") {
      s += a ? `${r[u]}\r
` : `[${r[u]}\r
]`;
      continue;
    }
    s += r[u], r[u] === "\\" ? i = !0 : a && r[u] === "]" ? a = !1 : !a && r[u] === "[" && (a = !0);
  }
  try {
    new RegExp(s);
  } catch {
    return console.warn(`Could not convert regex pattern at ${t.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), e.source;
  }
  return s;
}
function zE(e, t) {
  if (t.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."), t.target === "openApi3" && e.keyType?._def.typeName === $.ZodEnum) return {
    type: "object",
    required: e.keyType._def.values,
    properties: e.keyType._def.values.reduce((r, s) => ({
      ...r,
      [s]: De(e.valueType._def, {
        ...t,
        currentPath: [
          ...t.currentPath,
          "properties",
          s
        ]
      }) ?? cn(t)
    }), {}),
    additionalProperties: t.rejectedAdditionalProperties
  };
  const n = {
    type: "object",
    additionalProperties: De(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    }) ?? t.allowedAdditionalProperties
  };
  if (t.target === "openApi3") return n;
  if (e.keyType?._def.typeName === $.ZodString && e.keyType._def.checks?.length) {
    const { type: r, ...s } = FE(e.keyType._def, t);
    return {
      ...n,
      propertyNames: s
    };
  } else {
    if (e.keyType?._def.typeName === $.ZodEnum) return {
      ...n,
      propertyNames: { enum: e.keyType._def.values }
    };
    if (e.keyType?._def.typeName === $.ZodBranded && e.keyType._def.type._def.typeName === $.ZodString && e.keyType._def.type._def.checks?.length) {
      const { type: r, ...s } = DE(e.keyType._def, t);
      return {
        ...n,
        propertyNames: s
      };
    }
  }
  return n;
}
function aL(e, t) {
  if (t.mapStrategy === "record") return zE(e, t);
  const n = De(e.keyType._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || cn(t), r = De(e.valueType._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || cn(t);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function oL(e) {
  const t = e.values, r = Object.keys(e.values).filter((i) => typeof t[t[i]] != "number").map((i) => t[i]), s = Array.from(new Set(r.map((i) => typeof i)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function uL(e) {
  return e.target === "openAi" ? void 0 : { not: cn({
    ...e,
    currentPath: [...e.currentPath, "not"]
  }) };
}
function cL(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : { type: "null" };
}
const Wc = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function lL(e, t) {
  if (t.target === "openApi3") return Lv(e, t);
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every((r) => r._def.typeName in Wc && (!r._def.checks || !r._def.checks.length))) {
    const r = n.reduce((s, i) => {
      const a = Wc[i._def.typeName];
      return a && !s.includes(a) ? [...s, a] : s;
    }, []);
    return { type: r.length > 1 ? r : r[0] };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce((s, i) => {
      const a = typeof i._def.value;
      switch (a) {
        case "string":
        case "number":
        case "boolean":
          return [...s, a];
        case "bigint":
          return [...s, "integer"];
        case "object":
          return i._def.value === null ? [...s, "null"] : s;
        default:
          return s;
      }
    }, []);
    if (r.length === n.length) {
      const s = r.filter((i, a, o) => o.indexOf(i) === a);
      return {
        type: s.length > 1 ? s : s[0],
        enum: n.reduce((i, a) => i.includes(a._def.value) ? i : [...i, a._def.value], [])
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum")) return {
    type: "string",
    enum: n.reduce((r, s) => [...r, ...s._def.values.filter((i) => !r.includes(i))], [])
  };
  return Lv(e, t);
}
const Lv = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map((r, s) => De(r._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "anyOf",
      `${s}`
    ]
  })).filter((r) => !!r && (!t.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function dL(e, t) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" ? {
      type: Wc[e.innerType._def.typeName],
      nullable: !0
    } : { type: [Wc[e.innerType._def.typeName], "null"] };
  if (t.target === "openApi3") {
    const r = De(e.innerType._def, {
      ...t,
      currentPath: [...t.currentPath]
    });
    return r && "$ref" in r ? {
      allOf: [r],
      nullable: !0
    } : r && {
      ...r,
      nullable: !0
    };
  }
  const n = De(e.innerType._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "anyOf",
      "0"
    ]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function fL(e, t) {
  const n = { type: "number" };
  if (!e.checks) return n;
  for (const r of e.checks) switch (r.kind) {
    case "int":
      n.type = "integer", PE(n, "type", r.message, t);
      break;
    case "min":
      t.target === "jsonSchema7" ? r.inclusive ? Ue(n, "minimum", r.value, r.message, t) : Ue(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Ue(n, "minimum", r.value, r.message, t));
      break;
    case "max":
      t.target === "jsonSchema7" ? r.inclusive ? Ue(n, "maximum", r.value, r.message, t) : Ue(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Ue(n, "maximum", r.value, r.message, t));
      break;
    case "multipleOf":
      Ue(n, "multipleOf", r.value, r.message, t);
      break;
  }
  return n;
}
function hL(e, t) {
  const n = t.target === "openAi", r = {
    type: "object",
    properties: {}
  }, s = [], i = e.shape();
  for (const o in i) {
    let u = i[o];
    if (u === void 0 || u._def === void 0) continue;
    let c = mL(u);
    c && n && (u._def.typeName === "ZodOptional" && (u = u._def.innerType), u.isNullable() || (u = u.nullable()), c = !1);
    const l = De(u._def, {
      ...t,
      currentPath: [
        ...t.currentPath,
        "properties",
        o
      ],
      propertyPath: [
        ...t.currentPath,
        "properties",
        o
      ]
    });
    l !== void 0 && (r.properties[o] = l, c || s.push(o));
  }
  s.length && (r.required = s);
  const a = pL(e, t);
  return a !== void 0 && (r.additionalProperties = a), r;
}
function pL(e, t) {
  if (e.catchall._def.typeName !== "ZodNever") return De(e.catchall._def, {
    ...t,
    currentPath: [...t.currentPath, "additionalProperties"]
  });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function mL(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
const gL = (e, t) => {
  if (t.currentPath.toString() === t.propertyPath?.toString()) return De(e.innerType._def, t);
  const n = De(e.innerType._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "anyOf",
      "1"
    ]
  });
  return n ? { anyOf: [{ not: cn(t) }, n] } : cn(t);
}, _L = (e, t) => {
  if (t.pipeStrategy === "input") return De(e.in._def, t);
  if (t.pipeStrategy === "output") return De(e.out._def, t);
  const n = De(e.in._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "allOf",
      "0"
    ]
  }), r = De(e.out._def, {
    ...t,
    currentPath: [
      ...t.currentPath,
      "allOf",
      n ? "1" : "0"
    ]
  });
  return { allOf: [n, r].filter((s) => s !== void 0) };
};
function yL(e, t) {
  return De(e.type._def, t);
}
function wL(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: De(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && Ue(r, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && Ue(r, "maxItems", e.maxSize.value, e.maxSize.message, t), r;
}
function vL(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map((n, r) => De(n._def, {
      ...t,
      currentPath: [
        ...t.currentPath,
        "items",
        `${r}`
      ]
    })).reduce((n, r) => r === void 0 ? n : [...n, r], []),
    additionalItems: De(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map((n, r) => De(n._def, {
      ...t,
      currentPath: [
        ...t.currentPath,
        "items",
        `${r}`
      ]
    })).reduce((n, r) => r === void 0 ? n : [...n, r], [])
  };
}
function bL(e) {
  return { not: cn(e) };
}
function SL(e) {
  return cn(e);
}
const TL = (e, t) => De(e.innerType._def, t), xL = (e, t, n) => {
  switch (t) {
    case $.ZodString:
      return FE(e, n);
    case $.ZodNumber:
      return fL(e, n);
    case $.ZodObject:
      return hL(e, n);
    case $.ZodBigInt:
      return Wj(e, n);
    case $.ZodBoolean:
      return Jj();
    case $.ZodDate:
      return UE(e, n);
    case $.ZodUndefined:
      return bL(n);
    case $.ZodNull:
      return cL(n);
    case $.ZodArray:
      return Gj(e, n);
    case $.ZodUnion:
    case $.ZodDiscriminatedUnion:
      return lL(e, n);
    case $.ZodIntersection:
      return nL(e, n);
    case $.ZodTuple:
      return vL(e, n);
    case $.ZodRecord:
      return zE(e, n);
    case $.ZodLiteral:
      return rL(e, n);
    case $.ZodEnum:
      return eL(e);
    case $.ZodNativeEnum:
      return oL(e);
    case $.ZodNullable:
      return dL(e, n);
    case $.ZodOptional:
      return gL(e, n);
    case $.ZodMap:
      return aL(e, n);
    case $.ZodSet:
      return wL(e, n);
    case $.ZodLazy:
      return () => e.getter()._def;
    case $.ZodPromise:
      return yL(e, n);
    case $.ZodNaN:
    case $.ZodNever:
      return uL(n);
    case $.ZodEffects:
      return Qj(e, n);
    case $.ZodAny:
      return cn(n);
    case $.ZodUnknown:
      return SL(n);
    case $.ZodDefault:
      return Xj(e, n);
    case $.ZodBranded:
      return DE(e, n);
    case $.ZodReadonly:
      return TL(e, n);
    case $.ZodCatch:
      return Kj(e, n);
    case $.ZodPipeline:
      return _L(e, n);
    case $.ZodFunction:
    case $.ZodVoid:
    case $.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
};
function De(e, t, n = !1) {
  const r = t.seen.get(e);
  if (t.override) {
    const o = t.override?.(e, t, r, n);
    if (o !== _j) return o;
  }
  if (r && !n) {
    const o = EL(r, t);
    if (o !== void 0) return o;
  }
  const s = {
    def: e,
    path: t.currentPath,
    jsonSchema: void 0
  };
  t.seen.set(e, s);
  const i = xL(e, e.typeName, t), a = typeof i == "function" ? De(i(), t) : i;
  if (a && kL(e, t, a), t.postProcess) {
    const o = t.postProcess(a, e, t);
    return s.jsonSchema = a, o;
  }
  return s.jsonSchema = a, a;
}
const EL = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: RE(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, r) => t.currentPath[r] === n) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), cn(t)) : t.$refStrategy === "seen" ? cn(t) : void 0;
  }
}, kL = (e, t, n) => (e.description && (n.description = e.description, t.markdownDescription && (n.markdownDescription = e.description)), n), OL = (e, t) => {
  const n = vj(t);
  let r;
  const s = De(e._def, n, !1) ?? cn(n);
  n.flags.hasReferencedOpenAiAnyType && (r || (r = {}), r[n.openAiAnyTypeName] || (r[n.openAiAnyTypeName] = {
    type: [
      "string",
      "number",
      "integer",
      "boolean",
      "array",
      "null"
    ],
    items: { $ref: n.$refStrategy === "relative" ? "1" : [
      ...n.basePath,
      n.definitionPath,
      n.openAiAnyTypeName
    ].join("/") }
  }));
  const i = r ? {
    ...s,
    [n.definitionPath]: r
  } : s;
  return n.target === "jsonSchema7" ? i.$schema = "http://json-schema.org/draft-07/schema#" : (n.target === "jsonSchema2019-09" || n.target === "openAi") && (i.$schema = "https://json-schema.org/draft/2019-09/schema#"), n.target === "openAi" && ("anyOf" in i || "oneOf" in i || "allOf" in i || "type" in i && Array.isArray(i.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."), i;
};
function _s(e, t) {
  const n = typeof e;
  if (n !== typeof t)
    return !1;
  if (Array.isArray(e)) {
    if (!Array.isArray(t))
      return !1;
    const r = e.length;
    if (r !== t.length)
      return !1;
    for (let s = 0; s < r; s++)
      if (!_s(e[s], t[s]))
        return !1;
    return !0;
  }
  if (n === "object") {
    if (!e || !t)
      return e === t;
    const r = Object.keys(e), s = Object.keys(t);
    if (r.length !== s.length)
      return !1;
    for (const a of r)
      if (!_s(e[a], t[a]))
        return !1;
    return !0;
  }
  return e === t;
}
function In(e) {
  return encodeURI(IL(e));
}
function IL(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
const AL = {
  prefixItems: !0,
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
}, CL = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependentSchemas: !0
}, $L = {
  id: !0,
  $id: !0,
  $ref: !0,
  $schema: !0,
  $anchor: !0,
  $vocabulary: !0,
  $comment: !0,
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  type: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
let RL = typeof self < "u" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function Pr(e, t = /* @__PURE__ */ Object.create(null), n = RL, r = "") {
  if (e && typeof e == "object" && !Array.isArray(e)) {
    const i = e.$id || e.id;
    if (i) {
      const a = new URL(i, n.href);
      a.hash.length > 1 ? t[a.href] = e : (a.hash = "", r === "" ? n = a : Pr(e, t, n));
    }
  } else if (e !== !0 && e !== !1)
    return t;
  const s = n.href + (r ? "#" + r : "");
  if (t[s] !== void 0)
    throw new Error(`Duplicate schema URI "${s}".`);
  if (t[s] = e, e === !0 || e === !1)
    return t;
  if (e.__absolute_uri__ === void 0 && Object.defineProperty(e, "__absolute_uri__", {
    enumerable: !1,
    value: s
  }), e.$ref && e.__absolute_ref__ === void 0) {
    const i = new URL(e.$ref, n.href);
    i.hash = i.hash, Object.defineProperty(e, "__absolute_ref__", {
      enumerable: !1,
      value: i.href
    });
  }
  if (e.$recursiveRef && e.__absolute_recursive_ref__ === void 0) {
    const i = new URL(e.$recursiveRef, n.href);
    i.hash = i.hash, Object.defineProperty(e, "__absolute_recursive_ref__", {
      enumerable: !1,
      value: i.href
    });
  }
  if (e.$anchor) {
    const i = new URL("#" + e.$anchor, n.href);
    t[i.href] = e;
  }
  for (let i in e) {
    if ($L[i])
      continue;
    const a = `${r}/${In(i)}`, o = e[i];
    if (Array.isArray(o)) {
      if (AL[i]) {
        const u = o.length;
        for (let c = 0; c < u; c++)
          Pr(o[c], t, n, `${a}/${c}`);
      }
    } else if (CL[i])
      for (let u in o)
        Pr(o[u], t, n, `${a}/${In(u)}`);
    else
      Pr(o, t, n, a);
  }
  return t;
}
const PL = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, NL = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ML = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, jL = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, LL = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, DL = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, UL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, FL = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, zL = /^(?:\/(?:[^~/]|~0|~1)*)*$/, qL = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, BL = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, ZL = (e) => {
  if (e[0] === '"')
    return !1;
  const [t, n, ...r] = e.split("@");
  return !t || !n || r.length !== 0 || t.length > 64 || n.length > 253 || t[0] === "." || t.endsWith(".") || t.includes("..") || !/^[a-z0-9.-]+$/i.test(n) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(t) ? !1 : n.split(".").every((s) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(s));
}, VL = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, HL = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, GL = (e) => e.length > 1 && e.length < 80 && (/^P\d+([.,]\d+)?W$/.test(e) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(e) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(e));
function Zn(e) {
  return e.test.bind(e);
}
const Dv = {
  date: qE,
  time: BE.bind(void 0, !1),
  "date-time": KL,
  duration: GL,
  uri: QL,
  "uri-reference": Zn(LL),
  "uri-template": Zn(DL),
  url: Zn(UL),
  email: ZL,
  hostname: Zn(jL),
  ipv4: Zn(VL),
  ipv6: Zn(HL),
  regex: tD,
  uuid: Zn(FL),
  "json-pointer": Zn(zL),
  "json-pointer-uri-fragment": Zn(qL),
  "relative-json-pointer": Zn(BL)
};
function WL(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function qE(e) {
  const t = e.match(PL);
  if (!t)
    return !1;
  const n = +t[1], r = +t[2], s = +t[3];
  return r >= 1 && r <= 12 && s >= 1 && s <= (r == 2 && WL(n) ? 29 : NL[r]);
}
function BE(e, t) {
  const n = t.match(ML);
  if (!n)
    return !1;
  const r = +n[1], s = +n[2], i = +n[3], a = !!n[5];
  return (r <= 23 && s <= 59 && i <= 59 || r == 23 && s == 59 && i == 60) && (!e || a);
}
const JL = /t|\s/i;
function KL(e) {
  const t = e.split(JL);
  return t.length == 2 && qE(t[0]) && BE(!0, t[1]);
}
const YL = /\/|:/, XL = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function QL(e) {
  return YL.test(e) && XL.test(e);
}
const eD = /[^\\]\\Z/;
function tD(e) {
  if (eD.test(e))
    return !1;
  try {
    return new RegExp(e, "u"), !0;
  } catch {
    return !1;
  }
}
function nD(e) {
  let t = 0, n = e.length, r = 0, s;
  for (; r < n; )
    t++, s = e.charCodeAt(r++), s >= 55296 && s <= 56319 && r < n && (s = e.charCodeAt(r), (s & 64512) == 56320 && r++);
  return t;
}
function Ge(e, t, n = "2019-09", r = Pr(t), s = !0, i = null, a = "#", o = "#", u = /* @__PURE__ */ Object.create(null)) {
  if (t === !0)
    return { valid: !0, errors: [] };
  if (t === !1)
    return {
      valid: !1,
      errors: [
        {
          instanceLocation: a,
          keyword: "false",
          keywordLocation: a,
          error: "False boolean schema."
        }
      ]
    };
  const c = typeof e;
  let l;
  switch (c) {
    case "boolean":
    case "number":
    case "string":
      l = c;
      break;
    case "object":
      e === null ? l = "null" : Array.isArray(e) ? l = "array" : l = "object";
      break;
    default:
      throw new Error(`Instances of "${c}" type are not supported.`);
  }
  const { $ref: d, $recursiveRef: f, $recursiveAnchor: h, type: p, const: g, enum: m, required: _, not: y, anyOf: b, allOf: T, oneOf: x, if: k, then: O, else: S, format: j, properties: U, patternProperties: G, additionalProperties: He, unevaluatedProperties: yt, minProperties: D, maxProperties: N, propertyNames: L, dependentRequired: Z, dependentSchemas: ee, dependencies: q, prefixItems: ie, items: Te, additionalItems: me, unevaluatedItems: Re, contains: Be, minContains: z, maxContains: v, minItems: w, maxItems: C, uniqueItems: E, minimum: ae, maximum: ce, exclusiveMinimum: le, exclusiveMaximum: fe, multipleOf: Ae, minLength: Oe, maxLength: Xe, pattern: dn, __absolute_ref__: Cs, __absolute_recursive_ref__: Wo } = t, V = [];
  if (h === !0 && i === null && (i = t), f === "#") {
    const he = i === null ? r[Wo] : i, oe = `${o}/$recursiveRef`, ye = Ge(e, i === null ? t : i, n, r, s, he, a, oe, u);
    ye.valid || V.push({
      instanceLocation: a,
      keyword: "$recursiveRef",
      keywordLocation: oe,
      error: "A subschema had errors."
    }, ...ye.errors);
  }
  if (d !== void 0) {
    const oe = r[Cs || d];
    if (oe === void 0) {
      let B = `Unresolved $ref "${d}".`;
      throw Cs && Cs !== d && (B += `  Absolute URI "${Cs}".`), B += `
Known schemas:
- ${Object.keys(r).join(`
- `)}`, new Error(B);
    }
    const ye = `${o}/$ref`, K = Ge(e, oe, n, r, s, i, a, ye, u);
    if (K.valid || V.push({
      instanceLocation: a,
      keyword: "$ref",
      keywordLocation: ye,
      error: "A subschema had errors."
    }, ...K.errors), n === "4" || n === "7")
      return { valid: V.length === 0, errors: V };
  }
  if (Array.isArray(p)) {
    let he = p.length, oe = !1;
    for (let ye = 0; ye < he; ye++)
      if (l === p[ye] || p[ye] === "integer" && l === "number" && e % 1 === 0 && e === e) {
        oe = !0;
        break;
      }
    oe || V.push({
      instanceLocation: a,
      keyword: "type",
      keywordLocation: `${o}/type`,
      error: `Instance type "${l}" is invalid. Expected "${p.join('", "')}".`
    });
  } else p === "integer" ? (l !== "number" || e % 1 || e !== e) && V.push({
    instanceLocation: a,
    keyword: "type",
    keywordLocation: `${o}/type`,
    error: `Instance type "${l}" is invalid. Expected "${p}".`
  }) : p !== void 0 && l !== p && V.push({
    instanceLocation: a,
    keyword: "type",
    keywordLocation: `${o}/type`,
    error: `Instance type "${l}" is invalid. Expected "${p}".`
  });
  if (g !== void 0 && (l === "object" || l === "array" ? _s(e, g) || V.push({
    instanceLocation: a,
    keyword: "const",
    keywordLocation: `${o}/const`,
    error: `Instance does not match ${JSON.stringify(g)}.`
  }) : e !== g && V.push({
    instanceLocation: a,
    keyword: "const",
    keywordLocation: `${o}/const`,
    error: `Instance does not match ${JSON.stringify(g)}.`
  })), m !== void 0 && (l === "object" || l === "array" ? m.some((he) => _s(e, he)) || V.push({
    instanceLocation: a,
    keyword: "enum",
    keywordLocation: `${o}/enum`,
    error: `Instance does not match any of ${JSON.stringify(m)}.`
  }) : m.some((he) => e === he) || V.push({
    instanceLocation: a,
    keyword: "enum",
    keywordLocation: `${o}/enum`,
    error: `Instance does not match any of ${JSON.stringify(m)}.`
  })), y !== void 0) {
    const he = `${o}/not`;
    Ge(e, y, n, r, s, i, a, he).valid && V.push({
      instanceLocation: a,
      keyword: "not",
      keywordLocation: he,
      error: 'Instance matched "not" schema.'
    });
  }
  let Xr = [];
  if (b !== void 0) {
    const he = `${o}/anyOf`, oe = V.length;
    let ye = !1;
    for (let K = 0; K < b.length; K++) {
      const B = b[K], ge = Object.create(u), pe = Ge(e, B, n, r, s, h === !0 ? i : null, a, `${he}/${K}`, ge);
      V.push(...pe.errors), ye = ye || pe.valid, pe.valid && Xr.push(ge);
    }
    ye ? V.length = oe : V.splice(oe, 0, {
      instanceLocation: a,
      keyword: "anyOf",
      keywordLocation: he,
      error: "Instance does not match any subschemas."
    });
  }
  if (T !== void 0) {
    const he = `${o}/allOf`, oe = V.length;
    let ye = !0;
    for (let K = 0; K < T.length; K++) {
      const B = T[K], ge = Object.create(u), pe = Ge(e, B, n, r, s, h === !0 ? i : null, a, `${he}/${K}`, ge);
      V.push(...pe.errors), ye = ye && pe.valid, pe.valid && Xr.push(ge);
    }
    ye ? V.length = oe : V.splice(oe, 0, {
      instanceLocation: a,
      keyword: "allOf",
      keywordLocation: he,
      error: "Instance does not match every subschema."
    });
  }
  if (x !== void 0) {
    const he = `${o}/oneOf`, oe = V.length, ye = x.filter((K, B) => {
      const ge = Object.create(u), pe = Ge(e, K, n, r, s, h === !0 ? i : null, a, `${he}/${B}`, ge);
      return V.push(...pe.errors), pe.valid && Xr.push(ge), pe.valid;
    }).length;
    ye === 1 ? V.length = oe : V.splice(oe, 0, {
      instanceLocation: a,
      keyword: "oneOf",
      keywordLocation: he,
      error: `Instance does not match exactly one subschema (${ye} matches).`
    });
  }
  if ((l === "object" || l === "array") && Object.assign(u, ...Xr), k !== void 0) {
    const he = `${o}/if`;
    if (Ge(e, k, n, r, s, i, a, he, u).valid) {
      if (O !== void 0) {
        const ye = Ge(e, O, n, r, s, i, a, `${o}/then`, u);
        ye.valid || V.push({
          instanceLocation: a,
          keyword: "if",
          keywordLocation: he,
          error: 'Instance does not match "then" schema.'
        }, ...ye.errors);
      }
    } else if (S !== void 0) {
      const ye = Ge(e, S, n, r, s, i, a, `${o}/else`, u);
      ye.valid || V.push({
        instanceLocation: a,
        keyword: "if",
        keywordLocation: he,
        error: 'Instance does not match "else" schema.'
      }, ...ye.errors);
    }
  }
  if (l === "object") {
    if (_ !== void 0)
      for (const K of _)
        K in e || V.push({
          instanceLocation: a,
          keyword: "required",
          keywordLocation: `${o}/required`,
          error: `Instance does not have required property "${K}".`
        });
    const he = Object.keys(e);
    if (D !== void 0 && he.length < D && V.push({
      instanceLocation: a,
      keyword: "minProperties",
      keywordLocation: `${o}/minProperties`,
      error: `Instance does not have at least ${D} properties.`
    }), N !== void 0 && he.length > N && V.push({
      instanceLocation: a,
      keyword: "maxProperties",
      keywordLocation: `${o}/maxProperties`,
      error: `Instance does not have at least ${N} properties.`
    }), L !== void 0) {
      const K = `${o}/propertyNames`;
      for (const B in e) {
        const ge = `${a}/${In(B)}`, pe = Ge(B, L, n, r, s, i, ge, K);
        pe.valid || V.push({
          instanceLocation: a,
          keyword: "propertyNames",
          keywordLocation: K,
          error: `Property name "${B}" does not match schema.`
        }, ...pe.errors);
      }
    }
    if (Z !== void 0) {
      const K = `${o}/dependantRequired`;
      for (const B in Z)
        if (B in e) {
          const ge = Z[B];
          for (const pe of ge)
            pe in e || V.push({
              instanceLocation: a,
              keyword: "dependentRequired",
              keywordLocation: K,
              error: `Instance has "${B}" but does not have "${pe}".`
            });
        }
    }
    if (ee !== void 0)
      for (const K in ee) {
        const B = `${o}/dependentSchemas`;
        if (K in e) {
          const ge = Ge(e, ee[K], n, r, s, i, a, `${B}/${In(K)}`, u);
          ge.valid || V.push({
            instanceLocation: a,
            keyword: "dependentSchemas",
            keywordLocation: B,
            error: `Instance has "${K}" but does not match dependant schema.`
          }, ...ge.errors);
        }
      }
    if (q !== void 0) {
      const K = `${o}/dependencies`;
      for (const B in q)
        if (B in e) {
          const ge = q[B];
          if (Array.isArray(ge))
            for (const pe of ge)
              pe in e || V.push({
                instanceLocation: a,
                keyword: "dependencies",
                keywordLocation: K,
                error: `Instance has "${B}" but does not have "${pe}".`
              });
          else {
            const pe = Ge(e, ge, n, r, s, i, a, `${K}/${In(B)}`);
            pe.valid || V.push({
              instanceLocation: a,
              keyword: "dependencies",
              keywordLocation: K,
              error: `Instance has "${B}" but does not match dependant schema.`
            }, ...pe.errors);
          }
        }
    }
    const oe = /* @__PURE__ */ Object.create(null);
    let ye = !1;
    if (U !== void 0) {
      const K = `${o}/properties`;
      for (const B in U) {
        if (!(B in e))
          continue;
        const ge = `${a}/${In(B)}`, pe = Ge(e[B], U[B], n, r, s, i, ge, `${K}/${In(B)}`);
        if (pe.valid)
          u[B] = oe[B] = !0;
        else if (ye = s, V.push({
          instanceLocation: a,
          keyword: "properties",
          keywordLocation: K,
          error: `Property "${B}" does not match schema.`
        }, ...pe.errors), ye)
          break;
      }
    }
    if (!ye && G !== void 0) {
      const K = `${o}/patternProperties`;
      for (const B in G) {
        const ge = new RegExp(B, "u"), pe = G[B];
        for (const Dt in e) {
          if (!ge.test(Dt))
            continue;
          const vg = `${a}/${In(Dt)}`, bg = Ge(e[Dt], pe, n, r, s, i, vg, `${K}/${In(B)}`);
          bg.valid ? u[Dt] = oe[Dt] = !0 : (ye = s, V.push({
            instanceLocation: a,
            keyword: "patternProperties",
            keywordLocation: K,
            error: `Property "${Dt}" matches pattern "${B}" but does not match associated schema.`
          }, ...bg.errors));
        }
      }
    }
    if (!ye && He !== void 0) {
      const K = `${o}/additionalProperties`;
      for (const B in e) {
        if (oe[B])
          continue;
        const ge = `${a}/${In(B)}`, pe = Ge(e[B], He, n, r, s, i, ge, K);
        pe.valid ? u[B] = !0 : (ye = s, V.push({
          instanceLocation: a,
          keyword: "additionalProperties",
          keywordLocation: K,
          error: `Property "${B}" does not match additional properties schema.`
        }, ...pe.errors));
      }
    } else if (!ye && yt !== void 0) {
      const K = `${o}/unevaluatedProperties`;
      for (const B in e)
        if (!u[B]) {
          const ge = `${a}/${In(B)}`, pe = Ge(e[B], yt, n, r, s, i, ge, K);
          pe.valid ? u[B] = !0 : V.push({
            instanceLocation: a,
            keyword: "unevaluatedProperties",
            keywordLocation: K,
            error: `Property "${B}" does not match unevaluated properties schema.`
          }, ...pe.errors);
        }
    }
  } else if (l === "array") {
    C !== void 0 && e.length > C && V.push({
      instanceLocation: a,
      keyword: "maxItems",
      keywordLocation: `${o}/maxItems`,
      error: `Array has too many items (${e.length} > ${C}).`
    }), w !== void 0 && e.length < w && V.push({
      instanceLocation: a,
      keyword: "minItems",
      keywordLocation: `${o}/minItems`,
      error: `Array has too few items (${e.length} < ${w}).`
    });
    const he = e.length;
    let oe = 0, ye = !1;
    if (ie !== void 0) {
      const K = `${o}/prefixItems`, B = Math.min(ie.length, he);
      for (; oe < B; oe++) {
        const ge = Ge(e[oe], ie[oe], n, r, s, i, `${a}/${oe}`, `${K}/${oe}`);
        if (u[oe] = !0, !ge.valid && (ye = s, V.push({
          instanceLocation: a,
          keyword: "prefixItems",
          keywordLocation: K,
          error: "Items did not match schema."
        }, ...ge.errors), ye))
          break;
      }
    }
    if (Te !== void 0) {
      const K = `${o}/items`;
      if (Array.isArray(Te)) {
        const B = Math.min(Te.length, he);
        for (; oe < B; oe++) {
          const ge = Ge(e[oe], Te[oe], n, r, s, i, `${a}/${oe}`, `${K}/${oe}`);
          if (u[oe] = !0, !ge.valid && (ye = s, V.push({
            instanceLocation: a,
            keyword: "items",
            keywordLocation: K,
            error: "Items did not match schema."
          }, ...ge.errors), ye))
            break;
        }
      } else
        for (; oe < he; oe++) {
          const B = Ge(e[oe], Te, n, r, s, i, `${a}/${oe}`, K);
          if (u[oe] = !0, !B.valid && (ye = s, V.push({
            instanceLocation: a,
            keyword: "items",
            keywordLocation: K,
            error: "Items did not match schema."
          }, ...B.errors), ye))
            break;
        }
      if (!ye && me !== void 0) {
        const B = `${o}/additionalItems`;
        for (; oe < he; oe++) {
          const ge = Ge(e[oe], me, n, r, s, i, `${a}/${oe}`, B);
          u[oe] = !0, ge.valid || (ye = s, V.push({
            instanceLocation: a,
            keyword: "additionalItems",
            keywordLocation: B,
            error: "Items did not match additional items schema."
          }, ...ge.errors));
        }
      }
    }
    if (Be !== void 0)
      if (he === 0 && z === void 0)
        V.push({
          instanceLocation: a,
          keyword: "contains",
          keywordLocation: `${o}/contains`,
          error: "Array is empty. It must contain at least one item matching the schema."
        });
      else if (z !== void 0 && he < z)
        V.push({
          instanceLocation: a,
          keyword: "minContains",
          keywordLocation: `${o}/minContains`,
          error: `Array has less items (${he}) than minContains (${z}).`
        });
      else {
        const K = `${o}/contains`, B = V.length;
        let ge = 0;
        for (let pe = 0; pe < he; pe++) {
          const Dt = Ge(e[pe], Be, n, r, s, i, `${a}/${pe}`, K);
          Dt.valid ? (u[pe] = !0, ge++) : V.push(...Dt.errors);
        }
        ge >= (z || 0) && (V.length = B), z === void 0 && v === void 0 && ge === 0 ? V.splice(B, 0, {
          instanceLocation: a,
          keyword: "contains",
          keywordLocation: K,
          error: "Array does not contain item matching schema."
        }) : z !== void 0 && ge < z ? V.push({
          instanceLocation: a,
          keyword: "minContains",
          keywordLocation: `${o}/minContains`,
          error: `Array must contain at least ${z} items matching schema. Only ${ge} items were found.`
        }) : v !== void 0 && ge > v && V.push({
          instanceLocation: a,
          keyword: "maxContains",
          keywordLocation: `${o}/maxContains`,
          error: `Array may contain at most ${v} items matching schema. ${ge} items were found.`
        });
      }
    if (!ye && Re !== void 0) {
      const K = `${o}/unevaluatedItems`;
      for (oe; oe < he; oe++) {
        if (u[oe])
          continue;
        const B = Ge(e[oe], Re, n, r, s, i, `${a}/${oe}`, K);
        u[oe] = !0, B.valid || V.push({
          instanceLocation: a,
          keyword: "unevaluatedItems",
          keywordLocation: K,
          error: "Items did not match unevaluated items schema."
        }, ...B.errors);
      }
    }
    if (E)
      for (let K = 0; K < he; K++) {
        const B = e[K], ge = typeof B == "object" && B !== null;
        for (let pe = 0; pe < he; pe++) {
          if (K === pe)
            continue;
          const Dt = e[pe];
          (B === Dt || ge && (typeof Dt == "object" && Dt !== null) && _s(B, Dt)) && (V.push({
            instanceLocation: a,
            keyword: "uniqueItems",
            keywordLocation: `${o}/uniqueItems`,
            error: `Duplicate items at indexes ${K} and ${pe}.`
          }), K = Number.MAX_SAFE_INTEGER, pe = Number.MAX_SAFE_INTEGER);
        }
      }
  } else if (l === "number") {
    if (n === "4" ? (ae !== void 0 && (le === !0 && e <= ae || e < ae) && V.push({
      instanceLocation: a,
      keyword: "minimum",
      keywordLocation: `${o}/minimum`,
      error: `${e} is less than ${le ? "or equal to " : ""} ${ae}.`
    }), ce !== void 0 && (fe === !0 && e >= ce || e > ce) && V.push({
      instanceLocation: a,
      keyword: "maximum",
      keywordLocation: `${o}/maximum`,
      error: `${e} is greater than ${fe ? "or equal to " : ""} ${ce}.`
    })) : (ae !== void 0 && e < ae && V.push({
      instanceLocation: a,
      keyword: "minimum",
      keywordLocation: `${o}/minimum`,
      error: `${e} is less than ${ae}.`
    }), ce !== void 0 && e > ce && V.push({
      instanceLocation: a,
      keyword: "maximum",
      keywordLocation: `${o}/maximum`,
      error: `${e} is greater than ${ce}.`
    }), le !== void 0 && e <= le && V.push({
      instanceLocation: a,
      keyword: "exclusiveMinimum",
      keywordLocation: `${o}/exclusiveMinimum`,
      error: `${e} is less than ${le}.`
    }), fe !== void 0 && e >= fe && V.push({
      instanceLocation: a,
      keyword: "exclusiveMaximum",
      keywordLocation: `${o}/exclusiveMaximum`,
      error: `${e} is greater than or equal to ${fe}.`
    })), Ae !== void 0) {
      const he = e % Ae;
      Math.abs(0 - he) >= 11920929e-14 && Math.abs(Ae - he) >= 11920929e-14 && V.push({
        instanceLocation: a,
        keyword: "multipleOf",
        keywordLocation: `${o}/multipleOf`,
        error: `${e} is not a multiple of ${Ae}.`
      });
    }
  } else if (l === "string") {
    const he = Oe === void 0 && Xe === void 0 ? 0 : nD(e);
    Oe !== void 0 && he < Oe && V.push({
      instanceLocation: a,
      keyword: "minLength",
      keywordLocation: `${o}/minLength`,
      error: `String is too short (${he} < ${Oe}).`
    }), Xe !== void 0 && he > Xe && V.push({
      instanceLocation: a,
      keyword: "maxLength",
      keywordLocation: `${o}/maxLength`,
      error: `String is too long (${he} > ${Xe}).`
    }), dn !== void 0 && !new RegExp(dn, "u").test(e) && V.push({
      instanceLocation: a,
      keyword: "pattern",
      keywordLocation: `${o}/pattern`,
      error: "String does not match pattern."
    }), j !== void 0 && Dv[j] && !Dv[j](e) && V.push({
      instanceLocation: a,
      keyword: "format",
      keywordLocation: `${o}/format`,
      error: `String does not match format "${j}".`
    });
  }
  return { valid: V.length === 0, errors: V };
}
class rD {
  schema;
  draft;
  shortCircuit;
  lookup;
  constructor(t, n = "2019-09", r = !0) {
    this.schema = t, this.draft = n, this.shortCircuit = r, this.lookup = Pr(t);
  }
  validate(t) {
    return Ge(t, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(t, n) {
    n && (t = { ...t, $id: n }), Pr(t, this.lookup);
  }
}
var sD = {};
$e(sD, {
  Validator: () => rD,
  deepCompareStrict: () => _s,
  toJsonSchema: () => it,
  validatesOnlyStrings: () => so
});
function it(e, t) {
  if (Ke(e)) {
    const n = CE(e, !0);
    if (Wn(n)) {
      const r = qc(n, !0);
      return ip(r, t);
    } else return ip(e, t);
  }
  return ot(e) ? OL(e) : e;
}
function so(e) {
  if (!e || typeof e != "object" || Object.keys(e).length === 0 || Array.isArray(e)) return !1;
  if ("type" in e)
    return typeof e.type == "string" ? e.type === "string" : Array.isArray(e.type) ? e.type.every((t) => t === "string") : !1;
  if ("enum" in e) return Array.isArray(e.enum) && e.enum.length > 0 && e.enum.every((t) => typeof t == "string");
  if ("const" in e) return typeof e.const == "string";
  if ("allOf" in e && Array.isArray(e.allOf)) return e.allOf.some((t) => so(t));
  if ("anyOf" in e && Array.isArray(e.anyOf) || "oneOf" in e && Array.isArray(e.oneOf)) {
    const t = "anyOf" in e ? e.anyOf : e.oneOf;
    return t.length > 0 && t.every((n) => so(n));
  }
  if ("not" in e) return !1;
  if ("$ref" in e && typeof e.$ref == "string") {
    const t = e.$ref, n = Pr(e);
    return n[t] ? so(n[t]) : !1;
  }
  return !1;
}
var iD = {};
$e(iD, { Graph: () => Hm });
function aD(e, t) {
  if (e !== void 0 && !lc(e)) return e;
  if (jm(t)) try {
    let n = t.getName();
    return n = n.startsWith("Runnable") ? n.slice(8) : n, n;
  } catch {
    return t.getName();
  }
  else return t.name ?? "UnknownSchema";
}
function oD(e) {
  return jm(e.data) ? {
    type: "runnable",
    data: {
      id: e.data.lc_id,
      name: e.data.getName()
    }
  } : {
    type: "schema",
    data: {
      ...it(e.data.schema),
      title: e.data.name
    }
  };
}
var Hm = class ZE {
  nodes = {};
  edges = [];
  constructor(t) {
    this.nodes = t?.nodes ?? this.nodes, this.edges = t?.edges ?? this.edges;
  }
  toJSON() {
    const t = {};
    return Object.values(this.nodes).forEach((n, r) => {
      t[n.id] = lc(n.id) ? r : n.id;
    }), {
      nodes: Object.values(this.nodes).map((n) => ({
        id: t[n.id],
        ...oD(n)
      })),
      edges: this.edges.map((n) => {
        const r = {
          source: t[n.source],
          target: t[n.target]
        };
        return typeof n.data < "u" && (r.data = n.data), typeof n.conditional < "u" && (r.conditional = n.conditional), r;
      })
    };
  }
  addNode(t, n, r) {
    if (n !== void 0 && this.nodes[n] !== void 0) throw new Error(`Node with id ${n} already exists`);
    const s = n ?? qT(), i = {
      id: s,
      data: t,
      name: aD(n, t),
      metadata: r
    };
    return this.nodes[s] = i, i;
  }
  removeNode(t) {
    delete this.nodes[t.id], this.edges = this.edges.filter((n) => n.source !== t.id && n.target !== t.id);
  }
  addEdge(t, n, r, s) {
    if (this.nodes[t.id] === void 0) throw new Error(`Source node ${t.id} not in graph`);
    if (this.nodes[n.id] === void 0) throw new Error(`Target node ${n.id} not in graph`);
    const i = {
      source: t.id,
      target: n.id,
      data: r,
      conditional: s
    };
    return this.edges.push(i), i;
  }
  firstNode() {
    return Uv(this);
  }
  lastNode() {
    return Fv(this);
  }
  /**
  * Add all nodes and edges from another graph.
  * Note this doesn't check for duplicates, nor does it connect the graphs.
  */
  extend(t, n = "") {
    let r = n;
    Object.values(t.nodes).map((c) => c.id).every(lc) && (r = "");
    const i = (c) => r ? `${r}:${c}` : c;
    Object.entries(t.nodes).forEach(([c, l]) => {
      this.nodes[i(c)] = {
        ...l,
        id: i(c)
      };
    });
    const a = t.edges.map((c) => ({
      ...c,
      source: i(c.source),
      target: i(c.target)
    }));
    this.edges = [...this.edges, ...a];
    const o = t.firstNode(), u = t.lastNode();
    return [o ? {
      id: i(o.id),
      data: o.data
    } : void 0, u ? {
      id: i(u.id),
      data: u.data
    } : void 0];
  }
  trimFirstNode() {
    const t = this.firstNode();
    t && Uv(this, [t.id]) && this.removeNode(t);
  }
  trimLastNode() {
    const t = this.lastNode();
    t && Fv(this, [t.id]) && this.removeNode(t);
  }
  /**
  * Return a new graph with all nodes re-identified,
  * using their unique, readable names where possible.
  */
  reid() {
    const t = Object.fromEntries(Object.values(this.nodes).map((s) => [s.id, s.name])), n = /* @__PURE__ */ new Map();
    Object.values(t).forEach((s) => {
      n.set(s, (n.get(s) || 0) + 1);
    });
    const r = (s) => {
      const i = t[s];
      return lc(s) && n.get(i) === 1 ? i : s;
    };
    return new ZE({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([s, i]) => [r(s), {
        ...i,
        id: r(s)
      }])),
      edges: this.edges.map((s) => ({
        ...s,
        source: r(s.source),
        target: r(s.target)
      }))
    });
  }
  drawMermaid(t) {
    const { withStyles: n, curveStyle: r, nodeColors: s = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords: i } = t ?? {}, a = this.reid(), o = a.firstNode(), u = a.lastNode();
    return mj(a.nodes, a.edges, {
      firstNode: o?.id,
      lastNode: u?.id,
      withStyles: n,
      curveStyle: r,
      nodeColors: s,
      wrapLabelNWords: i
    });
  }
  async drawMermaidPng(t) {
    const n = this.drawMermaid(t);
    return gj(n, { backgroundColor: t?.backgroundColor });
  }
};
function Uv(e, t = []) {
  const n = new Set(e.edges.filter((s) => !t.includes(s.source)).map((s) => s.target)), r = [];
  for (const s of Object.values(e.nodes)) !t.includes(s.id) && !n.has(s.id) && r.push(s);
  return r.length === 1 ? r[0] : void 0;
}
function Fv(e, t = []) {
  const n = new Set(e.edges.filter((s) => !t.includes(s.target)).map((s) => s.source)), r = [];
  for (const s of Object.values(e.nodes)) !t.includes(s.id) && !n.has(s.id) && r.push(s);
  return r.length === 1 ? r[0] : void 0;
}
function uD(e) {
  const t = new TextEncoder(), n = new ReadableStream({ async start(r) {
    for await (const s of e) r.enqueue(t.encode(`event: data
data: ${JSON.stringify(s)}

`));
    r.enqueue(t.encode(`event: end

`)), r.close();
  } });
  return jn.fromReadableStream(n);
}
function zv(e) {
  return typeof e == "object" && e !== null && typeof e[Symbol.iterator] == "function" && typeof e.next == "function";
}
const cD = (e) => e != null && typeof e == "object" && "next" in e && typeof e.next == "function";
function _p(e) {
  return typeof e == "object" && e !== null && typeof e[Symbol.asyncIterator] == "function";
}
function* qv(e, t) {
  for (; ; ) {
    const { value: n, done: r } = Mn.runWithConfig(dr(e), t.next.bind(t), !0);
    if (r) break;
    yield n;
  }
}
async function* yp(e, t) {
  const n = t[Symbol.asyncIterator]();
  for (; ; ) {
    const { value: r, done: s } = await Mn.runWithConfig(dr(e), n.next.bind(t), !0);
    if (s) break;
    yield r;
  }
}
function ft(e, t) {
  return e && !Array.isArray(e) && !(e instanceof Date) && typeof e == "object" ? e : { [t]: e };
}
var nt = class extends ri {
  lc_runnable = !0;
  name;
  getName(e) {
    const t = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return e ? `${t}${e}` : t;
  }
  /**
  * Add retry logic to an existing runnable.
  * @param fields.stopAfterAttempt The number of attempts to retry.
  * @param fields.onFailedAttempt A function that is called when a retry fails.
  * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
  */
  withRetry(e) {
    return new Gm({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: e?.stopAfterAttempt,
      ...e
    });
  }
  /**
  * Bind config to a Runnable, returning a new Runnable.
  * @param config New configuration parameters to attach to the new runnable.
  * @returns A new RunnableBinding with a config matching what's passed.
  */
  withConfig(e) {
    return new fi({
      bound: this,
      config: e,
      kwargs: {}
    });
  }
  /**
  * Create a new runnable from the current one that will try invoking
  * other passed fallback runnables if the initial invocation fails.
  * @param fields.fallbacks Other runnables to call if the runnable errors.
  * @returns A new RunnableWithFallbacks.
  */
  withFallbacks(e) {
    const t = Array.isArray(e) ? e : e.fallbacks;
    return new KE({
      runnable: this,
      fallbacks: t
    });
  }
  _getOptionsList(e, t = 0) {
    if (Array.isArray(e) && e.length !== t) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);
    if (Array.isArray(e)) return e.map(Ne);
    if (t > 1 && !Array.isArray(e) && e.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const n = Object.fromEntries(Object.entries(e).filter(([r]) => r !== "runId"));
      return Array.from({ length: t }, (r, s) => Ne(s === 0 ? e : n));
    }
    return Array.from({ length: t }, () => Ne(e));
  }
  async batch(e, t, n) {
    const r = this._getOptionsList(t ?? {}, e.length), s = r[0]?.maxConcurrency ?? n?.maxConcurrency, i = new Uo({
      maxConcurrency: s,
      onFailedAttempt: (o) => {
        throw o;
      }
    }), a = e.map((o, u) => i.call(async () => {
      try {
        return await this.invoke(o, r[u]);
      } catch (c) {
        if (n?.returnExceptions) return c;
        throw c;
      }
    }));
    return Promise.all(a);
  }
  /**
  * Default streaming implementation.
  * Subclasses should override this method if they support streaming output.
  * @param input
  * @param options
  */
  async *_streamIterator(e, t) {
    yield this.invoke(e, t);
  }
  /**
  * Stream output in chunks.
  * @param input
  * @param options
  * @returns A readable stream that is also an iterable.
  */
  async stream(e, t) {
    const n = Ne(t), r = new Os({
      generator: this._streamIterator(e, n),
      config: n
    });
    return await r.setup, jn.fromAsyncGenerator(r);
  }
  _separateRunnableConfigFromCallOptions(e) {
    let t;
    e === void 0 ? t = Ne(e) : t = Ne({
      callbacks: e.callbacks,
      tags: e.tags,
      metadata: e.metadata,
      runName: e.runName,
      configurable: e.configurable,
      recursionLimit: e.recursionLimit,
      maxConcurrency: e.maxConcurrency,
      runId: e.runId,
      timeout: e.timeout,
      signal: e.signal
    });
    const n = { ...e };
    return delete n.callbacks, delete n.tags, delete n.metadata, delete n.runName, delete n.configurable, delete n.recursionLimit, delete n.maxConcurrency, delete n.runId, delete n.timeout, delete n.signal, [t, n];
  }
  async _callWithConfig(e, t, n) {
    const r = Ne(n), i = await (await un(r))?.handleChainStart(this.toJSON(), ft(t, "input"), r.runId, r?.runType, void 0, void 0, r?.runName ?? this.getName());
    delete r.runId;
    let a;
    try {
      const o = e.call(this, t, r, i);
      a = await fr(o, n?.signal);
    } catch (o) {
      throw await i?.handleChainError(o), o;
    }
    return await i?.handleChainEnd(ft(a, "output")), a;
  }
  /**
  * Internal method that handles batching and configuration for a runnable
  * It takes a function, input values, and optional configuration, and
  * returns a promise that resolves to the output values.
  * @param func The function to be executed for each input value.
  * @param input The input values to be processed.
  * @param config Optional configuration for the function execution.
  * @returns A promise that resolves to the output values.
  */
  async _batchWithConfig(e, t, n, r) {
    const s = this._getOptionsList(n ?? {}, t.length), i = await Promise.all(s.map(un)), a = await Promise.all(i.map(async (u, c) => {
      const l = await u?.handleChainStart(this.toJSON(), ft(t[c], "input"), s[c].runId, s[c].runType, void 0, void 0, s[c].runName ?? this.getName());
      return delete s[c].runId, l;
    }));
    let o;
    try {
      const u = e.call(this, t, s, a, r);
      o = await fr(u, s?.[0]?.signal);
    } catch (u) {
      throw await Promise.all(a.map((c) => c?.handleChainError(u))), u;
    }
    return await Promise.all(a.map((u) => u?.handleChainEnd(ft(o, "output")))), o;
  }
  /** @internal */
  _concatOutputChunks(e, t) {
    return hr(e, t);
  }
  /**
  * Helper method to transform an Iterator of Input values into an Iterator of
  * Output values, with callbacks.
  * Use this to implement `stream()` or `transform()` in Runnable subclasses.
  */
  async *_transformStreamWithConfig(e, t, n) {
    let r, s = !0, i, a = !0;
    const o = Ne(n), u = await un(o), c = this;
    async function* l() {
      for await (const f of e) {
        if (s) if (r === void 0) r = f;
        else try {
          r = c._concatOutputChunks(r, f);
        } catch {
          r = void 0, s = !1;
        }
        yield f;
      }
    }
    let d;
    try {
      const f = await Sx(t.bind(this), l(), async () => u?.handleChainStart(this.toJSON(), { input: "" }, o.runId, o.runType, void 0, void 0, o.runName ?? this.getName(), void 0, { lc_defers_inputs: !0 }), n?.signal, o);
      delete o.runId, d = f.setup;
      const h = d?.handlers.find(OP);
      let p = f.output;
      h !== void 0 && d !== void 0 && (p = h.tapOutputIterable(d.runId, p));
      const g = d?.handlers.find(kx);
      g !== void 0 && d !== void 0 && (p = g.tapOutputIterable(d.runId, p));
      for await (const m of p)
        if (yield m, a) if (i === void 0) i = m;
        else try {
          i = this._concatOutputChunks(i, m);
        } catch {
          i = void 0, a = !1;
        }
    } catch (f) {
      throw await d?.handleChainError(f, void 0, void 0, void 0, { inputs: ft(r, "input") }), f;
    }
    await d?.handleChainEnd(i ?? {}, void 0, void 0, void 0, { inputs: ft(r, "input") });
  }
  getGraph(e) {
    const t = new Hm(), n = t.addNode({
      name: `${this.getName()}Input`,
      schema: Mv()
    }), r = t.addNode(this), s = t.addNode({
      name: `${this.getName()}Output`,
      schema: Mv()
    });
    return t.addEdge(n, r), t.addEdge(r, s), t;
  }
  /**
  * Create a new runnable sequence that runs each individual runnable in series,
  * piping the output of one runnable into another runnable or runnable-like.
  * @param coerceable A runnable, function, or object whose values are functions or runnables.
  * @returns A new runnable sequence.
  */
  pipe(e) {
    return new Kr({
      first: this,
      last: Rn(e)
    });
  }
  /**
  * Pick keys from the dict output of this runnable. Returns a new runnable.
  */
  pick(e) {
    return this.pipe(new YE(e));
  }
  /**
  * Assigns new fields to the dict output of this runnable. Returns a new runnable.
  */
  assign(e) {
    return this.pipe(new Wm(new wi({ steps: e })));
  }
  /**
  * Default implementation of transform, which buffers input and then calls stream.
  * Subclasses should override this method if they can start producing output while
  * input is still being generated.
  * @param generator
  * @param options
  */
  async *transform(e, t) {
    let n;
    for await (const r of e) n === void 0 ? n = r : n = this._concatOutputChunks(n, r);
    yield* this._streamIterator(n, Ne(t));
  }
  /**
  * Stream all output from a runnable, as reported to the callback system.
  * This includes all inner runs of LLMs, Retrievers, Tools, etc.
  * Output is streamed as Log objects, which include a list of
  * jsonpatch ops that describe how the state of the run has changed in each
  * step, and the final state of the run.
  * The jsonpatch ops can be applied in order to construct state.
  * @param input
  * @param options
  * @param streamOptions
  */
  async *streamLog(e, t, n) {
    const r = new tp({
      ...n,
      autoClose: !1,
      _schemaFormat: "original"
    }), s = Ne(t);
    yield* this._streamLog(e, r, s);
  }
  async *_streamLog(e, t, n) {
    const { callbacks: r } = n;
    if (r === void 0) n.callbacks = [t];
    else if (Array.isArray(r)) n.callbacks = r.concat([t]);
    else {
      const o = r.copy();
      o.addHandler(t, !0), n.callbacks = o;
    }
    const s = this.stream(e, n);
    async function i() {
      try {
        const o = await s;
        for await (const u of o) {
          const c = new ar({ ops: [{
            op: "add",
            path: "/streamed_output/-",
            value: u
          }] });
          await t.writer.write(c);
        }
      } finally {
        await t.writer.close();
      }
    }
    const a = i();
    try {
      for await (const o of t) yield o;
    } finally {
      await a;
    }
  }
  streamEvents(e, t, n) {
    let r;
    if (t.version === "v1") r = this._streamEventsV1(e, t, n);
    else if (t.version === "v2") r = this._streamEventsV2(e, t, n);
    else throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
    return t.encoding === "text/event-stream" ? uD(r) : jn.fromAsyncGenerator(r);
  }
  async *_streamEventsV2(e, t, n) {
    const r = new IP({
      ...n,
      autoClose: !1
    }), s = Ne(t), i = s.runId ?? qT();
    s.runId = i;
    const a = s.callbacks;
    if (a === void 0) s.callbacks = [r];
    else if (Array.isArray(a)) s.callbacks = a.concat(r);
    else {
      const h = a.copy();
      h.addHandler(r, !0), s.callbacks = h;
    }
    const o = new AbortController(), u = this;
    async function c() {
      let h, p = null;
      try {
        t?.signal ? "any" in AbortSignal ? h = AbortSignal.any([o.signal, t.signal]) : (h = t.signal, p = () => {
          o.abort();
        }, t.signal.addEventListener("abort", p, { once: !0 })) : h = o.signal;
        const g = await u.stream(e, {
          ...s,
          signal: h
        }), m = r.tapOutputIterable(i, g);
        for await (const _ of m) if (o.signal.aborted) break;
      } finally {
        await r.finish(), h && p && h.removeEventListener("abort", p);
      }
    }
    const l = c();
    let d = !1, f;
    try {
      for await (const h of r) {
        if (!d) {
          h.data.input = e, d = !0, f = h.run_id, yield h;
          continue;
        }
        h.run_id === f && h.event.endsWith("_end") && h.data?.input && delete h.data.input, yield h;
      }
    } finally {
      o.abort(), await l;
    }
  }
  async *_streamEventsV1(e, t, n) {
    let r, s = !1;
    const i = Ne(t), a = i.tags ?? [], o = i.metadata ?? {}, u = i.runName ?? this.getName(), c = new tp({
      ...n,
      autoClose: !1,
      _schemaFormat: "streaming_events"
    }), l = new FP({ ...n }), d = this._streamLog(e, c, i);
    for await (const h of d) {
      if (r ? r = r.concat(h) : r = Mm.fromRunLogPatch(h), r.state === void 0) throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!s) {
        s = !0;
        const _ = { ...r.state }, y = {
          run_id: _.id,
          event: `on_${_.type}_start`,
          name: u,
          tags: a,
          metadata: o,
          data: { input: e }
        };
        l.includeEvent(y, _.type) && (yield y);
      }
      const p = h.ops.filter((_) => _.path.startsWith("/logs/")).map((_) => _.path.split("/")[2]), g = [...new Set(p)];
      for (const _ of g) {
        let y, b = {};
        const T = r.state.logs[_];
        if (T.end_time === void 0 ? T.streamed_output.length > 0 ? y = "stream" : y = "start" : y = "end", y === "start")
          T.inputs !== void 0 && (b.input = T.inputs);
        else if (y === "end")
          T.inputs !== void 0 && (b.input = T.inputs), b.output = T.final_output;
        else if (y === "stream") {
          const x = T.streamed_output.length;
          if (x !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${x} instead. Encountered in: "${T.name}"`);
          b = { chunk: T.streamed_output[0] }, T.streamed_output = [];
        }
        yield {
          event: `on_${T.type}_${y}`,
          name: T.name,
          run_id: T.id,
          tags: T.tags,
          metadata: T.metadata,
          data: b
        };
      }
      const { state: m } = r;
      if (m.streamed_output.length > 0) {
        const _ = m.streamed_output.length;
        if (_ !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${_} instead. Encountered in: "${m.name}"`);
        const y = { chunk: m.streamed_output[0] };
        m.streamed_output = [];
        const b = {
          event: `on_${m.type}_stream`,
          run_id: m.id,
          tags: a,
          metadata: o,
          name: u,
          data: y
        };
        l.includeEvent(b, m.type) && (yield b);
      }
    }
    const f = r?.state;
    if (f !== void 0) {
      const h = {
        event: `on_${f.type}_end`,
        name: u,
        run_id: f.id,
        tags: a,
        metadata: o,
        data: { output: f.final_output }
      };
      l.includeEvent(h, f.type) && (yield h);
    }
  }
  static isRunnable(e) {
    return jm(e);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: e, onEnd: t, onError: n }) {
    return new fi({
      bound: this,
      config: {},
      configFactories: [(r) => ({ callbacks: [new Ax({
        config: r,
        onStart: e,
        onEnd: t,
        onError: n
      })] })]
    });
  }
  /**
  * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
  * which contains the runnable, name, description and schema.
  *
  * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
  *
  * @param fields
  * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
  * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
  * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
  * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
  */
  asTool(e) {
    return pD(this, e);
  }
}, fi = class VE extends nt {
  static lc_name() {
    return "RunnableBinding";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  bound;
  config;
  kwargs;
  configFactories;
  constructor(t) {
    super(t), this.bound = t.bound, this.kwargs = t.kwargs, this.config = t.config, this.configFactories = t.configFactories;
  }
  getName(t) {
    return this.bound.getName(t);
  }
  async _mergeConfig(...t) {
    const n = Pc(this.config, ...t);
    return Pc(n, ...this.configFactories ? await Promise.all(this.configFactories.map(async (r) => await r(n))) : []);
  }
  withConfig(t) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: {
        ...this.config,
        ...t
      }
    });
  }
  withRetry(t) {
    return new Gm({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      maxAttemptNumber: t?.stopAfterAttempt,
      ...t
    });
  }
  async invoke(t, n) {
    return this.bound.invoke(t, await this._mergeConfig(n, this.kwargs));
  }
  async batch(t, n, r) {
    const s = Array.isArray(n) ? await Promise.all(n.map(async (i) => this._mergeConfig(Ne(i), this.kwargs))) : await this._mergeConfig(Ne(n), this.kwargs);
    return this.bound.batch(t, s, r);
  }
  /** @internal */
  _concatOutputChunks(t, n) {
    return this.bound._concatOutputChunks(t, n);
  }
  async *_streamIterator(t, n) {
    yield* this.bound._streamIterator(t, await this._mergeConfig(Ne(n), this.kwargs));
  }
  async stream(t, n) {
    return this.bound.stream(t, await this._mergeConfig(Ne(n), this.kwargs));
  }
  async *transform(t, n) {
    yield* this.bound.transform(t, await this._mergeConfig(Ne(n), this.kwargs));
  }
  streamEvents(t, n, r) {
    const s = this, i = async function* () {
      yield* s.bound.streamEvents(t, {
        ...await s._mergeConfig(Ne(n), s.kwargs),
        version: n.version
      }, r);
    };
    return jn.fromAsyncGenerator(i());
  }
  static isRunnableBinding(t) {
    return t.bound && nt.isRunnable(t.bound);
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: t, onEnd: n, onError: r }) {
    return new VE({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [(s) => ({ callbacks: [new Ax({
        config: s,
        onStart: t,
        onEnd: n,
        onError: r
      })] })]
    });
  }
}, lD = class HE extends nt {
  static lc_name() {
    return "RunnableEach";
  }
  lc_serializable = !0;
  lc_namespace = ["langchain_core", "runnables"];
  bound;
  constructor(t) {
    super(t), this.bound = t.bound;
  }
  /**
  * Invokes the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(t, n) {
    return this._callWithConfig(this._invoke.bind(this), t, n);
  }
  /**
  * A helper method that is used to invoke the runnable with the specified input and configuration.
  * @param input The input to invoke the runnable with.
  * @param config The configuration to invoke the runnable with.
  * @returns A promise that resolves to the output of the runnable.
  */
  async _invoke(t, n, r) {
    return this.bound.batch(t, Ze(n, { callbacks: r?.getChild() }));
  }
  /**
  * Bind lifecycle listeners to a Runnable, returning a new Runnable.
  * The Run object contains information about the run, including its id,
  * type, input, output, error, startTime, endTime, and any tags or metadata
  * added to the run.
  *
  * @param {Object} params - The object containing the callback functions.
  * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
  * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
  * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
  */
  withListeners({ onStart: t, onEnd: n, onError: r }) {
    return new HE({ bound: this.bound.withListeners({
      onStart: t,
      onEnd: n,
      onError: r
    }) });
  }
}, Gm = class extends fi {
  static lc_name() {
    return "RunnableRetry";
  }
  lc_namespace = ["langchain_core", "runnables"];
  maxAttemptNumber = 3;
  onFailedAttempt = () => {
  };
  constructor(e) {
    super(e), this.maxAttemptNumber = e.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = e.onFailedAttempt ?? this.onFailedAttempt;
  }
  _patchConfigForRetry(e, t, n) {
    const r = e > 1 ? `retry:attempt:${e}` : void 0;
    return Ze(t, { callbacks: n?.getChild(r) });
  }
  async _invoke(e, t, n) {
    return np((r) => super.invoke(e, this._patchConfigForRetry(r, t, n)), {
      onFailedAttempt: ({ error: r }) => this.onFailedAttempt(r, e),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: !0
    });
  }
  /**
  * Method that invokes the runnable with the specified input, run manager,
  * and config. It handles the retry logic by catching any errors and
  * recursively invoking itself with the updated config for the next retry
  * attempt.
  * @param input The input for the runnable.
  * @param runManager The run manager for the runnable.
  * @param config The config for the runnable.
  * @returns A promise that resolves to the output of the runnable.
  */
  async invoke(e, t) {
    return this._callWithConfig(this._invoke.bind(this), e, t);
  }
  async _batch(e, t, n, r) {
    const s = {};
    try {
      await np(async (i) => {
        const a = e.map((d, f) => f).filter((d) => s[d.toString()] === void 0 || s[d.toString()] instanceof Error), o = a.map((d) => e[d]), u = a.map((d) => this._patchConfigForRetry(i, t?.[d], n?.[d])), c = await super.batch(o, u, {
          ...r,
          returnExceptions: !0
        });
        let l;
        for (let d = 0; d < c.length; d += 1) {
          const f = c[d], h = a[d];
          f instanceof Error && l === void 0 && (l = f, l.input = o[d]), s[h.toString()] = f;
        }
        if (l) throw l;
        return c;
      }, {
        onFailedAttempt: ({ error: i }) => this.onFailedAttempt(i, i.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: !0
      });
    } catch (i) {
      if (r?.returnExceptions !== !0) throw i;
    }
    return Object.keys(s).sort((i, a) => parseInt(i, 10) - parseInt(a, 10)).map((i) => s[parseInt(i, 10)]);
  }
  async batch(e, t, n) {
    return this._batchWithConfig(this._batch.bind(this), e, t, n);
  }
}, Kr = class Ga extends nt {
  static lc_name() {
    return "RunnableSequence";
  }
  first;
  middle = [];
  last;
  omitSequenceTags = !1;
  lc_serializable = !0;
  lc_namespace = ["langchain_core", "runnables"];
  constructor(t) {
    super(t), this.first = t.first, this.middle = t.middle ?? this.middle, this.last = t.last, this.name = t.name, this.omitSequenceTags = t.omitSequenceTags ?? this.omitSequenceTags;
  }
  get steps() {
    return [
      this.first,
      ...this.middle,
      this.last
    ];
  }
  async invoke(t, n) {
    const r = Ne(n), i = await (await un(r))?.handleChainStart(this.toJSON(), ft(t, "input"), r.runId, void 0, void 0, void 0, r?.runName);
    delete r.runId;
    let a = t, o;
    try {
      const u = [this.first, ...this.middle];
      for (let c = 0; c < u.length; c += 1) {
        const d = u[c].invoke(a, Ze(r, { callbacks: i?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${c + 1}`) }));
        a = await fr(d, n?.signal);
      }
      if (n?.signal?.aborted) throw po(n.signal);
      o = await this.last.invoke(a, Ze(r, { callbacks: i?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (u) {
      throw await i?.handleChainError(u), u;
    }
    return await i?.handleChainEnd(ft(o, "output")), o;
  }
  async batch(t, n, r) {
    const s = this._getOptionsList(n ?? {}, t.length), i = await Promise.all(s.map(un)), a = await Promise.all(i.map(async (u, c) => {
      const l = await u?.handleChainStart(this.toJSON(), ft(t[c], "input"), s[c].runId, void 0, void 0, void 0, s[c].runName);
      return delete s[c].runId, l;
    }));
    let o = t;
    try {
      for (let u = 0; u < this.steps.length; u += 1) {
        const l = this.steps[u].batch(o, a.map((d, f) => {
          const h = d?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${u + 1}`);
          return Ze(s[f], { callbacks: h });
        }), r);
        o = await fr(l, s[0]?.signal);
      }
    } catch (u) {
      throw await Promise.all(a.map((c) => c?.handleChainError(u))), u;
    }
    return await Promise.all(a.map((u) => u?.handleChainEnd(ft(o, "output")))), o;
  }
  /** @internal */
  _concatOutputChunks(t, n) {
    return this.last._concatOutputChunks(t, n);
  }
  async *_streamIterator(t, n) {
    const r = await un(n), { runId: s, ...i } = n ?? {}, a = await r?.handleChainStart(this.toJSON(), ft(t, "input"), s, void 0, void 0, void 0, i?.runName), o = [
      this.first,
      ...this.middle,
      this.last
    ];
    let u = !0, c;
    async function* l() {
      yield t;
    }
    try {
      let d = o[0].transform(l(), Ze(i, { callbacks: a?.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
      for (let f = 1; f < o.length; f += 1)
        d = await o[f].transform(d, Ze(i, { callbacks: a?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${f + 1}`) }));
      for await (const f of d)
        if (n?.signal?.throwIfAborted(), yield f, u) if (c === void 0) c = f;
        else try {
          c = this._concatOutputChunks(c, f);
        } catch {
          c = void 0, u = !1;
        }
    } catch (d) {
      throw await a?.handleChainError(d), d;
    }
    await a?.handleChainEnd(ft(c, "output"));
  }
  getGraph(t) {
    const n = new Hm();
    let r = null;
    return this.steps.forEach((s, i) => {
      const a = s.getGraph(t);
      i !== 0 && a.trimFirstNode(), i !== this.steps.length - 1 && a.trimLastNode(), n.extend(a);
      const o = a.firstNode();
      if (!o) throw new Error(`Runnable ${s} has no first node`);
      r && n.addEdge(r, o), r = a.lastNode();
    }), n;
  }
  pipe(t) {
    return Ga.isRunnableSequence(t) ? new Ga({
      first: this.first,
      middle: this.middle.concat([
        this.last,
        t.first,
        ...t.middle
      ]),
      last: t.last,
      name: this.name ?? t.name
    }) : new Ga({
      first: this.first,
      middle: [...this.middle, this.last],
      last: Rn(t),
      name: this.name
    });
  }
  static isRunnableSequence(t) {
    return Array.isArray(t.middle) && nt.isRunnable(t);
  }
  static from([t, ...n], r) {
    let s = {};
    return typeof r == "string" ? s.name = r : r !== void 0 && (s = r), new Ga({
      ...s,
      first: Rn(t),
      middle: n.slice(0, -1).map(Rn),
      last: Rn(n[n.length - 1])
    });
  }
}, wi = class GE extends nt {
  static lc_name() {
    return "RunnableMap";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  steps;
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(t) {
    super(t), this.steps = {};
    for (const [n, r] of Object.entries(t.steps)) this.steps[n] = Rn(r);
  }
  static from(t) {
    return new GE({ steps: t });
  }
  async invoke(t, n) {
    const r = Ne(n), i = await (await un(r))?.handleChainStart(this.toJSON(), { input: t }, r.runId, void 0, void 0, void 0, r?.runName);
    delete r.runId;
    const a = {};
    try {
      const o = Object.entries(this.steps).map(async ([u, c]) => {
        a[u] = await c.invoke(t, Ze(r, { callbacks: i?.getChild(`map:key:${u}`) }));
      });
      await fr(Promise.all(o), n?.signal);
    } catch (o) {
      throw await i?.handleChainError(o), o;
    }
    return await i?.handleChainEnd(a), a;
  }
  async *_transform(t, n, r) {
    const s = { ...this.steps }, i = Pm(t, Object.keys(s).length), a = new Map(Object.entries(s).map(([o, u], c) => {
      const l = u.transform(i[c], Ze(r, { callbacks: n?.getChild(`map:key:${o}`) }));
      return [o, l.next().then((d) => ({
        key: o,
        gen: l,
        result: d
      }))];
    }));
    for (; a.size; ) {
      const o = Promise.race(a.values()), { key: u, result: c, gen: l } = await fr(o, r?.signal);
      a.delete(u), c.done || (yield { [u]: c.value }, a.set(u, l.next().then((d) => ({
        key: u,
        gen: l,
        result: d
      }))));
    }
  }
  transform(t, n) {
    return this._transformStreamWithConfig(t, this._transform.bind(this), n);
  }
  async stream(t, n) {
    async function* r() {
      yield t;
    }
    const s = Ne(n), i = new Os({
      generator: this.transform(r(), s),
      config: s
    });
    return await i.setup, jn.fromAsyncGenerator(i);
  }
}, dD = class WE extends nt {
  lc_serializable = !1;
  lc_namespace = ["langchain_core", "runnables"];
  func;
  constructor(t) {
    if (super(t), !Rm(t.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = t.func;
  }
  async invoke(t, n) {
    const [r] = this._getOptionsList(n ?? {}, 1), s = await un(r), i = this.func(Ze(r, { callbacks: s }), t);
    return fr(i, r?.signal);
  }
  async *_streamIterator(t, n) {
    const [r] = this._getOptionsList(n ?? {}, 1), s = await this.invoke(t, n);
    if (_p(s)) {
      for await (const i of s)
        r?.signal?.throwIfAborted(), yield i;
      return;
    }
    if (cD(s)) {
      for (; ; ) {
        r?.signal?.throwIfAborted();
        const i = s.next();
        if (i.done) break;
        yield i.value;
      }
      return;
    }
    yield s;
  }
  static from(t) {
    return new WE({ func: t });
  }
};
function fD(e) {
  if (Rm(e)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var _r = class JE extends nt {
  static lc_name() {
    return "RunnableLambda";
  }
  lc_namespace = ["langchain_core", "runnables"];
  func;
  constructor(t) {
    if (Rm(t.func)) return dD.from(t.func);
    super(t), fD(t.func), this.func = t.func;
  }
  static from(t) {
    return new JE({ func: t });
  }
  async _invoke(t, n, r) {
    return new Promise((s, i) => {
      const a = Ze(n, {
        callbacks: r?.getChild(),
        recursionLimit: (n?.recursionLimit ?? Qf) - 1
      });
      Mn.runWithConfig(dr(a), async () => {
        try {
          let o = await this.func(t, { ...a });
          if (o && nt.isRunnable(o)) {
            if (n?.recursionLimit === 0) throw new Error("Recursion limit reached.");
            o = await o.invoke(t, {
              ...a,
              recursionLimit: (a.recursionLimit ?? Qf) - 1
            });
          } else if (_p(o)) {
            let u;
            for await (const c of yp(a, o))
              if (n?.signal?.throwIfAborted(), u === void 0) u = c;
              else try {
                u = this._concatOutputChunks(u, c);
              } catch {
                u = c;
              }
            o = u;
          } else if (zv(o)) {
            let u;
            for (const c of qv(a, o))
              if (n?.signal?.throwIfAborted(), u === void 0) u = c;
              else try {
                u = this._concatOutputChunks(u, c);
              } catch {
                u = c;
              }
            o = u;
          }
          s(o);
        } catch (o) {
          i(o);
        }
      });
    });
  }
  async invoke(t, n) {
    return this._callWithConfig(this._invoke.bind(this), t, n);
  }
  async *_transform(t, n, r) {
    let s;
    for await (const o of t) if (s === void 0) s = o;
    else try {
      s = this._concatOutputChunks(s, o);
    } catch {
      s = o;
    }
    const i = Ze(r, {
      callbacks: n?.getChild(),
      recursionLimit: (r?.recursionLimit ?? Qf) - 1
    }), a = await new Promise((o, u) => {
      Mn.runWithConfig(dr(i), async () => {
        try {
          const c = await this.func(s, {
            ...i,
            config: i
          });
          o(c);
        } catch (c) {
          u(c);
        }
      });
    });
    if (a && nt.isRunnable(a)) {
      if (r?.recursionLimit === 0) throw new Error("Recursion limit reached.");
      const o = await a.stream(s, i);
      for await (const u of o) yield u;
    } else if (_p(a)) for await (const o of yp(i, a))
      r?.signal?.throwIfAborted(), yield o;
    else if (zv(a)) for (const o of qv(i, a))
      r?.signal?.throwIfAborted(), yield o;
    else yield a;
  }
  transform(t, n) {
    return this._transformStreamWithConfig(t, this._transform.bind(this), n);
  }
  async stream(t, n) {
    async function* r() {
      yield t;
    }
    const s = Ne(n), i = new Os({
      generator: this.transform(r(), s),
      config: s
    });
    return await i.setup, jn.fromAsyncGenerator(i);
  }
}, hD = class extends wi {
}, KE = class extends nt {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  runnable;
  fallbacks;
  constructor(e) {
    super(e), this.runnable = e.runnable, this.fallbacks = e.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const e of this.fallbacks) yield e;
  }
  async invoke(e, t) {
    const n = Ne(t), r = await un(n), { runId: s, ...i } = n, a = await r?.handleChainStart(this.toJSON(), ft(e, "input"), s, void 0, void 0, void 0, i?.runName), o = Ze(i, { callbacks: a?.getChild() });
    return await Mn.runWithConfig(o, async () => {
      let c;
      for (const l of this.runnables()) {
        n?.signal?.throwIfAborted();
        try {
          const d = await l.invoke(e, o);
          return await a?.handleChainEnd(ft(d, "output")), d;
        } catch (d) {
          c === void 0 && (c = d);
        }
      }
      throw c === void 0 ? new Error("No error stored at end of fallback.") : (await a?.handleChainError(c), c);
    });
  }
  async *_streamIterator(e, t) {
    const n = Ne(t), r = await un(n), { runId: s, ...i } = n, a = await r?.handleChainStart(this.toJSON(), ft(e, "input"), s, void 0, void 0, void 0, i?.runName);
    let o, u;
    for (const l of this.runnables()) {
      n?.signal?.throwIfAborted();
      const d = Ze(i, { callbacks: a?.getChild() });
      try {
        const f = await l.stream(e, d);
        u = yp(d, f);
        break;
      } catch (f) {
        o === void 0 && (o = f);
      }
    }
    if (u === void 0) {
      const l = o ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
      throw await a?.handleChainError(l), l;
    }
    let c;
    try {
      for await (const l of u) {
        yield l;
        try {
          c = c === void 0 ? c : this._concatOutputChunks(c, l);
        } catch {
          c = void 0;
        }
      }
    } catch (l) {
      throw await a?.handleChainError(l), l;
    }
    await a?.handleChainEnd(ft(c, "output"));
  }
  async batch(e, t, n) {
    if (n?.returnExceptions) throw new Error("Not implemented.");
    const r = this._getOptionsList(t ?? {}, e.length), s = await Promise.all(r.map((o) => un(o))), i = await Promise.all(s.map(async (o, u) => {
      const c = await o?.handleChainStart(this.toJSON(), ft(e[u], "input"), r[u].runId, void 0, void 0, void 0, r[u].runName);
      return delete r[u].runId, c;
    }));
    let a;
    for (const o of this.runnables()) {
      r[0].signal?.throwIfAborted();
      try {
        const u = await o.batch(e, i.map((c, l) => Ze(r[l], { callbacks: c?.getChild() })), n);
        return await Promise.all(i.map((c, l) => c?.handleChainEnd(ft(u[l], "output")))), u;
      } catch (u) {
        a === void 0 && (a = u);
      }
    }
    throw a ? (await Promise.all(i.map((o) => o?.handleChainError(a))), a) : new Error("No error stored at end of fallbacks.");
  }
};
function Rn(e) {
  if (typeof e == "function") return new _r({ func: e });
  if (nt.isRunnable(e)) return e;
  if (!Array.isArray(e) && typeof e == "object") {
    const t = {};
    for (const [n, r] of Object.entries(e)) t[n] = Rn(r);
    return new wi({ steps: t });
  } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var Wm = class extends nt {
  static lc_name() {
    return "RunnableAssign";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  mapper;
  constructor(e) {
    e instanceof wi && (e = { mapper: e }), super(e), this.mapper = e.mapper;
  }
  async invoke(e, t) {
    const n = await this.mapper.invoke(e, t);
    return {
      ...e,
      ...n
    };
  }
  async *_transform(e, t, n) {
    const r = this.mapper.getStepsKeys(), [s, i] = Pm(e), a = this.mapper.transform(i, Ze(n, { callbacks: t?.getChild() })), o = a.next();
    for await (const u of s) {
      if (typeof u != "object" || Array.isArray(u)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof u}`);
      const c = Object.fromEntries(Object.entries(u).filter(([l]) => !r.includes(l)));
      Object.keys(c).length > 0 && (yield c);
    }
    yield (await o).value;
    for await (const u of a) yield u;
  }
  transform(e, t) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), t);
  }
  async stream(e, t) {
    async function* n() {
      yield e;
    }
    const r = Ne(t), s = new Os({
      generator: this.transform(n(), r),
      config: r
    });
    return await s.setup, jn.fromAsyncGenerator(s);
  }
}, YE = class extends nt {
  static lc_name() {
    return "RunnablePick";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  keys;
  constructor(e) {
    (typeof e == "string" || Array.isArray(e)) && (e = { keys: e }), super(e), this.keys = e.keys;
  }
  async _pick(e) {
    if (typeof this.keys == "string") return e[this.keys];
    {
      const t = this.keys.map((n) => [n, e[n]]).filter((n) => n[1] !== void 0);
      return t.length === 0 ? void 0 : Object.fromEntries(t);
    }
  }
  async invoke(e, t) {
    return this._callWithConfig(this._pick.bind(this), e, t);
  }
  async *_transform(e) {
    for await (const t of e) {
      const n = await this._pick(t);
      n !== void 0 && (yield n);
    }
  }
  transform(e, t) {
    return this._transformStreamWithConfig(e, this._transform.bind(this), t);
  }
  async stream(e, t) {
    async function* n() {
      yield e;
    }
    const r = Ne(t), s = new Os({
      generator: this.transform(n(), r),
      config: r
    });
    return await s.setup, jn.fromAsyncGenerator(s);
  }
}, wp = class extends fi {
  name;
  description;
  schema;
  constructor(e) {
    const t = Kr.from([_r.from(async (n) => {
      let r;
      if (to(n)) try {
        r = await Fl(this.schema, n.args);
      } catch {
        throw new Ac("Received tool input did not match expected schema", JSON.stringify(n.args));
      }
      else r = n;
      return r;
    }).withConfig({ runName: `${e.name}:parse_input` }), e.bound]).withConfig({ runName: e.name });
    super({
      bound: t,
      config: e.config ?? {}
    }), this.name = e.name, this.description = e.description, this.schema = e.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function pD(e, t) {
  const n = t.name ?? e.getName(), r = t.description ?? zl(t.schema);
  return qm(t.schema) ? new wp({
    name: n,
    description: r,
    schema: Zl({ input: Bl() }).transform((s) => s.input),
    bound: e
  }) : new wp({
    name: n,
    description: r,
    schema: t.schema,
    bound: e
  });
}
const Jc = (e, t) => {
  const n = [...new Set(t?.map((s) => {
    if (typeof s == "string") return s;
    const i = new s({});
    if (!("getType" in i) || typeof i.getType != "function") throw new Error("Invalid type provided.");
    return i.getType();
  }))], r = e.getType();
  return n.some((s) => s === r);
};
function mD(e, t) {
  return Array.isArray(e) ? Bv(e, t) : _r.from((n) => Bv(n, e));
}
function Bv(e, t = {}) {
  const { includeNames: n, excludeNames: r, includeTypes: s, excludeTypes: i, includeIds: a, excludeIds: o } = t, u = [];
  for (const c of e)
    if (!(r && c.name && r.includes(c.name))) {
      {
        if (i && Jc(c, i)) continue;
        if (o && c.id && o.includes(c.id)) continue;
      }
      s || a || n ? (n && c.name && n.some((l) => l === c.name) || s && Jc(c, s) || a && c.id && a.some((l) => l === c.id)) && u.push(c) : u.push(c);
    }
  return u;
}
function gD(e) {
  return Array.isArray(e) ? Zv(e) : _r.from(Zv);
}
function Zv(e) {
  if (!e.length) return [];
  const t = [];
  for (const n of e) {
    const r = n, s = t.pop();
    if (!s) t.push(r);
    else if (r.getType() === "tool" || r.getType() !== s.getType()) t.push(s, r);
    else {
      const i = Cc(s), a = Cc(r), o = i.concat(a);
      typeof i.content == "string" && typeof a.content == "string" && (o.content = `${i.content}
${a.content}`), t.push(wD(o));
    }
  }
  return t;
}
function _D(e, t) {
  if (Array.isArray(e)) {
    const n = e;
    if (!t) throw new Error("Options parameter is required when providing messages.");
    return Vv(n, t);
  } else {
    const n = e;
    return _r.from((r) => Vv(r, n)).withConfig({ runName: "trim_messages" });
  }
}
async function Vv(e, t) {
  const { maxTokens: n, tokenCounter: r, strategy: s = "last", allowPartial: i = !1, endOn: a, startOn: o, includeSystem: u = !1, textSplitter: c } = t;
  if (o && s === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
  if (u && s === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
  let l;
  "getNumTokens" in r ? l = async (f) => (await Promise.all(f.map((p) => r.getNumTokens(p.content)))).reduce((p, g) => p + g, 0) : l = async (f) => r(f);
  let d = QE;
  if (c && ("splitText" in c ? d = c.splitText : d = async (f) => c(f)), s === "first") return XE(e, {
    maxTokens: n,
    tokenCounter: l,
    textSplitter: d,
    partialStrategy: i ? "first" : void 0,
    endOn: a
  });
  if (s === "last") return yD(e, {
    maxTokens: n,
    tokenCounter: l,
    textSplitter: d,
    allowPartial: i,
    includeSystem: u,
    startOn: o,
    endOn: a
  });
  throw new Error(`Unrecognized strategy: '${s}'. Must be one of 'first' or 'last'.`);
}
async function XE(e, t) {
  const { maxTokens: n, tokenCounter: r, textSplitter: s, partialStrategy: i, endOn: a } = t;
  let o = [...e], u = 0;
  for (let c = 0; c < o.length; c += 1) {
    const l = c > 0 ? o.slice(0, -c) : o;
    if (await r(l) <= n) {
      u = o.length - c;
      break;
    }
  }
  if (u < o.length && i) {
    let c = !1;
    if (Array.isArray(o[u].content)) {
      const l = o[u];
      if (typeof l.content == "string") throw new Error("Expected content to be an array.");
      const d = l.content.length, f = i === "last" ? [...l.content].reverse() : l.content;
      for (let h = 1; h <= d; h += 1) {
        const p = i === "first" ? f.slice(0, h) : f.slice(-h), g = Object.fromEntries(Object.entries(l).filter(([y]) => y !== "type" && !y.startsWith("lc_"))), m = Jm(l.getType(), {
          ...g,
          content: p
        }), _ = [...o.slice(0, u), m];
        if (await r(_) <= n)
          o = _, u += 1, c = !0;
        else break;
      }
      c && i === "last" && (l.content = [...f].reverse());
    }
    if (!c) {
      const l = o[u];
      let d;
      if (Array.isArray(l.content) && l.content.some((f) => typeof f == "string" || f.type === "text") ? d = l.content.find((h) => h.type === "text" && h.text)?.text : typeof l.content == "string" && (d = l.content), d) {
        const f = await s(d), h = f.length;
        i === "last" && f.reverse();
        for (let p = 0; p < h - 1; p += 1)
          if (f.pop(), l.content = f.join(""), await r([...o.slice(0, u), l]) <= n) {
            i === "last" && (l.content = [...f].reverse().join("")), o = [...o.slice(0, u), l], u += 1;
            break;
          }
      }
    }
  }
  if (a) {
    const c = Array.isArray(a) ? a : [a];
    for (; u > 0 && !Jc(o[u - 1], c); ) u -= 1;
  }
  return o.slice(0, u);
}
async function yD(e, t) {
  const { allowPartial: n = !1, includeSystem: r = !1, endOn: s, startOn: i, ...a } = t;
  let o = e.map((l) => {
    const d = Object.fromEntries(Object.entries(l).filter(([f]) => f !== "type" && !f.startsWith("lc_")));
    return Jm(l.getType(), d, hm(l));
  });
  if (s) {
    const l = Array.isArray(s) ? s : [s];
    for (; o.length > 0 && !Jc(o[o.length - 1], l); ) o = o.slice(0, -1);
  }
  const u = r && o[0]?.getType() === "system";
  let c = u ? o.slice(0, 1).concat(o.slice(1).reverse()) : o.reverse();
  return c = await XE(c, {
    ...a,
    partialStrategy: n ? "last" : void 0,
    endOn: i
  }), u ? [c[0], ...c.slice(1).reverse()] : c.reverse();
}
const Hv = {
  human: {
    message: Zt,
    messageChunk: Mo
  },
  ai: {
    message: rt,
    messageChunk: We
  },
  system: {
    message: Kn,
    messageChunk: Lr
  },
  developer: {
    message: Kn,
    messageChunk: Lr
  },
  tool: {
    message: Jn,
    messageChunk: Ro
  },
  function: {
    message: _l,
    messageChunk: No
  },
  generic: {
    message: Hr,
    messageChunk: Po
  },
  remove: {
    message: Ic,
    messageChunk: Ic
  }
};
function Jm(e, t, n) {
  let r, s;
  switch (e) {
    case "human":
      n ? r = new Mo(t) : s = new Zt(t);
      break;
    case "ai":
      if (n) {
        let i = { ...t };
        "tool_calls" in i && (i = {
          ...i,
          tool_call_chunks: i.tool_calls?.map((a) => ({
            ...a,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(a.args)
          }))
        }), r = new We(i);
      } else s = new rt(t);
      break;
    case "system":
      n ? r = new Lr(t) : s = new Kn(t);
      break;
    case "developer":
      n ? r = new Lr({
        ...t,
        additional_kwargs: {
          ...t.additional_kwargs,
          __openai_role__: "developer"
        }
      }) : s = new Kn({
        ...t,
        additional_kwargs: {
          ...t.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      break;
    case "tool":
      if ("tool_call_id" in t) n ? r = new Ro(t) : s = new Jn(t);
      else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
      break;
    case "function":
      if (n) r = new No(t);
      else {
        if (!t.name) throw new Error("FunctionMessage must have a 'name' field");
        s = new _l(t);
      }
      break;
    case "generic":
      if ("role" in t) n ? r = new Po(t) : s = new Hr(t);
      else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
      break;
    default:
      throw new Error(`Unrecognized message type ${e}`);
  }
  if (n && r) return r;
  if (s) return s;
  throw new Error(`Unrecognized message type ${e}`);
}
function wD(e) {
  const t = e.getType();
  let n;
  const r = Object.fromEntries(Object.entries(e).filter(([s]) => !["type", "tool_call_chunks"].includes(s) && !s.startsWith("lc_")));
  if (t in Hv && (n = Jm(t, r)), !n) throw new Error(`Unrecognized message chunk class ${t}. Supported classes are ${Object.keys(Hv)}`);
  return n;
}
function QE(e) {
  const t = e.split(`
`);
  return Promise.resolve([...t.slice(0, -1).map((n) => `${n}
`), t[t.length - 1]]);
}
const vD = [
  "tool_call",
  "tool_call_chunk",
  "invalid_tool_call",
  "server_tool_call",
  "server_tool_call_chunk",
  "server_tool_call_result"
], bD = [
  "image",
  "video",
  "audio",
  "text-plain",
  "file"
], SD = [
  "text",
  "reasoning",
  ...vD,
  ...bD
];
var TD = {};
$e(TD, {
  AIMessage: () => rt,
  AIMessageChunk: () => We,
  BaseMessage: () => gr,
  BaseMessageChunk: () => Vr,
  ChatMessage: () => Hr,
  ChatMessageChunk: () => Po,
  FunctionMessage: () => _l,
  FunctionMessageChunk: () => No,
  HumanMessage: () => Zt,
  HumanMessageChunk: () => Mo,
  KNOWN_BLOCK_TYPES: () => SD,
  RemoveMessage: () => Ic,
  SystemMessage: () => Kn,
  SystemMessageChunk: () => Lr,
  ToolMessage: () => Jn,
  ToolMessageChunk: () => Ro,
  _isMessageFieldWithRole: () => xT,
  _mergeDicts: () => At,
  _mergeLists: () => $o,
  _mergeObj: () => ST,
  _mergeStatus: () => bT,
  coerceMessageLikeToMessage: () => no,
  collapseToolCallChunks: () => RT,
  convertToChunk: () => Cc,
  convertToOpenAIImageBlock: () => mT,
  convertToProviderContentBlock: () => Co,
  defaultTextSplitter: () => QE,
  defaultToolCallParser: () => gm,
  filterMessages: () => mD,
  getBufferString: () => wm,
  iife: () => $T,
  isAIMessage: () => Dr,
  isAIMessageChunk: () => Zh,
  isBase64ContentBlock: () => cm,
  isBaseMessage: () => ur,
  isBaseMessageChunk: () => hm,
  isChatMessage: () => EA,
  isChatMessageChunk: () => kA,
  isDataContentBlock: () => gn,
  isDirectToolOutput: () => mm,
  isFunctionMessage: () => OA,
  isFunctionMessageChunk: () => IA,
  isHumanMessage: () => AA,
  isHumanMessageChunk: () => CA,
  isIDContentBlock: () => pT,
  isMessage: () => gT,
  isOpenAIToolCallArray: () => bA,
  isPlainTextContentBlock: () => H1,
  isSystemMessage: () => $A,
  isSystemMessageChunk: () => RA,
  isToolMessage: () => _m,
  isToolMessageChunk: () => OT,
  isURLContentBlock: () => um,
  mapChatMessagesToStoredMessages: () => JA,
  mapStoredMessageToChatMessage: () => vm,
  mapStoredMessagesToChatMessages: () => WA,
  mergeContent: () => lr,
  mergeMessageRuns: () => gD,
  mergeResponseMetadata: () => ET,
  mergeUsageMetadata: () => pm,
  parseBase64DataUrl: () => Gn,
  parseMimeType: () => zh,
  trimMessages: () => _D
});
const ys = (e) => e();
function Fo(e) {
  return e ? !!(/^o\d/.test(e ?? "") || e.startsWith("gpt-5") && !e.startsWith("gpt-5-chat")) : !1;
}
function xD(e) {
  return e.role !== "system" && e.role !== "developer" && e.role !== "assistant" && e.role !== "user" && e.role !== "function" && e.role !== "tool" && console.warn(`Unknown message role: ${e.role}`), e.role;
}
function Kc(e) {
  const t = e.metadata?.filename ?? e.metadata?.name ?? e.metadata?.title;
  if (!t) throw new Error("a filename or name or title is needed via meta-data for OpenAI when working with multimodal blocks");
  return t;
}
function zo(e) {
  const t = e._getType();
  switch (t) {
    case "system":
      return "system";
    case "ai":
      return "assistant";
    case "human":
      return "user";
    case "function":
      return "function";
    case "tool":
      return "tool";
    case "generic":
      if (!Hr.isInstance(e)) throw new Error("Invalid generic chat message");
      return xD(e);
    default:
      throw new Error(`Unknown message type: ${t}`);
  }
}
function ED(e) {
  return e.includes("gpt-5.2-pro");
}
function kD(e) {
  const { azureOpenAIApiDeploymentName: t, azureOpenAIApiInstanceName: n, azureOpenAIApiKey: r, azureOpenAIBasePath: s, baseURL: i, azureADTokenProvider: a, azureOpenAIEndpoint: o } = e;
  if ((r || a) && s && t) return `${s}/${t}`;
  if ((r || a) && o && t) return `${o}/openai/deployments/${t}`;
  if (r || a) {
    if (!n) throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
    if (!t) throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
    return `https://${n}.openai.azure.com/openai/deployments/${t}`;
  }
  return i;
}
function Gv(e) {
  return typeof Headers < "u" && e !== null && typeof e == "object" && Object.prototype.toString.call(e) === "[object Headers]";
}
function OD(e) {
  const t = ys(() => {
    if (Gv(e)) return e;
    if (Array.isArray(e)) return new Headers(e);
    if (typeof e == "object" && e !== null && "values" in e && Gv(e.values)) return e.values;
    if (typeof e == "object" && e !== null) {
      const n = Object.entries(e).filter(([, r]) => typeof r == "string").map(([r, s]) => [r, s]);
      return new Headers(n);
    }
    return new Headers();
  });
  return Object.fromEntries(t.entries());
}
function ID() {
  let e = bm();
  return (e === "node" || e === "deno") && (e = `(${e}/${process.version}; ${process.platform}; ${process.arch})`), e;
}
function AD(e, t = !1, n = "1.0.0") {
  const r = OD(e), s = ID(), i = `langchainjs${t ? "-azure" : ""}-openai`;
  return {
    ...r,
    "User-Agent": r["User-Agent"] ? `${i}/${n} (${s})${r["User-Agent"]}` : `${i}/${n} (${s})`
  };
}
function Km(e) {
  return e !== void 0 && Array.isArray(e.lc_namespace);
}
function Ym(e) {
  return e !== void 0 && nt.isRunnable(e) && "lc_name" in e.constructor && typeof e.constructor.lc_name == "function" && e.constructor.lc_name() === "RunnableToolLike";
}
function Xm(e) {
  return !!e && typeof e == "object" && "name" in e && "schema" in e && (_t(e.schema) || e.schema != null && typeof e.schema == "object" && "type" in e.schema && typeof e.schema.type == "string" && [
    "null",
    "boolean",
    "object",
    "array",
    "number",
    "string"
  ].includes(e.schema.type));
}
function Br(e) {
  return Xm(e) || Ym(e) || Km(e);
}
var CD = {};
$e(CD, {
  convertToOpenAIFunction: () => ek,
  convertToOpenAITool: () => Yc,
  isLangChainTool: () => Br,
  isRunnableToolLike: () => Ym,
  isStructuredTool: () => Km,
  isStructuredToolParams: () => Xm
});
function ek(e, t) {
  const n = typeof t == "number" ? void 0 : t;
  return {
    name: e.name,
    description: e.description,
    parameters: it(e.schema),
    ...n?.strict !== void 0 ? { strict: n.strict } : {}
  };
}
function Yc(e, t) {
  const n = typeof t == "number" ? void 0 : t;
  let r;
  return Br(e) ? r = {
    type: "function",
    function: ek(e)
  } : r = e, n?.strict !== void 0 && (r.function.strict = n.strict), r;
}
var $D = {};
$e($D, {
  extendInteropZodObject: () => oj,
  getInteropZodDefaultGetter: () => cj,
  getInteropZodObjectShape: () => ap,
  getSchemaDescription: () => zl,
  interopParse: () => sj,
  interopParseAsync: () => Fl,
  interopSafeParse: () => rj,
  interopSafeParseAsync: () => Ul,
  interopZodObjectMakeFieldsOptional: () => fj,
  interopZodObjectPartial: () => uj,
  interopZodObjectPassthrough: () => op,
  interopZodObjectStrict: () => qc,
  interopZodTransformInputSchema: () => CE,
  isInteropZodError: () => $E,
  isInteropZodLiteral: () => nj,
  isInteropZodObject: () => aj,
  isInteropZodSchema: () => _t,
  isShapelessZodSchema: () => ij,
  isSimpleStringZodSchema: () => qm,
  isZodArrayV4: () => ql,
  isZodLiteralV3: () => kE,
  isZodLiteralV4: () => OE,
  isZodNullableV4: () => AE,
  isZodObjectV3: () => Bm,
  isZodObjectV4: () => Wn,
  isZodOptionalV4: () => IE,
  isZodSchema: () => tj,
  isZodSchemaV3: () => ot,
  isZodSchemaV4: () => Ke
});
function RD(e, t) {
  let n;
  return Br(e) ? n = Yc(e) : n = e, t?.strict !== void 0 && (n.function.strict = t.strict), n;
}
function PD(e) {
  return e.anyOf !== void 0 && Array.isArray(e.anyOf);
}
function ND(e) {
  const t = ["namespace functions {", ""];
  for (const n of e)
    n.description && t.push(`// ${n.description}`), Object.keys(n.parameters.properties ?? {}).length > 0 ? (t.push(`type ${n.name} = (_: {`), t.push(tk(n.parameters, 0)), t.push("}) => any;")) : t.push(`type ${n.name} = () => any;`), t.push("");
  return t.push("} // namespace functions"), t.join(`
`);
}
function tk(e, t) {
  const n = [];
  for (const [r, s] of Object.entries(e.properties ?? {}))
    s.description && t < 2 && n.push(`// ${s.description}`), e.required?.includes(r) ? n.push(`${r}: ${Xc(s, t)},`) : n.push(`${r}?: ${Xc(s, t)},`);
  return n.map((r) => " ".repeat(t) + r).join(`
`);
}
function Xc(e, t) {
  if (PD(e)) return e.anyOf.map((n) => Xc(n, t)).join(" | ");
  switch (e.type) {
    case "string":
      return e.enum ? e.enum.map((n) => `"${n}"`).join(" | ") : "string";
    case "number":
      return e.enum ? e.enum.map((n) => `${n}`).join(" | ") : "number";
    case "integer":
      return e.enum ? e.enum.map((n) => `${n}`).join(" | ") : "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return [
        "{",
        tk(e, t + 2),
        "}"
      ].join(`
`);
    case "array":
      return e.items ? `${Xc(e.items, t)}[]` : "any[]";
    default:
      return "";
  }
}
function nk(e) {
  if (e) return e === "any" || e === "required" ? "required" : e === "auto" ? "auto" : e === "none" ? "none" : typeof e == "string" ? {
    type: "function",
    function: { name: e }
  } : e;
}
function Qm(e) {
  return "type" in e && e.type !== "function";
}
function MD(e) {
  return typeof e == "object" && e !== null && "extras" in e && typeof e.extras == "object" && e.extras !== null && "providerToolDefinition" in e.extras && typeof e.extras.providerToolDefinition == "object" && e.extras.providerToolDefinition !== null;
}
function jD(e) {
  return e != null && typeof e == "object" && "type" in e && e.type !== "function";
}
function Qc(e) {
  return typeof e == "object" && e !== null && "metadata" in e && typeof e.metadata == "object" && e.metadata !== null && "customTool" in e.metadata && typeof e.metadata.customTool == "object" && e.metadata.customTool !== null;
}
function rk(e) {
  return "type" in e && e.type === "custom" && "custom" in e && typeof e.custom == "object" && e.custom !== null;
}
function LD(e) {
  if (e.type === "custom_tool_call")
    return {
      ...e,
      type: "tool_call",
      call_id: e.id,
      id: e.call_id,
      name: e.name,
      isCustomTool: !0,
      args: { input: e.input }
    };
}
function DD(e) {
  if (e.type === "computer_call")
    return {
      ...e,
      type: "tool_call",
      call_id: e.id,
      id: e.call_id,
      name: "computer_use",
      isComputerTool: !0,
      args: { action: e.action }
    };
}
function UD(e) {
  return typeof e == "object" && e !== null && "type" in e && e.type === "tool_call" && "isComputerTool" in e && e.isComputerTool === !0;
}
function FD(e) {
  return typeof e == "object" && e !== null && "type" in e && e.type === "tool_call" && "isCustomTool" in e && e.isCustomTool === !0;
}
function zD(e) {
  const t = () => {
    if (e.custom.format) {
      if (e.custom.format.type === "grammar") return {
        type: "grammar",
        definition: e.custom.format.grammar.definition,
        syntax: e.custom.format.grammar.syntax
      };
      if (e.custom.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    name: e.custom.name,
    description: e.custom.description,
    format: t()
  };
}
function qD(e) {
  const t = () => {
    if (e.format) {
      if (e.format.type === "grammar") return {
        type: "grammar",
        grammar: {
          definition: e.format.definition,
          syntax: e.format.syntax
        }
      };
      if (e.format.type === "text") return { type: "text" };
    }
  };
  return {
    type: "custom",
    custom: {
      name: e.name,
      description: e.description,
      format: t()
    }
  };
}
const BD = /* @__PURE__ */ R("ZodISODateTime", (e, t) => {
  cM.init(e, t), Qe.init(e, t);
});
function ZD(e) {
  return /* @__PURE__ */ p2(BD, e);
}
const VD = /* @__PURE__ */ R("ZodISODate", (e, t) => {
  lM.init(e, t), Qe.init(e, t);
});
function HD(e) {
  return /* @__PURE__ */ m2(VD, e);
}
const GD = /* @__PURE__ */ R("ZodISOTime", (e, t) => {
  dM.init(e, t), Qe.init(e, t);
});
function WD(e) {
  return /* @__PURE__ */ g2(GD, e);
}
const JD = /* @__PURE__ */ R("ZodISODuration", (e, t) => {
  fM.init(e, t), Qe.init(e, t);
});
function KD(e) {
  return /* @__PURE__ */ _2(JD, e);
}
const YD = (e, t) => {
  Dx.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => eN(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => QP(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, rp, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, rp, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, bn = R("ZodError", YD, {
  Parent: Error
}), XD = /* @__PURE__ */ Rl(bn), QD = /* @__PURE__ */ Nl(bn), e4 = /* @__PURE__ */ Ml(bn), t4 = /* @__PURE__ */ jl(bn), n4 = /* @__PURE__ */ iN(bn), r4 = /* @__PURE__ */ aN(bn), s4 = /* @__PURE__ */ oN(bn), i4 = /* @__PURE__ */ uN(bn), a4 = /* @__PURE__ */ cN(bn), o4 = /* @__PURE__ */ lN(bn), u4 = /* @__PURE__ */ dN(bn), c4 = /* @__PURE__ */ fN(bn), Ye = /* @__PURE__ */ R("ZodType", (e, t) => (Ve.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: zc(e, "input"),
    output: zc(e, "output")
  }
}), e.toJSONSchema = L2(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(Jr(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, r) => Et(e, n, r), e.brand = () => e, e.register = ((n, r) => (n.add(e, r), e)), e.parse = (n, r) => XD(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => e4(e, n, r), e.parseAsync = async (n, r) => QD(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => t4(e, n, r), e.spa = e.safeParseAsync, e.encode = (n, r) => n4(e, n, r), e.decode = (n, r) => r4(e, n, r), e.encodeAsync = async (n, r) => s4(e, n, r), e.decodeAsync = async (n, r) => i4(e, n, r), e.safeEncode = (n, r) => a4(e, n, r), e.safeDecode = (n, r) => o4(e, n, r), e.safeEncodeAsync = async (n, r) => u4(e, n, r), e.safeDecodeAsync = async (n, r) => c4(e, n, r), e.refine = (n, r) => e.check(iU(n, r)), e.superRefine = (n) => e.check(aU(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ yi(n)), e.optional = () => Kv(e), e.exactOptional = () => H4(e), e.nullable = () => Yv(e), e.nullish = () => Kv(Yv(e)), e.nonoptional = (n) => X4(e, n), e.array = () => vs(e), e.or = (n) => ok([e, n]), e.and = (n) => D4(e, n), e.transform = (n) => Xv(e, Z4(n)), e.default = (n) => J4(e, n), e.prefault = (n) => Y4(e, n), e.catch = (n) => eU(e, n), e.pipe = (n) => Xv(e, n), e.readonly = () => rU(e), e.describe = (n) => {
  const r = e.clone();
  return gt.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return gt.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return gt.get(e);
  const r = e.clone();
  return gt.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), sk = /* @__PURE__ */ R("_ZodString", (e, t) => {
  Fm.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (r, s, i) => sE(e, r, s);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(/* @__PURE__ */ b2(...r)), e.includes = (...r) => e.check(/* @__PURE__ */ x2(...r)), e.startsWith = (...r) => e.check(/* @__PURE__ */ E2(...r)), e.endsWith = (...r) => e.check(/* @__PURE__ */ k2(...r)), e.min = (...r) => e.check(/* @__PURE__ */ Lc(...r)), e.max = (...r) => e.check(/* @__PURE__ */ nE(...r)), e.length = (...r) => e.check(/* @__PURE__ */ rE(...r)), e.nonempty = (...r) => e.check(/* @__PURE__ */ Lc(1, ...r)), e.lowercase = (r) => e.check(/* @__PURE__ */ S2(r)), e.uppercase = (r) => e.check(/* @__PURE__ */ T2(r)), e.trim = () => e.check(/* @__PURE__ */ I2()), e.normalize = (...r) => e.check(/* @__PURE__ */ O2(...r)), e.toLowerCase = () => e.check(/* @__PURE__ */ A2()), e.toUpperCase = () => e.check(/* @__PURE__ */ C2()), e.slugify = () => e.check(/* @__PURE__ */ $2());
}), l4 = /* @__PURE__ */ R("ZodString", (e, t) => {
  Fm.init(e, t), sk.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ GM(d4, n)), e.url = (n) => e.check(/* @__PURE__ */ XM(f4, n)), e.jwt = (n) => e.check(/* @__PURE__ */ h2(O4, n)), e.emoji = (n) => e.check(/* @__PURE__ */ QM(h4, n)), e.guid = (n) => e.check(/* @__PURE__ */ pv(Wv, n)), e.uuid = (n) => e.check(/* @__PURE__ */ WM(Iu, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ JM(Iu, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ KM(Iu, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ YM(Iu, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ e2(p4, n)), e.guid = (n) => e.check(/* @__PURE__ */ pv(Wv, n)), e.cuid = (n) => e.check(/* @__PURE__ */ t2(m4, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ n2(g4, n)), e.ulid = (n) => e.check(/* @__PURE__ */ r2(_4, n)), e.base64 = (n) => e.check(/* @__PURE__ */ l2(x4, n)), e.base64url = (n) => e.check(/* @__PURE__ */ d2(E4, n)), e.xid = (n) => e.check(/* @__PURE__ */ s2(y4, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ i2(w4, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ a2(v4, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ o2(b4, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ u2(S4, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ c2(T4, n)), e.e164 = (n) => e.check(/* @__PURE__ */ f2(k4, n)), e.datetime = (n) => e.check(ZD(n)), e.date = (n) => e.check(HD(n)), e.time = (n) => e.check(WD(n)), e.duration = (n) => e.check(KD(n));
});
function Ie(e) {
  return /* @__PURE__ */ HM(l4, e);
}
const Qe = /* @__PURE__ */ R("ZodStringFormat", (e, t) => {
  Je.init(e, t), sk.init(e, t);
}), d4 = /* @__PURE__ */ R("ZodEmail", (e, t) => {
  eM.init(e, t), Qe.init(e, t);
}), Wv = /* @__PURE__ */ R("ZodGUID", (e, t) => {
  XN.init(e, t), Qe.init(e, t);
}), Iu = /* @__PURE__ */ R("ZodUUID", (e, t) => {
  QN.init(e, t), Qe.init(e, t);
}), f4 = /* @__PURE__ */ R("ZodURL", (e, t) => {
  tM.init(e, t), Qe.init(e, t);
}), h4 = /* @__PURE__ */ R("ZodEmoji", (e, t) => {
  nM.init(e, t), Qe.init(e, t);
}), p4 = /* @__PURE__ */ R("ZodNanoID", (e, t) => {
  rM.init(e, t), Qe.init(e, t);
}), m4 = /* @__PURE__ */ R("ZodCUID", (e, t) => {
  sM.init(e, t), Qe.init(e, t);
}), g4 = /* @__PURE__ */ R("ZodCUID2", (e, t) => {
  iM.init(e, t), Qe.init(e, t);
}), _4 = /* @__PURE__ */ R("ZodULID", (e, t) => {
  aM.init(e, t), Qe.init(e, t);
}), y4 = /* @__PURE__ */ R("ZodXID", (e, t) => {
  oM.init(e, t), Qe.init(e, t);
}), w4 = /* @__PURE__ */ R("ZodKSUID", (e, t) => {
  uM.init(e, t), Qe.init(e, t);
}), v4 = /* @__PURE__ */ R("ZodIPv4", (e, t) => {
  hM.init(e, t), Qe.init(e, t);
}), b4 = /* @__PURE__ */ R("ZodIPv6", (e, t) => {
  pM.init(e, t), Qe.init(e, t);
}), S4 = /* @__PURE__ */ R("ZodCIDRv4", (e, t) => {
  mM.init(e, t), Qe.init(e, t);
}), T4 = /* @__PURE__ */ R("ZodCIDRv6", (e, t) => {
  gM.init(e, t), Qe.init(e, t);
}), x4 = /* @__PURE__ */ R("ZodBase64", (e, t) => {
  _M.init(e, t), Qe.init(e, t);
}), E4 = /* @__PURE__ */ R("ZodBase64URL", (e, t) => {
  wM.init(e, t), Qe.init(e, t);
}), k4 = /* @__PURE__ */ R("ZodE164", (e, t) => {
  vM.init(e, t), Qe.init(e, t);
}), O4 = /* @__PURE__ */ R("ZodJWT", (e, t) => {
  SM.init(e, t), Qe.init(e, t);
}), ik = /* @__PURE__ */ R("ZodNumber", (e, t) => {
  Wx.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (r, s, i) => iE(e, r, s), e.gt = (r, s) => e.check(/* @__PURE__ */ gv(r, s)), e.gte = (r, s) => e.check(/* @__PURE__ */ nh(r, s)), e.min = (r, s) => e.check(/* @__PURE__ */ nh(r, s)), e.lt = (r, s) => e.check(/* @__PURE__ */ mv(r, s)), e.lte = (r, s) => e.check(/* @__PURE__ */ th(r, s)), e.max = (r, s) => e.check(/* @__PURE__ */ th(r, s)), e.int = (r) => e.check(Jv(r)), e.safe = (r) => e.check(Jv(r)), e.positive = (r) => e.check(/* @__PURE__ */ gv(0, r)), e.nonnegative = (r) => e.check(/* @__PURE__ */ nh(0, r)), e.negative = (r) => e.check(/* @__PURE__ */ mv(0, r)), e.nonpositive = (r) => e.check(/* @__PURE__ */ th(0, r)), e.multipleOf = (r, s) => e.check(/* @__PURE__ */ _v(r, s)), e.step = (r, s) => e.check(/* @__PURE__ */ _v(r, s)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function ze(e) {
  return /* @__PURE__ */ y2(ik, e);
}
const I4 = /* @__PURE__ */ R("ZodNumberFormat", (e, t) => {
  TM.init(e, t), ik.init(e, t);
});
function Jv(e) {
  return /* @__PURE__ */ w2(I4, e);
}
const A4 = /* @__PURE__ */ R("ZodBoolean", (e, t) => {
  xM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => aE(e, n, r);
});
function C4(e) {
  return /* @__PURE__ */ v2(A4, e);
}
const $4 = /* @__PURE__ */ R("ZodUnknown", (e, t) => {
  Jx.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => uE();
});
function el() {
  return /* @__PURE__ */ eE($4);
}
const R4 = /* @__PURE__ */ R("ZodNever", (e, t) => {
  Kx.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => oE(e, n, r);
});
function P4(e) {
  return /* @__PURE__ */ tE(R4, e);
}
const N4 = /* @__PURE__ */ R("ZodArray", (e, t) => {
  EM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => hE(e, n, r, s), e.element = t.element, e.min = (n, r) => e.check(/* @__PURE__ */ Lc(n, r)), e.nonempty = (n) => e.check(/* @__PURE__ */ Lc(1, n)), e.max = (n, r) => e.check(/* @__PURE__ */ nE(n, r)), e.length = (n, r) => e.check(/* @__PURE__ */ rE(n, r)), e.unwrap = () => e.element;
});
function vs(e, t) {
  return /* @__PURE__ */ R2(N4, e, t);
}
const M4 = /* @__PURE__ */ R("ZodObject", (e, t) => {
  OM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => pE(e, n, r, s), Le(e, "shape", () => t.shape), e.keyof = () => Vl(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: el() }), e.loose = () => e.clone({ ...e._zod.def, catchall: el() }), e.strict = () => e.clone({ ...e._zod.def, catchall: P4() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => Mx(e, n), e.safeExtend = (n) => KP(e, n), e.merge = (n) => YP(e, n), e.pick = (n) => WP(e, n), e.omit = (n) => JP(e, n), e.partial = (...n) => jx(uk, e, n[0]), e.required = (...n) => XP(ck, e, n[0]);
});
function we(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...te(t)
  };
  return new M4(n);
}
const ak = /* @__PURE__ */ R("ZodUnion", (e, t) => {
  Qx.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => mE(e, n, r, s), e.options = t.options;
});
function ok(e, t) {
  return new ak({
    type: "union",
    options: e,
    ...te(t)
  });
}
const j4 = /* @__PURE__ */ R("ZodDiscriminatedUnion", (e, t) => {
  ak.init(e, t), IM.init(e, t);
});
function As(e, t, n) {
  return new j4({
    type: "union",
    options: t,
    discriminator: e,
    ...te(n)
  });
}
const L4 = /* @__PURE__ */ R("ZodIntersection", (e, t) => {
  AM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => gE(e, n, r, s);
});
function D4(e, t) {
  return new L4({
    type: "intersection",
    left: e,
    right: t
  });
}
const U4 = /* @__PURE__ */ R("ZodTuple", (e, t) => {
  CM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => _E(e, n, r, s), e.rest = (n) => e.clone({
    ...e._zod.def,
    rest: n
  });
});
function eg(e, t, n) {
  const r = t instanceof Ve, s = r ? n : t, i = r ? t : null;
  return new U4({
    type: "tuple",
    items: e,
    rest: i,
    ...te(s)
  });
}
const F4 = /* @__PURE__ */ R("ZodRecord", (e, t) => {
  $M.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => yE(e, n, r, s), e.keyType = t.keyType, e.valueType = t.valueType;
});
function z4(e, t, n) {
  return new F4({
    type: "record",
    keyType: e,
    valueType: t,
    ...te(n)
  });
}
const vp = /* @__PURE__ */ R("ZodEnum", (e, t) => {
  RM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (r, s, i) => cE(e, r, s), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, s) => {
    const i = {};
    for (const a of r)
      if (n.has(a))
        i[a] = t.entries[a];
      else
        throw new Error(`Key ${a} not found in enum`);
    return new vp({
      ...t,
      checks: [],
      ...te(s),
      entries: i
    });
  }, e.exclude = (r, s) => {
    const i = { ...t.entries };
    for (const a of r)
      if (n.has(a))
        delete i[a];
      else
        throw new Error(`Key ${a} not found in enum`);
    return new vp({
      ...t,
      checks: [],
      ...te(s),
      entries: i
    });
  };
});
function Vl(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new vp({
    type: "enum",
    entries: n,
    ...te(t)
  });
}
const q4 = /* @__PURE__ */ R("ZodLiteral", (e, t) => {
  PM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => lE(e, n, r), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function Ee(e, t) {
  return new q4({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...te(t)
  });
}
const B4 = /* @__PURE__ */ R("ZodTransform", (e, t) => {
  NM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => fE(e, n), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new Cx(e.constructor.name);
    n.addIssue = (i) => {
      if (typeof i == "string")
        n.issues.push(yo(i, n.value, t));
      else {
        const a = i;
        a.fatal && (a.continue = !1), a.code ?? (a.code = "custom"), a.input ?? (a.input = n.value), a.inst ?? (a.inst = e), n.issues.push(yo(a));
      }
    };
    const s = t.transform(n.value, n);
    return s instanceof Promise ? s.then((i) => (n.value = i, n)) : (n.value = s, n);
  };
});
function Z4(e) {
  return new B4({
    type: "transform",
    transform: e
  });
}
const uk = /* @__PURE__ */ R("ZodOptional", (e, t) => {
  Dl.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => zm(e, n, r, s), e.unwrap = () => e._zod.def.innerType;
});
function Kv(e) {
  return new uk({
    type: "optional",
    innerType: e
  });
}
const V4 = /* @__PURE__ */ R("ZodExactOptional", (e, t) => {
  MM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => zm(e, n, r, s), e.unwrap = () => e._zod.def.innerType;
});
function H4(e) {
  return new V4({
    type: "optional",
    innerType: e
  });
}
const G4 = /* @__PURE__ */ R("ZodNullable", (e, t) => {
  jM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => wE(e, n, r, s), e.unwrap = () => e._zod.def.innerType;
});
function Yv(e) {
  return new G4({
    type: "nullable",
    innerType: e
  });
}
const W4 = /* @__PURE__ */ R("ZodDefault", (e, t) => {
  LM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => bE(e, n, r, s), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function J4(e, t) {
  return new W4({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Nx(t);
    }
  });
}
const K4 = /* @__PURE__ */ R("ZodPrefault", (e, t) => {
  DM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => SE(e, n, r, s), e.unwrap = () => e._zod.def.innerType;
});
function Y4(e, t) {
  return new K4({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Nx(t);
    }
  });
}
const ck = /* @__PURE__ */ R("ZodNonOptional", (e, t) => {
  UM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => vE(e, n, r, s), e.unwrap = () => e._zod.def.innerType;
});
function X4(e, t) {
  return new ck({
    type: "nonoptional",
    innerType: e,
    ...te(t)
  });
}
const Q4 = /* @__PURE__ */ R("ZodCatch", (e, t) => {
  FM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => TE(e, n, r, s), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function eU(e, t) {
  return new Q4({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const tU = /* @__PURE__ */ R("ZodPipe", (e, t) => {
  zM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => xE(e, n, r, s), e.in = t.in, e.out = t.out;
});
function Xv(e, t) {
  return new tU({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const nU = /* @__PURE__ */ R("ZodReadonly", (e, t) => {
  qM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => EE(e, n, r, s), e.unwrap = () => e._zod.def.innerType;
});
function rU(e) {
  return new nU({
    type: "readonly",
    innerType: e
  });
}
const lk = /* @__PURE__ */ R("ZodCustom", (e, t) => {
  BM.init(e, t), Ye.init(e, t), e._zod.processJSONSchema = (n, r, s) => dE(e, n);
});
function sU(e, t) {
  return /* @__PURE__ */ P2(lk, (() => !0), t);
}
function iU(e, t = {}) {
  return /* @__PURE__ */ N2(lk, e, t);
}
function aU(e) {
  return /* @__PURE__ */ M2(e);
}
const oU = /* @__PURE__ */ Symbol("Let zodToJsonSchema decide on which parser to use"), Qv = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, uU = (e) => typeof e == "string" ? {
  ...Qv,
  basePath: ["#"],
  definitions: {},
  name: e
} : {
  ...Qv,
  basePath: ["#"],
  definitions: {},
  ...e
}, bp = (e) => "_def" in e ? e._def : e;
function cU(e) {
  if (!e)
    return !0;
  for (const t in e)
    return !1;
  return !0;
}
const lU = (e) => {
  const t = uU(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: n,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(t.definitions).map(([r, s]) => [
      bp(s),
      {
        def: bp(s),
        path: [...t.basePath, t.definitionPath, r],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function dk(e, t, n, r) {
  r?.errorMessages && n && (e.errorMessage = {
    ...e.errorMessage,
    [t]: n
  });
}
function Fe(e, t, n, r, s) {
  e[t] = n, dk(e, t, r, s);
}
function dU() {
  return {};
}
function fU(e, t) {
  const n = {
    type: "array"
  };
  return e.type?._def?.typeName !== $.ZodAny && (n.items = je(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && Fe(n, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && Fe(n, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (Fe(n, "minItems", e.exactLength.value, e.exactLength.message, t), Fe(n, "maxItems", e.exactLength.value, e.exactLength.message, t)), n;
}
function hU(e, t) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks)
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Fe(n, "minimum", r.value, r.message, t) : Fe(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Fe(n, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Fe(n, "maximum", r.value, r.message, t) : Fe(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Fe(n, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Fe(n, "multipleOf", r.value, r.message, t);
        break;
    }
  return n;
}
function pU() {
  return {
    type: "boolean"
  };
}
function mU(e, t) {
  return je(e.type._def, t);
}
const gU = (e, t) => je(e.innerType._def, t);
function fk(e, t, n) {
  const r = n ?? t.dateStrategy;
  if (Array.isArray(r))
    return {
      anyOf: r.map((s, i) => fk(e, t, s))
    };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return _U(e, t);
  }
}
const _U = (e, t) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  if (t.target === "openApi3")
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        Fe(
          n,
          "minimum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
      case "max":
        Fe(
          n,
          "maximum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
    }
  return n;
};
function yU(e, t) {
  return {
    ...je(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function wU(e, t, n) {
  return t.effectStrategy === "input" ? je(e.schema._def, t, n) : {};
}
function vU(e) {
  return {
    type: "string",
    enum: [...e.values]
  };
}
const bU = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function SU(e, t) {
  const n = [
    je(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    je(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let r = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return n.forEach((i) => {
    if (bU(i))
      s.push(...i.allOf), i.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let a = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: o, ...u } = i;
        a = u;
      } else
        r = void 0;
      s.push(a);
    }
  }), s.length ? {
    allOf: s,
    ...r
  } : void 0;
}
function TU(e, t) {
  const n = typeof e.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : t.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [e.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: e.value
  };
}
let oh;
const Qr = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (oh === void 0 && (oh = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), oh),
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function hk(e, t) {
  const n = {
    type: "string"
  };
  function r(s) {
    return t.patternStrategy === "escape" ? xU(s) : s;
  }
  if (e.checks)
    for (const s of e.checks)
      switch (s.kind) {
        case "min":
          Fe(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, s.value) : s.value, s.message, t);
          break;
        case "max":
          Fe(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, s.value) : s.value, s.message, t);
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              xn(n, "email", s.message, t);
              break;
            case "format:idn-email":
              xn(n, "idn-email", s.message, t);
              break;
            case "pattern:zod":
              En(n, Qr.email, s.message, t);
              break;
          }
          break;
        case "url":
          xn(n, "uri", s.message, t);
          break;
        case "uuid":
          xn(n, "uuid", s.message, t);
          break;
        case "regex":
          En(n, s.regex, s.message, t);
          break;
        case "cuid":
          En(n, Qr.cuid, s.message, t);
          break;
        case "cuid2":
          En(n, Qr.cuid2, s.message, t);
          break;
        case "startsWith":
          En(n, RegExp(`^${r(s.value)}`), s.message, t);
          break;
        case "endsWith":
          En(n, RegExp(`${r(s.value)}$`), s.message, t);
          break;
        case "datetime":
          xn(n, "date-time", s.message, t);
          break;
        case "date":
          xn(n, "date", s.message, t);
          break;
        case "time":
          xn(n, "time", s.message, t);
          break;
        case "duration":
          xn(n, "duration", s.message, t);
          break;
        case "length":
          Fe(n, "minLength", typeof n.minLength == "number" ? Math.max(n.minLength, s.value) : s.value, s.message, t), Fe(n, "maxLength", typeof n.maxLength == "number" ? Math.min(n.maxLength, s.value) : s.value, s.message, t);
          break;
        case "includes": {
          En(n, RegExp(r(s.value)), s.message, t);
          break;
        }
        case "ip": {
          s.version !== "v6" && xn(n, "ipv4", s.message, t), s.version !== "v4" && xn(n, "ipv6", s.message, t);
          break;
        }
        case "emoji":
          En(n, Qr.emoji, s.message, t);
          break;
        case "ulid": {
          En(n, Qr.ulid, s.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              xn(n, "binary", s.message, t);
              break;
            }
            case "contentEncoding:base64": {
              Fe(n, "contentEncoding", "base64", s.message, t);
              break;
            }
            case "pattern:zod": {
              En(n, Qr.base64, s.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          En(n, Qr.nanoid, s.message, t);
      }
  return n;
}
const xU = (e) => Array.from(e).map((t) => /[a-zA-Z0-9]/.test(t) ? t : `\\${t}`).join(""), xn = (e, t, n, r) => {
  e.format || e.anyOf?.some((s) => s.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format,
    ...e.errorMessage && r.errorMessages && {
      errorMessage: { format: e.errorMessage.format }
    }
  }), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push({
    format: t,
    ...n && r.errorMessages && { errorMessage: { format: n } }
  })) : Fe(e, "format", t, n, r);
}, En = (e, t, n, r) => {
  e.pattern || e.allOf?.some((s) => s.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern,
    ...e.errorMessage && r.errorMessages && {
      errorMessage: { pattern: e.errorMessage.pattern }
    }
  }), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push({
    pattern: e0(t, r),
    ...n && r.errorMessages && { errorMessage: { pattern: n } }
  })) : Fe(e, "pattern", e0(t, r), n, r);
}, e0 = (e, t) => {
  const n = typeof e == "function" ? e() : e;
  if (!t.applyRegexFlags || !n.flags)
    return n.source;
  const r = {
    i: n.flags.includes("i"),
    // Case-insensitive
    m: n.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: n.flags.includes("s")
    // `.` matches newlines
  }, s = r.i ? n.source.toLowerCase() : n.source;
  let i = "", a = !1, o = !1, u = !1;
  for (let c = 0; c < s.length; c++) {
    if (a) {
      i += s[c], a = !1;
      continue;
    }
    if (r.i) {
      if (o) {
        if (s[c].match(/[a-z]/)) {
          u ? (i += s[c], i += `${s[c - 2]}-${s[c]}`.toUpperCase(), u = !1) : s[c + 1] === "-" && s[c + 2]?.match(/[a-z]/) ? (i += s[c], u = !0) : i += `${s[c]}${s[c].toUpperCase()}`;
          continue;
        }
      } else if (s[c].match(/[a-z]/)) {
        i += `[${s[c]}${s[c].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (s[c] === "^") {
        i += `(^|(?<=[\r
]))`;
        continue;
      } else if (s[c] === "$") {
        i += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && s[c] === ".") {
      i += o ? `${s[c]}\r
` : `[${s[c]}\r
]`;
      continue;
    }
    i += s[c], s[c] === "\\" ? a = !0 : o && s[c] === "]" ? o = !1 : !o && s[c] === "[" && (o = !0);
  }
  try {
    const c = new RegExp(i);
  } catch {
    return console.warn(`Could not convert regex pattern at ${t.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), n.source;
  }
  return i;
};
function pk(e, t) {
  if (t.target === "openApi3" && e.keyType?._def.typeName === $.ZodEnum)
    return {
      type: "object",
      required: e.keyType._def.values,
      properties: e.keyType._def.values.reduce((r, s) => ({
        ...r,
        [s]: je(e.valueType._def, {
          ...t,
          currentPath: [...t.currentPath, "properties", s]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const n = {
    type: "object",
    additionalProperties: je(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (t.target === "openApi3")
    return n;
  if (e.keyType?._def.typeName === $.ZodString && e.keyType._def.checks?.length) {
    const r = Object.entries(hk(e.keyType._def, t)).reduce((s, [i, a]) => i === "type" ? s : { ...s, [i]: a }, {});
    return {
      ...n,
      propertyNames: r
    };
  } else if (e.keyType?._def.typeName === $.ZodEnum)
    return {
      ...n,
      propertyNames: {
        enum: e.keyType._def.values
      }
    };
  return n;
}
function EU(e, t) {
  if (t.mapStrategy === "record")
    return pk(e, t);
  const n = je(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || {}, r = je(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function kU(e) {
  const t = e.values, r = Object.keys(e.values).filter((i) => typeof t[t[i]] != "number").map((i) => t[i]), s = Array.from(new Set(r.map((i) => typeof i)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function OU() {
  return {
    not: {}
  };
}
function IU(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const tl = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function AU(e, t) {
  if (t.target === "openApi3")
    return t0(e, t);
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every((r) => r._def.typeName in tl && (!r._def.checks || !r._def.checks.length))) {
    const r = n.reduce((s, i) => {
      const a = tl[i._def.typeName];
      return a && !s.includes(a) ? [...s, a] : s;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce((s, i) => {
      const a = typeof i._def.value;
      switch (a) {
        case "string":
        case "number":
        case "boolean":
          return [...s, a];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (i._def.value === null)
            return [...s, "null"];
        default:
          return s;
      }
    }, []);
    if (r.length === n.length) {
      const s = r.filter((i, a, o) => o.indexOf(i) === a);
      return {
        type: s.length > 1 ? s : s[0],
        enum: n.reduce((i, a) => i.includes(a._def.value) ? i : [...i, a._def.value], [])
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce((r, s) => [...r, ...s._def.values.filter((i) => !r.includes(i))], [])
    };
  return t0(e, t);
}
const t0 = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map((r, s) => je(r._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", `${s}`]
  })).filter((r) => !!r && (!t.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
  return n.length ? { anyOf: n } : void 0;
};
function CU(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" || t.nullableStrategy === "property" ? {
      type: tl[e.innerType._def.typeName],
      nullable: !0
    } : {
      type: [tl[e.innerType._def.typeName], "null"]
    };
  if (t.target === "openApi3") {
    const r = je(e.innerType._def, {
      ...t,
      currentPath: [...t.currentPath]
    });
    return r && "$ref" in r ? { allOf: [r], nullable: !0 } : r && { ...r, nullable: !0 };
  }
  const n = je(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function $U(e, t) {
  const n = {
    type: "number"
  };
  if (!e.checks)
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "int":
        n.type = "integer", dk(n, "type", r.message, t);
        break;
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Fe(n, "minimum", r.value, r.message, t) : Fe(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Fe(n, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Fe(n, "maximum", r.value, r.message, t) : Fe(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Fe(n, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Fe(n, "multipleOf", r.value, r.message, t);
        break;
    }
  return n;
}
function RU(e, t) {
  return t.removeAdditionalStrategy === "strict" ? e.catchall._def.typeName === "ZodNever" ? e.unknownKeys !== "strict" : je(e.catchall._def, {
    ...t,
    currentPath: [...t.currentPath, "additionalProperties"]
  }) ?? !0 : e.catchall._def.typeName === "ZodNever" ? e.unknownKeys === "passthrough" : je(e.catchall._def, {
    ...t,
    currentPath: [...t.currentPath, "additionalProperties"]
  }) ?? !0;
}
function PU(e, t) {
  const n = {
    type: "object",
    ...Object.entries(e.shape()).reduce((r, [s, i]) => {
      if (i === void 0 || i._def === void 0)
        return r;
      const a = [...t.currentPath, "properties", s], o = je(i._def, {
        ...t,
        currentPath: a,
        propertyPath: a
      });
      if (o === void 0)
        return r;
      if (t.openaiStrictMode && i.isOptional() && !i.isNullable() && typeof i._def?.defaultValue > "u")
        throw new Error(`Zod field at \`${a.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      return {
        properties: {
          ...r.properties,
          [s]: o
        },
        required: i.isOptional() && !t.openaiStrictMode ? r.required : [...r.required, s]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: RU(e, t)
  };
  return n.required.length || delete n.required, n;
}
const NU = (e, t) => {
  if (t.propertyPath && t.currentPath.slice(0, t.propertyPath.length).toString() === t.propertyPath.toString())
    return je(e.innerType._def, { ...t, currentPath: t.currentPath });
  const n = je(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return n ? {
    anyOf: [
      {
        not: {}
      },
      n
    ]
  } : {};
}, MU = (e, t) => {
  if (t.pipeStrategy === "input")
    return je(e.in._def, t);
  if (t.pipeStrategy === "output")
    return je(e.out._def, t);
  const n = je(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), r = je(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, r].filter((s) => s !== void 0)
  };
};
function jU(e, t) {
  return je(e.type._def, t);
}
function LU(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: je(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && Fe(r, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && Fe(r, "maxItems", e.maxSize.value, e.maxSize.message, t), r;
}
function DU(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map((n, r) => je(n._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${r}`]
    })).reduce((n, r) => r === void 0 ? n : [...n, r], []),
    additionalItems: je(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map((n, r) => je(n._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${r}`]
    })).reduce((n, r) => r === void 0 ? n : [...n, r], [])
  };
}
function UU() {
  return {
    not: {}
  };
}
function FU() {
  return {};
}
const zU = (e, t) => je(e.innerType._def, t);
function je(e, t, n = !1) {
  const r = t.seen.get(e);
  if (t.override) {
    const a = t.override?.(e, t, r, n);
    if (a !== oU)
      return a;
  }
  if (r && !n) {
    const a = qU(r, t);
    if (a !== void 0)
      return "$ref" in a && t.seenRefs.add(a.$ref), a;
  }
  const s = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, s);
  const i = ZU(e, e.typeName, t, n);
  return i && VU(e, t, i), s.jsonSchema = i, i;
}
const qU = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
    // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
    // the schema to `#/definitions/` and reference that.
    //
    // e.g. if we need to reference a schema at
    // `["#","definitions","contactPerson","properties","person1","properties","name"]`
    // then we'll extract it out to `contactPerson_properties_person1_properties_name`
    case "extract-to-root":
      const n = e.path.slice(t.basePath.length + 1).join("_");
      return n !== t.name && t.nameStrategy === "duplicate-ref" && (t.definitions[n] = e.def), { $ref: [...t.basePath, t.definitionPath, n].join("/") };
    case "relative":
      return { $ref: BU(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((r, s) => t.currentPath[s] === r) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), {}) : t.$refStrategy === "seen" ? {} : void 0;
  }
}, BU = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, ZU = (e, t, n, r) => {
  switch (t) {
    case $.ZodString:
      return hk(e, n);
    case $.ZodNumber:
      return $U(e, n);
    case $.ZodObject:
      return PU(e, n);
    case $.ZodBigInt:
      return hU(e, n);
    case $.ZodBoolean:
      return pU();
    case $.ZodDate:
      return fk(e, n);
    case $.ZodUndefined:
      return UU();
    case $.ZodNull:
      return IU(n);
    case $.ZodArray:
      return fU(e, n);
    case $.ZodUnion:
    case $.ZodDiscriminatedUnion:
      return AU(e, n);
    case $.ZodIntersection:
      return SU(e, n);
    case $.ZodTuple:
      return DU(e, n);
    case $.ZodRecord:
      return pk(e, n);
    case $.ZodLiteral:
      return TU(e, n);
    case $.ZodEnum:
      return vU(e);
    case $.ZodNativeEnum:
      return kU(e);
    case $.ZodNullable:
      return CU(e, n);
    case $.ZodOptional:
      return NU(e, n);
    case $.ZodMap:
      return EU(e, n);
    case $.ZodSet:
      return LU(e, n);
    case $.ZodLazy:
      return je(e.getter()._def, n);
    case $.ZodPromise:
      return jU(e, n);
    case $.ZodNaN:
    case $.ZodNever:
      return OU();
    case $.ZodEffects:
      return wU(e, n, r);
    case $.ZodAny:
      return dU();
    case $.ZodUnknown:
      return FU();
    case $.ZodDefault:
      return yU(e, n);
    case $.ZodBranded:
      return mU(e, n);
    case $.ZodReadonly:
      return zU(e, n);
    case $.ZodCatch:
      return gU(e, n);
    case $.ZodPipeline:
      return MU(e, n);
    case $.ZodFunction:
    case $.ZodVoid:
    case $.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((s) => {
      })();
  }
}, VU = (e, t, n) => (e.description && (n.description = e.description, t.markdownDescription && (n.markdownDescription = e.description)), n), HU = (e, t) => {
  const n = lU(t), r = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, s = je(e._def, r === void 0 ? n : {
    ...n,
    currentPath: [...n.basePath, n.definitionPath, r]
  }, !1) ?? {}, i = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  i !== void 0 && (s.title = i);
  const a = (() => {
    if (cU(n.definitions))
      return;
    const u = {}, c = /* @__PURE__ */ new Set();
    for (let l = 0; l < 500; l++) {
      const d = Object.entries(n.definitions).filter(([f]) => !c.has(f));
      if (d.length === 0)
        break;
      for (const [f, h] of d)
        u[f] = je(bp(h), { ...n, currentPath: [...n.basePath, n.definitionPath, f] }, !0) ?? {}, c.add(f);
    }
    return u;
  })(), o = r === void 0 ? a ? {
    ...s,
    [n.definitionPath]: a
  } : s : n.nameStrategy === "duplicate-ref" ? {
    ...s,
    ...a || n.seenRefs.size ? {
      [n.definitionPath]: {
        ...a,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...n.seenRefs.size ? { [r]: s } : void 0
      }
    } : void 0
  } : {
    $ref: [...n.$refStrategy === "relative" ? [] : n.basePath, n.definitionPath, r].join("/"),
    [n.definitionPath]: {
      ...a,
      [r]: s
    }
  };
  return n.target === "jsonSchema7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : n.target === "jsonSchema2019-09" && (o.$schema = "https://json-schema.org/draft/2019-09/schema#"), o;
};
function GU(e) {
  if (e.type !== "object")
    throw new Error(`Root schema must have type: 'object' but got type: ${e.type ? `'${e.type}'` : "undefined"}`);
  const t = structuredClone(e);
  return ir(t, [], t);
}
function Sp(e) {
  if (typeof e == "boolean")
    return !1;
  if (e.type === "null")
    return !0;
  for (const t of e.oneOf ?? [])
    if (Sp(t))
      return !0;
  for (const t of e.anyOf ?? [])
    if (Sp(t))
      return !0;
  return !1;
}
function ir(e, t, n) {
  if (typeof e == "boolean")
    throw new TypeError(`Expected object schema but got boolean; path=${t.join("/")}`);
  if (!as(e))
    throw new TypeError(`Expected ${JSON.stringify(e)} to be an object; path=${t.join("/")}`);
  const r = e.$defs;
  if (as(r))
    for (const [f, h] of Object.entries(r))
      ir(h, [...t, "$defs", f], n);
  const s = e.definitions;
  if (as(s))
    for (const [f, h] of Object.entries(s))
      ir(h, [...t, "definitions", f], n);
  e.type === "object" && !("additionalProperties" in e) && (e.additionalProperties = !1);
  const a = e.required ?? [], o = e.properties;
  if (as(o)) {
    for (const [f, h] of Object.entries(o))
      if (!Sp(h) && !a.includes(f))
        throw new Error(`Zod field at \`${[...t, "properties", f].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
    e.required = Object.keys(o), e.properties = Object.fromEntries(Object.entries(o).map(([f, h]) => [
      f,
      ir(h, [...t, "properties", f], n)
    ]));
  }
  const u = e.items;
  as(u) && (e.items = ir(u, [...t, "items"], n));
  const c = e.anyOf;
  Array.isArray(c) && (e.anyOf = c.map((f, h) => ir(f, [...t, "anyOf", String(h)], n)));
  const l = e.allOf;
  if (Array.isArray(l))
    if (l.length === 1) {
      const f = ir(l[0], [...t, "allOf", "0"], n);
      Object.assign(e, f), delete e.allOf;
    } else
      e.allOf = l.map((f, h) => ir(f, [...t, "allOf", String(h)], n));
  e.default === null && delete e.default;
  const d = e.$ref;
  if (d && JU(e, 1)) {
    if (typeof d != "string")
      throw new TypeError(`Received non-string $ref - ${d}; path=${t.join("/")}`);
    const f = WU(n, d);
    if (typeof f == "boolean")
      throw new Error(`Expected \`$ref: ${d}\` to resolve to an object schema but got boolean`);
    if (!as(f))
      throw new Error(`Expected \`$ref: ${d}\` to resolve to an object but got ${JSON.stringify(f)}`);
    return Object.assign(e, { ...f, ...e }), delete e.$ref, ir(e, t, n);
  }
  return e;
}
function WU(e, t) {
  if (!t.startsWith("#/"))
    throw new Error(`Unexpected $ref format ${JSON.stringify(t)}; Does not start with #/`);
  const n = t.slice(2).split("/");
  let r = e;
  for (const s of n) {
    if (!as(r))
      throw new Error(`encountered non-object entry while resolving ${t} - ${JSON.stringify(r)}`);
    const i = r[s];
    if (i === void 0)
      throw new Error(`Key ${s} not found while resolving ${t}`);
    r = i;
  }
  return r;
}
function as(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
function JU(e, t) {
  let n = 0;
  for (const r in e)
    if (n++, n > t)
      return !0;
  return !1;
}
function KU(e, t) {
  return HU(e, {
    openaiStrictMode: !0,
    name: t.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function YU(e) {
  return GU(ip(e, {
    target: "draft-7"
  }));
}
function XU(e) {
  return "_zod" in e;
}
function QU(e, t, n) {
  return b1({
    type: "json_schema",
    json_schema: {
      ...n,
      name: t,
      strict: !0,
      schema: XU(e) ? YU(e) : KU(e, { name: t })
    }
  }, (r) => e.parse(JSON.parse(r)));
}
const n0 = [
  "jsonSchema",
  "functionCalling",
  "jsonMode"
];
function eF(e, t) {
  if (typeof t < "u" && !n0.includes(t)) throw new Error(`Invalid method: ${t}. Supported methods are: ${n0.join(", ")}`);
  const n = !e.startsWith("gpt-3") && !e.startsWith("gpt-4-") && e !== "gpt-4";
  if (n && !t) return "jsonSchema";
  if (!n && t === "jsonSchema") throw new Error(`JSON Schema is not supported for model "${e}". Please use a different method, e.g. "functionCalling" or "jsonMode".`);
  return t ?? "functionCalling";
}
function tF(e, t) {
  const n = { ...e };
  return Object.defineProperties(n, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: !1
    },
    $parseRaw: {
      value: t,
      enumerable: !1
    }
  }), n;
}
function nF(e, t, n) {
  if (ot(e)) return QU(e, t, n);
  if (Ke(e)) return tF({
    type: "json_schema",
    json_schema: {
      ...n,
      name: t,
      strict: !0,
      schema: it(e, {
        cycles: "ref",
        reused: "ref",
        override(r) {
          r.jsonSchema.title = t;
        }
      })
    }
  }, (r) => Pl(e, JSON.parse(r)));
  throw new Error("Unsupported schema response format");
}
function rF(e, t) {
  if (t && typeof t == "object" && "images" in t && Array.isArray(t.images)) {
    const n = t.images.filter((r) => typeof r?.image_url?.url == "string").map((r) => ({
      type: "image",
      url: r.image_url.url
    }));
    return [{
      type: "text",
      text: e
    }, ...n];
  }
  return e;
}
const sF = {
  "gpt-4.1-nano": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-3-small": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-05-13": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-08-06": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1-mini": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-3.5-turbo": {
    maxInputTokens: 16385,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1,
    imageUrlInputs: !1,
    pdfToolMessage: !1,
    imageToolMessage: !1,
    toolChoice: !0
  },
  "text-embedding-3-large": {
    maxInputTokens: 8191,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 3072,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4-turbo": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-preview": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-mini": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "codex-mini-latest": {
    maxInputTokens: 2e5,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-nano": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-codex": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4.1": {
    maxInputTokens: 1047576,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o1: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-mini": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o1-mini": {
    maxInputTokens: 128e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "text-embedding-ada-002": {
    maxInputTokens: 8192,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1536,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o3-pro": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-2024-11-20": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  o3: {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "o4-mini-deep-research": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 1e5,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-chat-latest": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-4o-mini": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 16384,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 128e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  },
  "gpt-5-pro": {
    maxInputTokens: 4e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 272e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0,
    toolChoice: !0
  }
};
var iF = sF, aF = {};
$e(aF, {
  BasePromptValue: () => Hl,
  ChatPromptValue: () => gk,
  ImagePromptValue: () => oF,
  StringPromptValue: () => mk
});
var Hl = class extends ri {
}, mk = class extends Hl {
  static lc_name() {
    return "StringPromptValue";
  }
  lc_namespace = ["langchain_core", "prompt_values"];
  lc_serializable = !0;
  value;
  constructor(e) {
    super({ value: e }), this.value = e;
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new Zt(this.value)];
  }
}, gk = class extends Hl {
  lc_namespace = ["langchain_core", "prompt_values"];
  lc_serializable = !0;
  static lc_name() {
    return "ChatPromptValue";
  }
  messages;
  constructor(e) {
    Array.isArray(e) && (e = { messages: e }), super(e), this.messages = e.messages;
  }
  toString() {
    return wm(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
}, oF = class extends Hl {
  lc_namespace = ["langchain_core", "prompt_values"];
  lc_serializable = !0;
  static lc_name() {
    return "ImagePromptValue";
  }
  imageUrl;
  /** @ignore */
  value;
  constructor(e) {
    "imageUrl" in e || (e = { imageUrl: e }), super(e), this.imageUrl = e.imageUrl;
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [new Zt({ content: [{
      type: "image_url",
      image_url: {
        detail: this.imageUrl.detail,
        url: this.imageUrl.url
      }
    }] })];
  }
}, Y = "0123456789abcdef".split(""), uF = [
  -2147483648,
  8388608,
  32768,
  128
], kn = [
  24,
  16,
  8,
  0
], Au = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], pt = [];
function Ln(e, t) {
  t ? (pt[0] = pt[16] = pt[1] = pt[2] = pt[3] = pt[4] = pt[5] = pt[6] = pt[7] = pt[8] = pt[9] = pt[10] = pt[11] = pt[12] = pt[13] = pt[14] = pt[15] = 0, this.blocks = pt) : this.blocks = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], e ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = e;
}
Ln.prototype.update = function(e) {
  if (!this.finalized) {
    var t, n = typeof e;
    if (n !== "string") {
      if (n === "object") {
        if (e === null) throw new Error(ERROR);
        if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
        else if (!Array.isArray(e) && (!ARRAY_BUFFER || !ArrayBuffer.isView(e)))
          throw new Error(ERROR);
      } else throw new Error(ERROR);
      t = !0;
    }
    for (var r, s = 0, i, a = e.length, o = this.blocks; s < a; ) {
      if (this.hashed && (this.hashed = !1, o[0] = this.block, this.block = o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), t) for (i = this.start; s < a && i < 64; ++s) o[i >>> 2] |= e[s] << kn[i++ & 3];
      else for (i = this.start; s < a && i < 64; ++s)
        r = e.charCodeAt(s), r < 128 ? o[i >>> 2] |= r << kn[i++ & 3] : r < 2048 ? (o[i >>> 2] |= (192 | r >>> 6) << kn[i++ & 3], o[i >>> 2] |= (128 | r & 63) << kn[i++ & 3]) : r < 55296 || r >= 57344 ? (o[i >>> 2] |= (224 | r >>> 12) << kn[i++ & 3], o[i >>> 2] |= (128 | r >>> 6 & 63) << kn[i++ & 3], o[i >>> 2] |= (128 | r & 63) << kn[i++ & 3]) : (r = 65536 + ((r & 1023) << 10 | e.charCodeAt(++s) & 1023), o[i >>> 2] |= (240 | r >>> 18) << kn[i++ & 3], o[i >>> 2] |= (128 | r >>> 12 & 63) << kn[i++ & 3], o[i >>> 2] |= (128 | r >>> 6 & 63) << kn[i++ & 3], o[i >>> 2] |= (128 | r & 63) << kn[i++ & 3]);
      this.lastByteIndex = i, this.bytes += i - this.start, i >= 64 ? (this.block = o[16], this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i;
    }
    return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
  }
};
Ln.prototype.finalize = function() {
  if (!this.finalized) {
    this.finalized = !0;
    var e = this.blocks, t = this.lastByteIndex;
    e[16] = this.block, e[t >>> 2] |= uF[t & 3], this.block = e[16], t >= 56 && (this.hashed || this.hash(), e[0] = this.block, e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.hBytes << 3 | this.bytes >>> 29, e[15] = this.bytes << 3, this.hash();
  }
};
Ln.prototype.hash = function() {
  var e = this.h0, t = this.h1, n = this.h2, r = this.h3, s = this.h4, i = this.h5, a = this.h6, o = this.h7, u = this.blocks, c, l, d, f, h, p, g, m, _, y, b;
  for (c = 16; c < 64; ++c)
    h = u[c - 15], l = (h >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, h = u[c - 2], d = (h >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10, u[c] = u[c - 16] + l + u[c - 7] + d << 0;
  for (b = t & n, c = 0; c < 64; c += 4)
    this.first ? (this.is224 ? (m = 300032, h = u[0] - 1413257819, o = h - 150054599 << 0, r = h + 24177077 << 0) : (m = 704751109, h = u[0] - 210244248, o = h - 1521486534 << 0, r = h + 143694565 << 0), this.first = !1) : (l = (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10), d = (s >>> 6 | s << 26) ^ (s >>> 11 | s << 21) ^ (s >>> 25 | s << 7), m = e & t, f = m ^ e & n ^ b, g = s & i ^ ~s & a, h = o + d + g + Au[c] + u[c], p = l + f, o = r + h << 0, r = h + p << 0), l = (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10), d = (o >>> 6 | o << 26) ^ (o >>> 11 | o << 21) ^ (o >>> 25 | o << 7), _ = r & e, f = _ ^ r & t ^ m, g = a & o ^ ~a & s, h = i + d + g + Au[c + 1] + u[c + 1], p = l + f, a = n + h << 0, n = h + p << 0, l = (n >>> 2 | n << 30) ^ (n >>> 13 | n << 19) ^ (n >>> 22 | n << 10), d = (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7), y = n & r, f = y ^ n & e ^ _, g = i & a ^ ~i & o, h = s + d + g + Au[c + 2] + u[c + 2], p = l + f, i = t + h << 0, t = h + p << 0, l = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), d = (i >>> 6 | i << 26) ^ (i >>> 11 | i << 21) ^ (i >>> 25 | i << 7), b = t & n, f = b ^ t & r ^ y, g = i & a ^ ~i & o, h = s + d + g + Au[c + 3] + u[c + 3], p = l + f, s = e + h << 0, e = h + p << 0, this.chromeBugWorkAround = !0;
  this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + r << 0, this.h4 = this.h4 + s << 0, this.h5 = this.h5 + i << 0, this.h6 = this.h6 + a << 0, this.h7 = this.h7 + o << 0;
};
Ln.prototype.hex = function() {
  this.finalize();
  var e = this.h0, t = this.h1, n = this.h2, r = this.h3, s = this.h4, i = this.h5, a = this.h6, o = this.h7, u = Y[e >>> 28 & 15] + Y[e >>> 24 & 15] + Y[e >>> 20 & 15] + Y[e >>> 16 & 15] + Y[e >>> 12 & 15] + Y[e >>> 8 & 15] + Y[e >>> 4 & 15] + Y[e & 15] + Y[t >>> 28 & 15] + Y[t >>> 24 & 15] + Y[t >>> 20 & 15] + Y[t >>> 16 & 15] + Y[t >>> 12 & 15] + Y[t >>> 8 & 15] + Y[t >>> 4 & 15] + Y[t & 15] + Y[n >>> 28 & 15] + Y[n >>> 24 & 15] + Y[n >>> 20 & 15] + Y[n >>> 16 & 15] + Y[n >>> 12 & 15] + Y[n >>> 8 & 15] + Y[n >>> 4 & 15] + Y[n & 15] + Y[r >>> 28 & 15] + Y[r >>> 24 & 15] + Y[r >>> 20 & 15] + Y[r >>> 16 & 15] + Y[r >>> 12 & 15] + Y[r >>> 8 & 15] + Y[r >>> 4 & 15] + Y[r & 15] + Y[s >>> 28 & 15] + Y[s >>> 24 & 15] + Y[s >>> 20 & 15] + Y[s >>> 16 & 15] + Y[s >>> 12 & 15] + Y[s >>> 8 & 15] + Y[s >>> 4 & 15] + Y[s & 15] + Y[i >>> 28 & 15] + Y[i >>> 24 & 15] + Y[i >>> 20 & 15] + Y[i >>> 16 & 15] + Y[i >>> 12 & 15] + Y[i >>> 8 & 15] + Y[i >>> 4 & 15] + Y[i & 15] + Y[a >>> 28 & 15] + Y[a >>> 24 & 15] + Y[a >>> 20 & 15] + Y[a >>> 16 & 15] + Y[a >>> 12 & 15] + Y[a >>> 8 & 15] + Y[a >>> 4 & 15] + Y[a & 15];
  return this.is224 || (u += Y[o >>> 28 & 15] + Y[o >>> 24 & 15] + Y[o >>> 20 & 15] + Y[o >>> 16 & 15] + Y[o >>> 12 & 15] + Y[o >>> 8 & 15] + Y[o >>> 4 & 15] + Y[o & 15]), u;
};
Ln.prototype.toString = Ln.prototype.hex;
Ln.prototype.digest = function() {
  this.finalize();
  var e = this.h0, t = this.h1, n = this.h2, r = this.h3, s = this.h4, i = this.h5, a = this.h6, o = this.h7, u = [
    e >>> 24 & 255,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    t >>> 24 & 255,
    t >>> 16 & 255,
    t >>> 8 & 255,
    t & 255,
    n >>> 24 & 255,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255,
    r >>> 24 & 255,
    r >>> 16 & 255,
    r >>> 8 & 255,
    r & 255,
    s >>> 24 & 255,
    s >>> 16 & 255,
    s >>> 8 & 255,
    s & 255,
    i >>> 24 & 255,
    i >>> 16 & 255,
    i >>> 8 & 255,
    i & 255,
    a >>> 24 & 255,
    a >>> 16 & 255,
    a >>> 8 & 255,
    a & 255
  ];
  return this.is224 || u.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, o & 255), u;
};
Ln.prototype.array = Ln.prototype.digest;
Ln.prototype.arrayBuffer = function() {
  this.finalize();
  var e = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32), t = new DataView(e);
  return t.setUint32(0, this.h0), t.setUint32(4, this.h1), t.setUint32(8, this.h2), t.setUint32(12, this.h3), t.setUint32(16, this.h4), t.setUint32(20, this.h5), t.setUint32(24, this.h6), this.is224 || t.setUint32(28, this.h7), e;
};
const _k = (...e) => new Ln(!1, !0).update(e.join("")).hex();
var cF = {};
$e(cF, { sha256: () => _k });
var lF = {};
$e(lF, {
  BaseCache: () => wk,
  InMemoryCache: () => vk,
  defaultHashKeyEncoder: () => yk,
  deserializeStoredGeneration: () => dF,
  serializeGeneration: () => fF
});
const yk = (...e) => _k(e.join("_"));
function dF(e) {
  return e.message !== void 0 ? {
    text: e.text,
    message: vm(e.message)
  } : { text: e.text };
}
function fF(e) {
  const t = { text: e.text };
  return e.message !== void 0 && (t.message = e.message.toDict()), t;
}
var wk = class {
  keyEncoder = yk;
  /**
  * Sets a custom key encoder function for the cache.
  * This function should take a prompt and an LLM key and return a string
  * that will be used as the cache key.
  * @param keyEncoderFn The custom key encoder function.
  */
  makeDefaultKeyEncoder(e) {
    this.keyEncoder = e;
  }
};
const hF = /* @__PURE__ */ new Map();
var vk = class bk extends wk {
  cache;
  constructor(t) {
    super(), this.cache = t ?? /* @__PURE__ */ new Map();
  }
  /**
  * Retrieves data from the cache using a prompt and an LLM key. If the
  * data is not found, it returns null.
  * @param prompt The prompt used to find the data.
  * @param llmKey The LLM key used to find the data.
  * @returns The data corresponding to the prompt and LLM key, or null if not found.
  */
  lookup(t, n) {
    return Promise.resolve(this.cache.get(this.keyEncoder(t, n)) ?? null);
  }
  /**
  * Updates the cache with new data using a prompt and an LLM key.
  * @param prompt The prompt used to store the data.
  * @param llmKey The LLM key used to store the data.
  * @param value The data to be stored.
  */
  async update(t, n, r) {
    this.cache.set(this.keyEncoder(t, n), r);
  }
  /**
  * Returns a global instance of InMemoryCache using a predefined global
  * map as the initial cache.
  * @returns A global instance of InMemoryCache.
  */
  static global() {
    return new bk(hF);
  }
}, ta = {}, r0;
function pF() {
  if (r0) return ta;
  r0 = 1, ta.byteLength = o, ta.toByteArray = c, ta.fromByteArray = f;
  for (var e = [], t = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, i = r.length; s < i; ++s)
    e[s] = r[s], t[r.charCodeAt(s)] = s;
  t[45] = 62, t[95] = 63;
  function a(h) {
    var p = h.length;
    if (p % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var g = h.indexOf("=");
    g === -1 && (g = p);
    var m = g === p ? 0 : 4 - g % 4;
    return [g, m];
  }
  function o(h) {
    var p = a(h), g = p[0], m = p[1];
    return (g + m) * 3 / 4 - m;
  }
  function u(h, p, g) {
    return (p + g) * 3 / 4 - g;
  }
  function c(h) {
    var p, g = a(h), m = g[0], _ = g[1], y = new n(u(h, m, _)), b = 0, T = _ > 0 ? m - 4 : m, x;
    for (x = 0; x < T; x += 4)
      p = t[h.charCodeAt(x)] << 18 | t[h.charCodeAt(x + 1)] << 12 | t[h.charCodeAt(x + 2)] << 6 | t[h.charCodeAt(x + 3)], y[b++] = p >> 16 & 255, y[b++] = p >> 8 & 255, y[b++] = p & 255;
    return _ === 2 && (p = t[h.charCodeAt(x)] << 2 | t[h.charCodeAt(x + 1)] >> 4, y[b++] = p & 255), _ === 1 && (p = t[h.charCodeAt(x)] << 10 | t[h.charCodeAt(x + 1)] << 4 | t[h.charCodeAt(x + 2)] >> 2, y[b++] = p >> 8 & 255, y[b++] = p & 255), y;
  }
  function l(h) {
    return e[h >> 18 & 63] + e[h >> 12 & 63] + e[h >> 6 & 63] + e[h & 63];
  }
  function d(h, p, g) {
    for (var m, _ = [], y = p; y < g; y += 3)
      m = (h[y] << 16 & 16711680) + (h[y + 1] << 8 & 65280) + (h[y + 2] & 255), _.push(l(m));
    return _.join("");
  }
  function f(h) {
    for (var p, g = h.length, m = g % 3, _ = [], y = 16383, b = 0, T = g - m; b < T; b += y)
      _.push(d(h, b, b + y > T ? T : b + y));
    return m === 1 ? (p = h[g - 1], _.push(
      e[p >> 2] + e[p << 4 & 63] + "=="
    )) : m === 2 && (p = (h[g - 2] << 8) + h[g - 1], _.push(
      e[p >> 10] + e[p >> 4 & 63] + e[p << 2 & 63] + "="
    )), _.join("");
  }
  return ta;
}
var mF = pF();
const gF = /* @__PURE__ */ Zr(mF);
var _F = Object.defineProperty, yF = (e, t, n) => t in e ? _F(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, wF = (e, t, n) => (yF(e, t + "", n), n);
function vF(e, t) {
  let n = Array.from(
    { length: e.length },
    (r, s) => ({ start: s, end: s + 1 })
  );
  for (; n.length > 1; ) {
    let r = null;
    for (let s = 0; s < n.length - 1; s++) {
      const i = e.slice(n[s].start, n[s + 1].end), a = t.get(i.join(","));
      a != null && (r == null || a < r[0]) && (r = [a, s]);
    }
    if (r != null) {
      const s = r[1];
      n[s] = { start: n[s].start, end: n[s + 1].end }, n.splice(s + 1, 1);
    } else
      break;
  }
  return n;
}
function bF(e, t) {
  return e.length === 1 ? [t.get(e.join(","))] : vF(e, t).map((n) => t.get(e.slice(n.start, n.end).join(","))).filter((n) => n != null);
}
function SF(e) {
  return e.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Tp = class {
  /** @internal */
  specialTokens;
  /** @internal */
  inverseSpecialTokens;
  /** @internal */
  patStr;
  /** @internal */
  textEncoder = new TextEncoder();
  /** @internal */
  textDecoder = new TextDecoder("utf-8");
  /** @internal */
  rankMap = /* @__PURE__ */ new Map();
  /** @internal */
  textMap = /* @__PURE__ */ new Map();
  constructor(e, t) {
    this.patStr = e.pat_str;
    const n = e.bpe_ranks.split(`
`).filter(Boolean).reduce((r, s) => {
      const [i, a, ...o] = s.split(" "), u = Number.parseInt(a, 10);
      return o.forEach((c, l) => r[c] = u + l), r;
    }, {});
    for (const [r, s] of Object.entries(n)) {
      const i = gF.toByteArray(r);
      this.rankMap.set(i.join(","), s), this.textMap.set(s, i);
    }
    this.specialTokens = { ...e.special_tokens, ...t }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((r, [s, i]) => (r[i] = this.textEncoder.encode(s), r), {});
  }
  encode(e, t = [], n = "all") {
    const r = new RegExp(this.patStr, "ug"), s = Tp.specialTokenRegex(
      Object.keys(this.specialTokens)
    ), i = [], a = new Set(
      t === "all" ? Object.keys(this.specialTokens) : t
    ), o = new Set(
      n === "all" ? Object.keys(this.specialTokens).filter(
        (c) => !a.has(c)
      ) : n
    );
    if (o.size > 0) {
      const c = Tp.specialTokenRegex([
        ...o
      ]), l = e.match(c);
      if (l != null)
        throw new Error(
          `The text contains a special token that is not allowed: ${l[0]}`
        );
    }
    let u = 0;
    for (; ; ) {
      let c = null, l = u;
      for (; s.lastIndex = l, c = s.exec(e), !(c == null || a.has(c[0])); )
        l = c.index + 1;
      const d = c?.index ?? e.length;
      for (const h of e.substring(u, d).matchAll(r)) {
        const p = this.textEncoder.encode(h[0]), g = this.rankMap.get(p.join(","));
        if (g != null) {
          i.push(g);
          continue;
        }
        i.push(...bF(p, this.rankMap));
      }
      if (c == null)
        break;
      let f = this.specialTokens[c[0]];
      i.push(f), u = c.index + c[0].length;
    }
    return i;
  }
  decode(e) {
    const t = [];
    let n = 0;
    for (let i = 0; i < e.length; ++i) {
      const a = e[i], o = this.textMap.get(a) ?? this.inverseSpecialTokens[a];
      o != null && (t.push(o), n += o.length);
    }
    const r = new Uint8Array(n);
    let s = 0;
    for (const i of t)
      r.set(i, s), s += i.length;
    return this.textDecoder.decode(r);
  }
}, Sk = Tp;
wF(Sk, "specialTokenRegex", (e) => new RegExp(e.map((t) => SF(t)).join("|"), "g"));
function TF(e) {
  switch (e) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest":
      return "o200k_base";
    default:
      throw new Error("Unknown model");
  }
}
var xF = {};
$e(xF, {
  encodingForModel: () => tg,
  getEncoding: () => Tk
});
const Cu = {}, EF = /* @__PURE__ */ new Uo({});
async function Tk(e) {
  return e in Cu || (Cu[e] = EF.fetch(`https://tiktoken.pages.dev/js/${e}.json`).then((t) => t.json()).then((t) => new Sk(t)).catch((t) => {
    throw delete Cu[e], t;
  })), await Cu[e];
}
async function tg(e) {
  return Tk(TF(e));
}
var kF = {};
$e(kF, {
  BaseLangChain: () => ng,
  BaseLanguageModel: () => rg,
  calculateMaxTokens: () => IF,
  getEmbeddingContextSize: () => OF,
  getModelContextSize: () => xk,
  getModelNameForTiktoken: () => Gl,
  isOpenAITool: () => vi
});
const Gl = (e) => e.startsWith("gpt-5") ? "gpt-5" : e.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : e.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : e.startsWith("gpt-4-32k") ? "gpt-4-32k" : e.startsWith("gpt-4-") ? "gpt-4" : e.startsWith("gpt-4o") ? "gpt-4o" : e, OF = (e) => e === "text-embedding-ada-002" ? 8191 : 2046, xk = (e) => {
  switch (Gl(e)) {
    case "gpt-5":
    case "gpt-5-turbo":
    case "gpt-5-turbo-preview":
      return 4e5;
    case "gpt-4o":
    case "gpt-4o-mini":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
      return 128e3;
    case "gpt-4-turbo":
    case "gpt-4-turbo-preview":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-0125-preview":
    case "gpt-4-1106-preview":
      return 128e3;
    case "gpt-4-32k":
    case "gpt-4-32k-0314":
    case "gpt-4-32k-0613":
      return 32768;
    case "gpt-4":
    case "gpt-4-0314":
    case "gpt-4-0613":
      return 8192;
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-16k-0613":
      return 16384;
    case "gpt-3.5-turbo":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-1106":
    case "gpt-3.5-turbo-0125":
      return 4096;
    case "text-davinci-003":
    case "text-davinci-002":
      return 4097;
    case "text-davinci-001":
      return 2049;
    case "text-curie-001":
    case "text-babbage-001":
    case "text-ada-001":
      return 2048;
    case "code-davinci-002":
    case "code-davinci-001":
      return 8e3;
    case "code-cushman-001":
      return 2048;
    case "claude-3-5-sonnet-20241022":
    case "claude-3-5-sonnet-20240620":
    case "claude-3-opus-20240229":
    case "claude-3-sonnet-20240229":
    case "claude-3-haiku-20240307":
    case "claude-2.1":
      return 2e5;
    case "claude-2.0":
    case "claude-instant-1.2":
      return 1e5;
    case "gemini-1.5-pro":
    case "gemini-1.5-pro-latest":
    case "gemini-1.5-flash":
    case "gemini-1.5-flash-latest":
      return 1e6;
    case "gemini-pro":
    case "gemini-pro-vision":
      return 32768;
    default:
      return 4097;
  }
};
function vi(e) {
  return typeof e != "object" || !e ? !1 : !!("type" in e && e.type === "function" && "function" in e && typeof e.function == "object" && e.function && "name" in e.function && "parameters" in e.function);
}
const IF = async ({ prompt: e, modelName: t }) => {
  let n;
  try {
    n = (await tg(Gl(t))).encode(e).length;
  } catch {
    console.warn("Failed to calculate number of tokens, falling back to approximate count"), n = Math.ceil(e.length / 4);
  }
  return xk(t) - n;
}, AF = () => !1;
var ng = class extends nt {
  /**
  * Whether to print out response text.
  */
  verbose;
  callbacks;
  tags;
  metadata;
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
  constructor(e) {
    super(e), this.verbose = e.verbose ?? AF(), this.callbacks = e.callbacks, this.tags = e.tags ?? [], this.metadata = e.metadata ?? {};
  }
}, rg = class extends ng {
  /**
  * Keys that the language model accepts as call options.
  */
  get callKeys() {
    return [
      "stop",
      "timeout",
      "signal",
      "tags",
      "metadata",
      "callbacks"
    ];
  }
  /**
  * The async caller should be used by subclasses to make any async calls,
  * which will thus benefit from the concurrency and retry logic.
  */
  caller;
  cache;
  constructor({ callbacks: e, callbackManager: t, ...n }) {
    const { cache: r, ...s } = n;
    super({
      callbacks: e ?? t,
      ...s
    }), typeof r == "object" ? this.cache = r : r ? this.cache = vk.global() : this.cache = void 0, this.caller = new Uo(n ?? {});
  }
  _encoding;
  /**
  * Get the number of tokens in the content.
  * @param content The content to get the number of tokens for.
  * @returns The number of tokens in the content.
  */
  async getNumTokens(e) {
    let t;
    typeof e == "string" ? t = e : t = e.map((r) => typeof r == "string" ? r : r.type === "text" && "text" in r ? r.text : "").join("");
    let n = Math.ceil(t.length / 4);
    if (!this._encoding) try {
      this._encoding = await tg("modelName" in this ? Gl(this.modelName) : "gpt2");
    } catch (r) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", r);
    }
    if (this._encoding) try {
      n = this._encoding.encode(t).length;
    } catch (r) {
      console.warn("Failed to calculate number of tokens, falling back to approximate count", r);
    }
    return n;
  }
  static _convertInputToPromptValue(e) {
    return typeof e == "string" ? new mk(e) : Array.isArray(e) ? new gk(e.map(no)) : e;
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  /**
  * Create a unique cache key for a specific call to a specific language model.
  * @param callOptions Call options for the model
  * @returns A unique cache key.
  */
  _getSerializedCacheKeyParametersForCall({ config: e, ...t }) {
    const n = {
      ...this._identifyingParams(),
      ...t,
      _type: this._llmType(),
      _model: this._modelType()
    };
    return Object.entries(n).filter(([i, a]) => a !== void 0).map(([i, a]) => `${i}:${JSON.stringify(a)}`).sort().join(",");
  }
  /**
  * @deprecated
  * Return a json-like object representing this LLM.
  */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
  * @deprecated
  * Load an LLM from a json-like object describing it.
  */
  static async deserialize(e) {
    throw new Error("Use .toJSON() instead");
  }
  /**
  * Return profiling information for the model.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  */
  get profile() {
    return {};
  }
}, _n = class extends nt {
  static lc_name() {
    return "RunnablePassthrough";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  func;
  constructor(e) {
    super(e), e && (this.func = e.func);
  }
  async invoke(e, t) {
    const n = Ne(t);
    return this.func && await this.func(e, n), this._callWithConfig((r) => Promise.resolve(r), e, n);
  }
  async *transform(e, t) {
    const n = Ne(t);
    let r, s = !0;
    for await (const i of this._transformStreamWithConfig(e, (a) => a, n))
      if (yield i, s) if (r === void 0) r = i;
      else try {
        r = hr(r, i);
      } catch {
        r = void 0, s = !1;
      }
    this.func && r !== void 0 && await this.func(r, n);
  }
  /**
  * A runnable that assigns key-value pairs to the input.
  *
  * The example below shows how you could use it with an inline function.
  *
  * @example
  * ```typescript
  * const prompt =
  *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
  * Question: {question}
  * SQL Query:`);
  *
  * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
  * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
  * // In this case, we're passing the schema.
  * const sqlQueryGeneratorChain = RunnableSequence.from([
  *   RunnablePassthrough.assign({
  *     schema: async () => db.getTableInfo(),
  *   }),
  *   prompt,
  *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
  *   new StringOutputParser(),
  * ]);
  * const result = await sqlQueryGeneratorChain.invoke({
  *   question: "How many employees are there?",
  * });
  * ```
  */
  static assign(e) {
    return new Wm(new wi({ steps: e }));
  }
};
const CF = (e) => e();
function uh(e) {
  const t = e.constructor;
  return new t({
    ...e,
    content: e.contentBlocks,
    response_metadata: {
      ...e.response_metadata,
      output_version: "v1"
    }
  });
}
var $F = {};
$e($F, {
  BaseChatModel: () => bi,
  SimpleChatModel: () => RF
});
function ch(e) {
  const t = [];
  for (const n of e) {
    let r = n;
    if (Array.isArray(n.content)) for (let s = 0; s < n.content.length; s++) {
      const i = n.content[s];
      (um(i) || cm(i)) && r === n && (r = new n.constructor({
        ...r,
        content: [
          ...n.content.slice(0, s),
          mT(i),
          ...n.content.slice(s + 1)
        ]
      }));
    }
    t.push(r);
  }
  return t;
}
var bi = class os extends rg {
  lc_namespace = [
    "langchain",
    "chat_models",
    this._llmType()
  ];
  disableStreaming = !1;
  outputVersion;
  get callKeys() {
    return [...super.callKeys, "outputVersion"];
  }
  constructor(t) {
    super(t), this.outputVersion = CF(() => {
      const n = t.outputVersion ?? on("LC_OUTPUT_VERSION");
      return n && ["v0", "v1"].includes(n) ? n : "v0";
    });
  }
  _separateRunnableConfigFromCallOptionsCompat(t) {
    const [n, r] = super._separateRunnableConfigFromCallOptions(t);
    return r.signal = n.signal, [n, r];
  }
  /**
  * Invokes the chat model with a single input.
  * @param input The input for the language model.
  * @param options The call options.
  * @returns A Promise that resolves to a BaseMessageChunk.
  */
  async invoke(t, n) {
    const r = os._convertInputToPromptValue(t);
    return (await this.generatePrompt([r], n, n?.callbacks)).generations[0][0].message;
  }
  async *_streamResponseChunks(t, n, r) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(t, n) {
    if (this._streamResponseChunks === os.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(t, n);
    else {
      const s = os._convertInputToPromptValue(t).toChatMessages(), [i, a] = this._separateRunnableConfigFromCallOptionsCompat(n), o = {
        ...i.metadata,
        ...this.getLsParams(a)
      }, u = await Vt.configure(i.callbacks, this.callbacks, i.tags, this.tags, o, this.metadata, { verbose: this.verbose }), c = {
        options: a,
        invocation_params: this?.invocationParams(a),
        batch_size: 1
      }, l = a.outputVersion ?? this.outputVersion, d = await u?.handleChatModelStart(this.toJSON(), [ch(s)], i.runId, void 0, c, void 0, void 0, i.runName);
      let f, h;
      try {
        for await (const p of this._streamResponseChunks(s, a, d?.[0])) {
          if (p.message.id == null) {
            const g = d?.at(0)?.runId;
            g != null && p.message._updateId(`run-${g}`);
          }
          p.message.response_metadata = {
            ...p.generationInfo,
            ...p.message.response_metadata
          }, l === "v1" ? yield uh(p.message) : yield p.message, f ? f = f.concat(p) : f = p, Zh(p.message) && p.message.usage_metadata !== void 0 && (h = { tokenUsage: {
            promptTokens: p.message.usage_metadata.input_tokens,
            completionTokens: p.message.usage_metadata.output_tokens,
            totalTokens: p.message.usage_metadata.total_tokens
          } });
        }
      } catch (p) {
        throw await Promise.all((d ?? []).map((g) => g?.handleLLMError(p))), p;
      }
      await Promise.all((d ?? []).map((p) => p?.handleLLMEnd({
        generations: [[f]],
        llmOutput: h
      })));
    }
  }
  getLsParams(t) {
    const n = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: t.stop,
      ls_provider: n
    };
  }
  /** @ignore */
  async _generateUncached(t, n, r, s) {
    const i = t.map((f) => f.map(no));
    let a;
    if (s !== void 0 && s.length === i.length) a = s;
    else {
      const f = {
        ...r.metadata,
        ...this.getLsParams(n)
      }, h = await Vt.configure(r.callbacks, this.callbacks, r.tags, this.tags, f, this.metadata, { verbose: this.verbose }), p = {
        options: n,
        invocation_params: this?.invocationParams(n),
        batch_size: 1
      };
      a = await h?.handleChatModelStart(this.toJSON(), i.map(ch), r.runId, void 0, p, void 0, void 0, r.runName);
    }
    const o = n.outputVersion ?? this.outputVersion, u = [], c = [];
    if (!!a?.[0].handlers.find(Tm) && !this.disableStreaming && i.length === 1 && this._streamResponseChunks !== os.prototype._streamResponseChunks) try {
      const f = await this._streamResponseChunks(i[0], n, a?.[0]);
      let h, p;
      for await (const g of f) {
        if (g.message.id == null) {
          const m = a?.at(0)?.runId;
          m != null && g.message._updateId(`run-${m}`);
        }
        h === void 0 ? h = g : h = hr(h, g), Zh(g.message) && g.message.usage_metadata !== void 0 && (p = { tokenUsage: {
          promptTokens: g.message.usage_metadata.input_tokens,
          completionTokens: g.message.usage_metadata.output_tokens,
          totalTokens: g.message.usage_metadata.total_tokens
        } });
      }
      if (h === void 0) throw new Error("Received empty response from chat model call.");
      u.push([h]), await a?.[0].handleLLMEnd({
        generations: u,
        llmOutput: p
      });
    } catch (f) {
      throw await a?.[0].handleLLMError(f), f;
    }
    else {
      const f = await Promise.allSettled(i.map(async (h, p) => {
        const g = await this._generate(h, {
          ...n,
          promptIndex: p
        }, a?.[p]);
        if (o === "v1") for (const m of g.generations) m.message = uh(m.message);
        return g;
      }));
      await Promise.all(f.map(async (h, p) => {
        if (h.status === "fulfilled") {
          const g = h.value;
          for (const m of g.generations) {
            if (m.message.id == null) {
              const _ = a?.at(0)?.runId;
              _ != null && m.message._updateId(`run-${_}`);
            }
            m.message.response_metadata = {
              ...m.generationInfo,
              ...m.message.response_metadata
            };
          }
          return g.generations.length === 1 && (g.generations[0].message.response_metadata = {
            ...g.llmOutput,
            ...g.generations[0].message.response_metadata
          }), u[p] = g.generations, c[p] = g.llmOutput, a?.[p]?.handleLLMEnd({
            generations: [g.generations],
            llmOutput: g.llmOutput
          });
        } else
          return await a?.[p]?.handleLLMError(h.reason), Promise.reject(h.reason);
      }));
    }
    const d = {
      generations: u,
      llmOutput: c.length ? this._combineLLMOutput?.(...c) : void 0
    };
    return Object.defineProperty(d, go, {
      value: a ? { runIds: a?.map((f) => f.runId) } : void 0,
      configurable: !0
    }), d;
  }
  async _generateCached({ messages: t, cache: n, llmStringKey: r, parsedOptions: s, handledOptions: i }) {
    const a = t.map((_) => _.map(no)), o = {
      ...i.metadata,
      ...this.getLsParams(s)
    }, u = await Vt.configure(i.callbacks, this.callbacks, i.tags, this.tags, o, this.metadata, { verbose: this.verbose }), c = {
      options: s,
      invocation_params: this?.invocationParams(s),
      batch_size: 1
    }, l = await u?.handleChatModelStart(this.toJSON(), a.map(ch), i.runId, void 0, c, void 0, void 0, i.runName), d = [], h = (await Promise.allSettled(a.map(async (_, y) => {
      const b = os._convertInputToPromptValue(_).toString(), T = await n.lookup(b, r);
      return T == null && d.push(y), T;
    }))).map((_, y) => ({
      result: _,
      runManager: l?.[y]
    })).filter(({ result: _ }) => _.status === "fulfilled" && _.value != null || _.status === "rejected"), p = s.outputVersion ?? this.outputVersion, g = [];
    await Promise.all(h.map(async ({ result: _, runManager: y }, b) => {
      if (_.status === "fulfilled") {
        const T = _.value;
        return g[b] = T.map((x) => ("message" in x && ur(x.message) && Dr(x.message) && (x.message.usage_metadata = {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        }, p === "v1" && (x.message = uh(x.message))), x.generationInfo = {
          ...x.generationInfo,
          tokenUsage: {}
        }, x)), T.length && await y?.handleLLMNewToken(T[0].text), y?.handleLLMEnd({ generations: [T] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await y?.handleLLMError(_.reason, void 0, void 0, void 0, { cached: !0 }), Promise.reject(_.reason);
    }));
    const m = {
      generations: g,
      missingPromptIndices: d,
      startedRunManagers: l
    };
    return Object.defineProperty(m, go, {
      value: l ? { runIds: l?.map((_) => _.runId) } : void 0,
      configurable: !0
    }), m;
  }
  /**
  * Generates chat based on the input messages.
  * @param messages An array of arrays of BaseMessage instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generate(t, n, r) {
    let s;
    Array.isArray(n) ? s = { stop: n } : s = n;
    const i = t.map((p) => p.map(no)), [a, o] = this._separateRunnableConfigFromCallOptionsCompat(s);
    if (a.callbacks = a.callbacks ?? r, !this.cache) return this._generateUncached(i, o, a);
    const { cache: u } = this, c = this._getSerializedCacheKeyParametersForCall(o), { generations: l, missingPromptIndices: d, startedRunManagers: f } = await this._generateCached({
      messages: i,
      cache: u,
      llmStringKey: c,
      parsedOptions: o,
      handledOptions: a
    });
    let h = {};
    if (d.length > 0) {
      const p = await this._generateUncached(d.map((g) => i[g]), o, a, f !== void 0 ? d.map((g) => f?.[g]) : void 0);
      await Promise.all(p.generations.map(async (g, m) => {
        const _ = d[m];
        l[_] = g;
        const y = os._convertInputToPromptValue(i[_]).toString();
        return u.update(y, c, g);
      })), h = p.llmOutput ?? {};
    }
    return {
      generations: l,
      llmOutput: h
    };
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(t) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
  * Generates a prompt based on the input prompt values.
  * @param promptValues An array of BasePromptValue instances.
  * @param options The call options or an array of stop sequences.
  * @param callbacks The callbacks for the language model.
  * @returns A Promise that resolves to an LLMResult.
  */
  async generatePrompt(t, n, r) {
    const s = t.map((i) => i.toChatMessages());
    return this.generate(s, n, r);
  }
  withStructuredOutput(t, n) {
    if (typeof this.bindTools != "function") throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
    if (n?.strict) throw new Error('"strict" mode is not supported for this model by default.');
    const r = t, s = n?.name, i = zl(r) ?? "A function available to call.", a = n?.method, o = n?.includeRaw;
    if (a === "jsonMode") throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
    let u = s ?? "extract", c;
    _t(r) ? c = [{
      type: "function",
      function: {
        name: u,
        description: i,
        parameters: it(r)
      }
    }] : ("name" in r && (u = r.name), c = [{
      type: "function",
      function: {
        name: u,
        description: i,
        parameters: r
      }
    }]);
    const l = this.bindTools(c), d = _r.from((g) => {
      if (!We.isInstance(g)) throw new Error("Input is not an AIMessageChunk.");
      if (!g.tool_calls || g.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
      const m = g.tool_calls.find((_) => _.name === u);
      if (!m) throw new Error(`No tool call found with name ${u}.`);
      return m.args;
    });
    if (!o) return l.pipe(d).withConfig({ runName: "StructuredOutput" });
    const f = _n.assign({ parsed: (g, m) => d.invoke(g.raw, m) }), h = _n.assign({ parsed: () => null }), p = f.withFallbacks({ fallbacks: [h] });
    return Kr.from([{ raw: l }, p]).withConfig({ runName: "StructuredOutputRunnable" });
  }
}, RF = class extends bi {
  async _generate(e, t, n) {
    const r = await this._call(e, t, n), s = new rt(r);
    if (typeof s.content != "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
    return { generations: [{
      text: s.content,
      message: s
    }] };
  }
}, PF = class extends nt {
  static lc_name() {
    return "RouterRunnable";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  runnables;
  constructor(e) {
    super(e), this.runnables = e.runnables;
  }
  async invoke(e, t) {
    const { key: n, input: r } = e, s = this.runnables[n];
    if (s === void 0) throw new Error(`No runnable associated with key "${n}".`);
    return s.invoke(r, Ne(t));
  }
  async batch(e, t, n) {
    const r = e.map((d) => d.key), s = e.map((d) => d.input);
    if (r.find((d) => this.runnables[d] === void 0) !== void 0) throw new Error("One or more keys do not have a corresponding runnable.");
    const a = r.map((d) => this.runnables[d]), o = this._getOptionsList(t ?? {}, e.length), u = o[0]?.maxConcurrency ?? n?.maxConcurrency, c = u && u > 0 ? u : e.length, l = [];
    for (let d = 0; d < s.length; d += c) {
      const f = s.slice(d, d + c).map((p, g) => a[g].invoke(p, o[g])), h = await Promise.all(f);
      l.push(h);
    }
    return l.flat();
  }
  async stream(e, t) {
    const { key: n, input: r } = e, s = this.runnables[n];
    if (s === void 0) throw new Error(`No runnable associated with key "${n}".`);
    return s.stream(r, t);
  }
}, NF = class extends nt {
  static lc_name() {
    return "RunnableBranch";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = !0;
  default;
  branches;
  constructor(e) {
    super(e), this.branches = e.branches, this.default = e.default;
  }
  /**
  * Convenience method for instantiating a RunnableBranch from
  * RunnableLikes (objects, functions, or Runnables).
  *
  * Each item in the input except for the last one should be a
  * tuple with two items. The first is a "condition" RunnableLike that
  * returns "true" if the second RunnableLike in the tuple should run.
  *
  * The final item in the input should be a RunnableLike that acts as a
  * default branch if no other branches match.
  *
  * @example
  * ```ts
  * import { RunnableBranch } from "@langchain/core/runnables";
  *
  * const branch = RunnableBranch.from([
  *   [(x: number) => x > 0, (x: number) => x + 1],
  *   [(x: number) => x < 0, (x: number) => x - 1],
  *   (x: number) => x
  * ]);
  * ```
  * @param branches An array where the every item except the last is a tuple of [condition, runnable]
  *   pairs. The last item is a default runnable which is invoked if no other condition matches.
  * @returns A new RunnableBranch.
  */
  static from(e) {
    if (e.length < 1) throw new Error("RunnableBranch requires at least one branch");
    const n = e.slice(0, -1).map(([s, i]) => [Rn(s), Rn(i)]), r = Rn(e[e.length - 1]);
    return new this({
      branches: n,
      default: r
    });
  }
  async _invoke(e, t, n) {
    let r;
    for (let s = 0; s < this.branches.length; s += 1) {
      const [i, a] = this.branches[s];
      if (await i.invoke(e, Ze(t, { callbacks: n?.getChild(`condition:${s + 1}`) }))) {
        r = await a.invoke(e, Ze(t, { callbacks: n?.getChild(`branch:${s + 1}`) }));
        break;
      }
    }
    return r || (r = await this.default.invoke(e, Ze(t, { callbacks: n?.getChild("branch:default") }))), r;
  }
  async invoke(e, t = {}) {
    return this._callWithConfig(this._invoke, e, t);
  }
  async *_streamIterator(e, t) {
    const r = await (await un(t))?.handleChainStart(this.toJSON(), ft(e, "input"), t?.runId, void 0, void 0, void 0, t?.runName);
    let s, i = !0, a;
    try {
      for (let o = 0; o < this.branches.length; o += 1) {
        const [u, c] = this.branches[o];
        if (await u.invoke(e, Ze(t, { callbacks: r?.getChild(`condition:${o + 1}`) }))) {
          a = await c.stream(e, Ze(t, { callbacks: r?.getChild(`branch:${o + 1}`) }));
          for await (const d of a)
            if (yield d, i) if (s === void 0) s = d;
            else try {
              s = hr(s, d);
            } catch {
              s = void 0, i = !1;
            }
          break;
        }
      }
      if (a === void 0) {
        a = await this.default.stream(e, Ze(t, { callbacks: r?.getChild("branch:default") }));
        for await (const o of a)
          if (yield o, i) if (s === void 0) s = o;
          else try {
            s = hr(s, o);
          } catch {
            s = void 0, i = !1;
          }
      }
    } catch (o) {
      throw await r?.handleChainError(o), o;
    }
    await r?.handleChainEnd(s ?? {});
  }
}, MF = class extends fi {
  runnable;
  inputMessagesKey;
  outputMessagesKey;
  historyMessagesKey;
  getMessageHistory;
  constructor(e) {
    let t = _r.from((i, a) => this._enterHistory(i, a ?? {})).withConfig({ runName: "loadHistory" });
    const n = e.historyMessagesKey ?? e.inputMessagesKey;
    n && (t = _n.assign({ [n]: t }).withConfig({ runName: "insertHistory" }));
    const r = t.pipe(e.runnable.withListeners({ onEnd: (i, a) => this._exitHistory(i, a ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" }), s = e.config ?? {};
    super({
      ...e,
      config: s,
      bound: r
    }), this.runnable = e.runnable, this.getMessageHistory = e.getMessageHistory, this.inputMessagesKey = e.inputMessagesKey, this.outputMessagesKey = e.outputMessagesKey, this.historyMessagesKey = e.historyMessagesKey;
  }
  _getInputMessages(e) {
    let t;
    if (typeof e == "object" && !Array.isArray(e) && !ur(e)) {
      let n;
      this.inputMessagesKey ? n = this.inputMessagesKey : Object.keys(e).length === 1 ? n = Object.keys(e)[0] : n = "input", Array.isArray(e[n]) && Array.isArray(e[n][0]) ? t = e[n][0] : t = e[n];
    } else t = e;
    if (typeof t == "string") return [new Zt(t)];
    if (Array.isArray(t)) return t;
    if (ur(t)) return [t];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(t, null, 2)}`);
  }
  _getOutputMessages(e) {
    let t;
    if (!Array.isArray(e) && !ur(e) && typeof e != "string") {
      let n;
      this.outputMessagesKey !== void 0 ? n = this.outputMessagesKey : Object.keys(e).length === 1 ? n = Object.keys(e)[0] : n = "output", e.generations !== void 0 ? t = e.generations[0][0].message : t = e[n];
    } else t = e;
    if (typeof t == "string") return [new rt(t)];
    if (Array.isArray(t)) return t;
    if (ur(t)) return [t];
    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(t, null, 2)}`);
  }
  async _enterHistory(e, t) {
    const r = await (t?.configurable?.messageHistory).getMessages();
    return this.historyMessagesKey === void 0 ? r.concat(this._getInputMessages(e)) : r;
  }
  async _exitHistory(e, t) {
    const n = t.configurable?.messageHistory;
    let r;
    Array.isArray(e.inputs) && Array.isArray(e.inputs[0]) ? r = e.inputs[0] : r = e.inputs;
    let s = this._getInputMessages(r);
    if (this.historyMessagesKey === void 0) {
      const o = await n.getMessages();
      s = s.slice(o.length);
    }
    const i = e.outputs;
    if (!i) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(e, null, 2)}`);
    const a = this._getOutputMessages(i);
    await n.addMessages([...s, ...a]);
  }
  async _mergeConfig(...e) {
    const t = await super._mergeConfig(...e);
    if (!t.configurable || !t.configurable.sessionId) {
      const r = { [this.inputMessagesKey ?? "input"]: "foo" }, s = { configurable: { sessionId: "123" } };
      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(r)}, ${JSON.stringify(s)})`);
    }
    const { sessionId: n } = t.configurable;
    return t.configurable.messageHistory = await this.getMessageHistory(n), t;
  }
}, jF = {};
$e(jF, {
  RouterRunnable: () => PF,
  Runnable: () => nt,
  RunnableAssign: () => Wm,
  RunnableBinding: () => fi,
  RunnableBranch: () => NF,
  RunnableEach: () => lD,
  RunnableLambda: () => _r,
  RunnableMap: () => wi,
  RunnableParallel: () => hD,
  RunnablePassthrough: () => _n,
  RunnablePick: () => YE,
  RunnableRetry: () => Gm,
  RunnableSequence: () => Kr,
  RunnableToolLike: () => wp,
  RunnableWithFallbacks: () => KE,
  RunnableWithMessageHistory: () => MF,
  _coerceToRunnable: () => Rn,
  ensureConfig: () => Ne,
  getCallbackManagerForConfig: () => un,
  mergeConfigs: () => Pc,
  patchConfig: () => Ze,
  pickRunnableConfigKeys: () => dr,
  raceWithSignal: () => fr
});
var Wl = class extends nt {
  /**
  * Parses the result of an LLM call with a given prompt. By default, it
  * simply calls `parseResult`.
  * @param generations The generations from an LLM call.
  * @param _prompt The prompt used in the LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parseResultWithPrompt(e, t, n) {
    return this.parseResult(e, n);
  }
  _baseMessageToString(e) {
    return typeof e.content == "string" ? e.content : this._baseMessageContentToString(e.content);
  }
  _baseMessageContentToString(e) {
    return JSON.stringify(e);
  }
  /**
  * Calls the parser with a given input and optional configuration options.
  * If the input is a string, it creates a generation with the input as
  * text and calls `parseResult`. If the input is a `BaseMessage`, it
  * creates a generation with the input as a message and the content of the
  * input as text, and then calls `parseResult`.
  * @param input The input to the parser, which can be a string or a `BaseMessage`.
  * @param options Optional configuration options.
  * @returns A promise of the parsed output.
  */
  async invoke(e, t) {
    return typeof e == "string" ? this._callWithConfig(async (n, r) => this.parseResult([{ text: n }], r?.callbacks), e, {
      ...t,
      runType: "parser"
    }) : this._callWithConfig(async (n, r) => this.parseResult([{
      message: n,
      text: this._baseMessageToString(n)
    }], r?.callbacks), e, {
      ...t,
      runType: "parser"
    });
  }
}, Jl = class extends Wl {
  parseResult(e, t) {
    return this.parse(e[0].text, t);
  }
  async parseWithPrompt(e, t, n) {
    return this.parse(e, n);
  }
  /**
  * Return the string type key uniquely identifying this class of parser
  */
  _type() {
    throw new Error("_type not implemented");
  }
}, mn = class extends Error {
  llmOutput;
  observation;
  sendToLLM;
  constructor(e, t, n, r = !1) {
    if (super(e), this.llmOutput = t, this.observation = n, this.sendToLLM = r, r && (n === void 0 || t === void 0))
      throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
    AT(this, "OUTPUT_PARSING_FAILURE");
  }
}, qo = class extends Jl {
  async *_transform(e) {
    for await (const t of e) typeof t == "string" ? yield this.parseResult([{ text: t }]) : yield this.parseResult([{
      message: t,
      text: this._baseMessageToString(t)
    }]);
  }
  /**
  * Transforms an asynchronous generator of input into an asynchronous
  * generator of parsed output.
  * @param inputGenerator An asynchronous generator of input.
  * @param options A configuration object.
  * @returns An asynchronous generator of parsed output.
  */
  async *transform(e, t) {
    yield* this._transformStreamWithConfig(e, this._transform.bind(this), {
      ...t,
      runType: "parser"
    });
  }
}, Kl = class extends qo {
  diff = !1;
  constructor(e) {
    super(e), this.diff = e?.diff ?? this.diff;
  }
  async *_transform(e) {
    let t, n;
    for await (const r of e) {
      if (typeof r != "string" && typeof r.content != "string") throw new Error("Cannot handle non-string output.");
      let s;
      if (hm(r)) {
        if (typeof r.content != "string") throw new Error("Cannot handle non-string message output.");
        s = new Xn({
          message: r,
          text: r.content
        });
      } else if (ur(r)) {
        if (typeof r.content != "string") throw new Error("Cannot handle non-string message output.");
        s = new Xn({
          message: Cc(r),
          text: r.content
        });
      } else s = new ii({ text: r });
      n === void 0 ? n = s : n = n.concat(s);
      const i = await this.parsePartialResult([n]);
      i != null && !_s(i, t) && (this.diff ? yield this._diff(t, i) : yield i, t = i);
    }
  }
  getFormatInstructions() {
    return "";
  }
}, LF = class extends qo {
  static lc_name() {
    return "BytesOutputParser";
  }
  lc_namespace = [
    "langchain_core",
    "output_parsers",
    "bytes"
  ];
  lc_serializable = !0;
  textEncoder = new TextEncoder();
  parse(e) {
    return Promise.resolve(this.textEncoder.encode(e));
  }
  getFormatInstructions() {
    return "";
  }
}, Bo = class extends qo {
  re;
  async *_transform(e) {
    let t = "";
    for await (const n of e)
      if (typeof n == "string" ? t += n : t += n.content, this.re) {
        const r = [...t.matchAll(this.re)];
        if (r.length > 1) {
          let s = 0;
          for (const i of r.slice(0, -1))
            yield [i[1]], s += (i.index ?? 0) + i[0].length;
          t = t.slice(s);
        }
      } else {
        const r = await this.parse(t);
        if (r.length > 1) {
          for (const s of r.slice(0, -1)) yield [s];
          t = r[r.length - 1];
        }
      }
    for (const n of await this.parse(t)) yield [n];
  }
}, DF = class extends Bo {
  static lc_name() {
    return "CommaSeparatedListOutputParser";
  }
  lc_namespace = [
    "langchain_core",
    "output_parsers",
    "list"
  ];
  lc_serializable = !0;
  /**
  * Parses the given text into an array of strings, using a comma as the
  * separator. If the parsing fails, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each comma.
  */
  async parse(e) {
    try {
      return e.trim().split(",").map((t) => t.trim());
    } catch {
      throw new mn(`Could not parse output: ${e}`, e);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CommaSeparatedListOutputParser.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return "Your response should be a list of comma separated values, eg: `foo, bar, baz`";
  }
}, UF = class extends Bo {
  lc_namespace = [
    "langchain_core",
    "output_parsers",
    "list"
  ];
  length;
  separator;
  constructor({ length: e, separator: t }) {
    super(...arguments), this.length = e, this.separator = t || ",";
  }
  /**
  * Parses the given text into an array of strings, using the specified
  * separator. If the parsing fails or the number of items in the list
  * doesn't match the expected length, throws an OutputParserException.
  * @param text The text to parse.
  * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
  */
  async parse(e) {
    try {
      const t = e.trim().split(this.separator).map((n) => n.trim());
      if (this.length !== void 0 && t.length !== this.length) throw new mn(`Incorrect number of items. Expected ${this.length}, got ${t.length}.`);
      return t;
    } catch (t) {
      throw Object.getPrototypeOf(t) === mn.prototype ? t : new mn(`Could not parse output: ${e}`);
    }
  }
  /**
  * Provides instructions on the expected format of the response for the
  * CustomListOutputParser, including the number of items and the
  * separator.
  * @returns A string containing instructions on the expected format of the response.
  */
  getFormatInstructions() {
    return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
  }
}, FF = class extends Bo {
  static lc_name() {
    return "NumberedListOutputParser";
  }
  lc_namespace = [
    "langchain_core",
    "output_parsers",
    "list"
  ];
  lc_serializable = !0;
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  re = /\d+\.\s([^\n]+)/g;
  async parse(e) {
    return [...e.matchAll(this.re) ?? []].map((t) => t[1]);
  }
}, zF = class extends Bo {
  static lc_name() {
    return "NumberedListOutputParser";
  }
  lc_namespace = [
    "langchain_core",
    "output_parsers",
    "list"
  ];
  lc_serializable = !0;
  getFormatInstructions() {
    return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
  }
  re = /^\s*[-*]\s([^\n]+)$/gm;
  async parse(e) {
    return [...e.matchAll(this.re) ?? []].map((t) => t[1]);
  }
}, qF = class extends qo {
  static lc_name() {
    return "StrOutputParser";
  }
  lc_namespace = [
    "langchain_core",
    "output_parsers",
    "string"
  ];
  lc_serializable = !0;
  /**
  * Parses a string output from an LLM call. This method is meant to be
  * implemented by subclasses to define how a string output from an LLM
  * should be parsed.
  * @param text The string output from an LLM call.
  * @param callbacks Optional callbacks.
  * @returns A promise of the parsed output.
  */
  parse(e) {
    return Promise.resolve(e);
  }
  getFormatInstructions() {
    return "";
  }
  _textContentToString(e) {
    return e.text;
  }
  _imageUrlContentToString(e) {
    throw new Error('Cannot coerce a multimodal "image_url" message part into a string.');
  }
  _messageContentToString(e) {
    switch (e.type) {
      case "text":
      case "text_delta":
        if ("text" in e) return this._textContentToString(e);
        break;
      case "image_url":
        if ("image_url" in e) return this._imageUrlContentToString(e);
        break;
      default:
        throw new Error(`Cannot coerce "${e.type}" message part into a string.`);
    }
    throw new Error(`Invalid content type: ${e.type}`);
  }
  _baseMessageContentToString(e) {
    return e.reduce((t, n) => t + this._messageContentToString(n), "");
  }
}, bs = class extends Jl {
  static lc_name() {
    return "StructuredOutputParser";
  }
  lc_namespace = [
    "langchain",
    "output_parsers",
    "structured"
  ];
  toJSON() {
    return this.toJSONNotImplemented();
  }
  constructor(e) {
    super(e), this.schema = e;
  }
  /**
  * Creates a new StructuredOutputParser from a Zod schema.
  * @param schema The Zod schema which the output should match
  * @returns A new instance of StructuredOutputParser.
  */
  static fromZodSchema(e) {
    return new this(e);
  }
  /**
  * Creates a new StructuredOutputParser from a set of names and
  * descriptions.
  * @param schemas An object where each key is a name and each value is a description
  * @returns A new instance of StructuredOutputParser.
  */
  static fromNamesAndDescriptions(e) {
    const t = Zl(Object.fromEntries(Object.entries(e).map(([n, r]) => [n, Bl().describe(r)])));
    return new this(t);
  }
  /**
  * Returns a markdown code snippet with a JSON object formatted according
  * to the schema.
  * @param options Optional. The options for formatting the instructions
  * @returns A markdown code snippet with a JSON object formatted according to the schema.
  */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(it(this.schema))}
\`\`\`
`;
  }
  /**
  * Parses the given text according to the schema.
  * @param text The text to parse
  * @returns The parsed output.
  */
  async parse(e) {
    try {
      const t = e.trim(), r = (t.match(/^```(?:json)?\s*([\s\S]*?)```/)?.[1] || t.match(/```json\s*([\s\S]*?)```/)?.[1] || t).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (s, i) => `"${i.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
      return await Fl(this.schema, JSON.parse(r));
    } catch (t) {
      throw new mn(`Failed to parse. Text: "${e}". Error: ${t}`, e);
    }
  }
}, Ek = class extends bs {
  static lc_name() {
    return "JsonMarkdownStructuredOutputParser";
  }
  getFormatInstructions(e) {
    const t = e?.interpolationDepth ?? 1;
    if (t < 1) throw new Error("f string interpolation depth must be at least 1");
    return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(it(this.schema)).replaceAll("{", "{".repeat(t)).replaceAll("}", "}".repeat(t))}
\`\`\``;
  }
  _schemaToInstruction(e, t = 2) {
    const n = e;
    if ("type" in n) {
      let r = !1, s;
      if (Array.isArray(n.type)) {
        const o = n.type.findIndex((u) => u === "null");
        o !== -1 && (r = !0, n.type.splice(o, 1)), s = n.type.join(" | ");
      } else s = n.type;
      if (n.type === "object" && n.properties) {
        const o = n.description ? ` // ${n.description}` : "";
        return `{
${Object.entries(n.properties).map(([c, l]) => {
          const d = n.required?.includes(c) ? "" : " (optional)";
          return `${" ".repeat(t)}"${c}": ${this._schemaToInstruction(l, t + 2)}${d}`;
        }).join(`
`)}
${" ".repeat(t - 2)}}${o}`;
      }
      if (n.type === "array" && n.items) {
        const o = n.description ? ` // ${n.description}` : "";
        return `array[
${" ".repeat(t)}${this._schemaToInstruction(n.items, t + 2)}
${" ".repeat(t - 2)}] ${o}`;
      }
      const i = r ? " (nullable)" : "", a = n.description ? ` // ${n.description}` : "";
      return `${s}${a}${i}`;
    }
    if ("anyOf" in n) return n.anyOf.map((r) => this._schemaToInstruction(r, t)).join(`
${" ".repeat(t - 2)}`);
    throw new Error("unsupported schema type");
  }
  static fromZodSchema(e) {
    return new this(e);
  }
  static fromNamesAndDescriptions(e) {
    const t = Zl(Object.fromEntries(Object.entries(e).map(([n, r]) => [n, Bl().describe(r)])));
    return new this(t);
  }
}, BF = class extends Jl {
  structuredInputParser;
  constructor({ inputSchema: e }) {
    super(...arguments), this.structuredInputParser = new Ek(e);
  }
  async parse(e) {
    let t;
    try {
      t = await this.structuredInputParser.parse(e);
    } catch (n) {
      throw new mn(`Failed to parse. Text: "${e}". Error: ${n}`, e);
    }
    return this.outputProcessor(t);
  }
  getFormatInstructions() {
    return this.structuredInputParser.getFormatInstructions();
  }
}, ZF = {};
$e(ZF, {
  applyPatch: () => si,
  compare: () => Nm
});
var Ss = class extends Kl {
  static lc_name() {
    return "JsonOutputParser";
  }
  lc_namespace = ["langchain_core", "output_parsers"];
  lc_serializable = !0;
  /** @internal */
  _concatOutputChunks(e, t) {
    return this.diff ? super._concatOutputChunks(e, t) : t;
  }
  _diff(e, t) {
    if (t)
      return e ? Nm(e, t) : [{
        op: "replace",
        path: "",
        value: t
      }];
  }
  async parsePartialResult(e) {
    return Bh(e[0].text);
  }
  async parse(e) {
    return Bh(e, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
  /**
  * Extracts text content from a message for JSON parsing.
  * Uses the message's `.text` accessor which properly handles both
  * string content and ContentBlock[] arrays (extracting text from text blocks).
  * @param message The message to extract text from
  * @returns The text content of the message
  */
  _baseMessageToString(e) {
    return e.text;
  }
};
const VF = function() {
  const e = {};
  e.parser = function(v, w) {
    return new n(v, w);
  }, e.SAXParser = n, e.SAXStream = c, e.createStream = u, e.MAX_BUFFER_LENGTH = 64 * 1024;
  const t = [
    "comment",
    "sgmlDecl",
    "textNode",
    "tagName",
    "doctype",
    "procInstName",
    "procInstBody",
    "entity",
    "attribName",
    "attribValue",
    "cdata",
    "script"
  ];
  e.EVENTS = [
    "text",
    "processinginstruction",
    "sgmldeclaration",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "opencdata",
    "cdata",
    "closecdata",
    "error",
    "end",
    "ready",
    "script",
    "opennamespace",
    "closenamespace"
  ];
  function n(v, w) {
    if (!(this instanceof n)) return new n(v, w);
    var C = this;
    s(C), C.q = C.c = "", C.bufferCheckPosition = e.MAX_BUFFER_LENGTH, C.opt = w || {}, C.opt.lowercase = C.opt.lowercase || C.opt.lowercasetags, C.looseCase = C.opt.lowercase ? "toLowerCase" : "toUpperCase", C.tags = [], C.closed = C.closedRoot = C.sawRoot = !1, C.tag = C.error = null, C.strict = !!v, C.noscript = !!(v || C.opt.noscript), C.state = S.BEGIN, C.strictEntities = C.opt.strictEntities, C.ENTITIES = C.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), C.attribList = [], C.opt.xmlns && (C.ns = Object.create(p)), C.trackPosition = C.opt.position !== !1, C.trackPosition && (C.position = C.line = C.column = 0), U(C, "onready");
  }
  Object.create || (Object.create = function(v) {
    function w() {
    }
    w.prototype = v;
    var C = new w();
    return C;
  }), Object.keys || (Object.keys = function(v) {
    var w = [];
    for (var C in v) v.hasOwnProperty(C) && w.push(C);
    return w;
  });
  function r(v) {
    for (var w = Math.max(e.MAX_BUFFER_LENGTH, 10), C = 0, E = 0, ae = t.length; E < ae; E++) {
      var ce = v[t[E]].length;
      if (ce > w) switch (t[E]) {
        case "textNode":
          He(v);
          break;
        case "cdata":
          G(v, "oncdata", v.cdata), v.cdata = "";
          break;
        case "script":
          G(v, "onscript", v.script), v.script = "";
          break;
        default:
          D(v, "Max buffer length exceeded: " + t[E]);
      }
      C = Math.max(C, ce);
    }
    var le = e.MAX_BUFFER_LENGTH - C;
    v.bufferCheckPosition = le + v.position;
  }
  function s(v) {
    for (var w = 0, C = t.length; w < C; w++) v[t[w]] = "";
  }
  function i(v) {
    He(v), v.cdata !== "" && (G(v, "oncdata", v.cdata), v.cdata = ""), v.script !== "" && (G(v, "onscript", v.script), v.script = "");
  }
  n.prototype = {
    end: function() {
      N(this);
    },
    write: z,
    resume: function() {
      return this.error = null, this;
    },
    close: function() {
      return this.write(null);
    },
    flush: function() {
      i(this);
    }
  };
  var a = ReadableStream;
  a || (a = function() {
  });
  var o = e.EVENTS.filter(function(v) {
    return v !== "error" && v !== "end";
  });
  function u(v, w) {
    return new c(v, w);
  }
  function c(v, w) {
    if (!(this instanceof c)) return new c(v, w);
    a.apply(this), this._parser = new n(v, w), this.writable = !0, this.readable = !0;
    var C = this;
    this._parser.onend = function() {
      C.emit("end");
    }, this._parser.onerror = function(E) {
      C.emit("error", E), C._parser.error = null;
    }, this._decoder = null, o.forEach(function(E) {
      Object.defineProperty(C, "on" + E, {
        get: function() {
          return C._parser["on" + E];
        },
        set: function(ae) {
          if (!ae)
            return C.removeAllListeners(E), C._parser["on" + E] = ae, ae;
          C.on(E, ae);
        },
        enumerable: !0,
        configurable: !1
      });
    });
  }
  c.prototype = Object.create(a.prototype, { constructor: { value: c } }), c.prototype.write = function(v) {
    return this._parser.write(v.toString()), this.emit("data", v), !0;
  }, c.prototype.end = function(v) {
    return v && v.length && this.write(v), this._parser.end(), !0;
  }, c.prototype.on = function(v, w) {
    var C = this;
    return !C._parser["on" + v] && o.indexOf(v) !== -1 && (C._parser["on" + v] = function() {
      var E = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
      E.splice(0, 0, v), C.emit.apply(C, E);
    }), a.prototype.on.call(C, v, w);
  };
  var l = "[CDATA[", d = "DOCTYPE", f = "http://www.w3.org/XML/1998/namespace", h = "http://www.w3.org/2000/xmlns/", p = {
    xml: f,
    xmlns: h
  }, g = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, m = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, _ = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
  function b(v) {
    return v === " " || v === `
` || v === "\r" || v === "	";
  }
  function T(v) {
    return v === '"' || v === "'";
  }
  function x(v) {
    return v === ">" || b(v);
  }
  function k(v, w) {
    return v.test(w);
  }
  function O(v, w) {
    return !k(v, w);
  }
  var S = 0;
  e.STATE = {
    BEGIN: S++,
    BEGIN_WHITESPACE: S++,
    TEXT: S++,
    TEXT_ENTITY: S++,
    OPEN_WAKA: S++,
    SGML_DECL: S++,
    SGML_DECL_QUOTED: S++,
    DOCTYPE: S++,
    DOCTYPE_QUOTED: S++,
    DOCTYPE_DTD: S++,
    DOCTYPE_DTD_QUOTED: S++,
    COMMENT_STARTING: S++,
    COMMENT: S++,
    COMMENT_ENDING: S++,
    COMMENT_ENDED: S++,
    CDATA: S++,
    CDATA_ENDING: S++,
    CDATA_ENDING_2: S++,
    PROC_INST: S++,
    PROC_INST_BODY: S++,
    PROC_INST_ENDING: S++,
    OPEN_TAG: S++,
    OPEN_TAG_SLASH: S++,
    ATTRIB: S++,
    ATTRIB_NAME: S++,
    ATTRIB_NAME_SAW_WHITE: S++,
    ATTRIB_VALUE: S++,
    ATTRIB_VALUE_QUOTED: S++,
    ATTRIB_VALUE_CLOSED: S++,
    ATTRIB_VALUE_UNQUOTED: S++,
    ATTRIB_VALUE_ENTITY_Q: S++,
    ATTRIB_VALUE_ENTITY_U: S++,
    CLOSE_TAG: S++,
    CLOSE_TAG_SAW_WHITE: S++,
    SCRIPT: S++,
    SCRIPT_ENDING: S++
  }, e.XML_ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  }, e.ENTITIES = {
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'",
    AElig: 198,
    Aacute: 193,
    Acirc: 194,
    Agrave: 192,
    Aring: 197,
    Atilde: 195,
    Auml: 196,
    Ccedil: 199,
    ETH: 208,
    Eacute: 201,
    Ecirc: 202,
    Egrave: 200,
    Euml: 203,
    Iacute: 205,
    Icirc: 206,
    Igrave: 204,
    Iuml: 207,
    Ntilde: 209,
    Oacute: 211,
    Ocirc: 212,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Ouml: 214,
    THORN: 222,
    Uacute: 218,
    Ucirc: 219,
    Ugrave: 217,
    Uuml: 220,
    Yacute: 221,
    aacute: 225,
    acirc: 226,
    aelig: 230,
    agrave: 224,
    aring: 229,
    atilde: 227,
    auml: 228,
    ccedil: 231,
    eacute: 233,
    ecirc: 234,
    egrave: 232,
    eth: 240,
    euml: 235,
    iacute: 237,
    icirc: 238,
    igrave: 236,
    iuml: 239,
    ntilde: 241,
    oacute: 243,
    ocirc: 244,
    ograve: 242,
    oslash: 248,
    otilde: 245,
    ouml: 246,
    szlig: 223,
    thorn: 254,
    uacute: 250,
    ucirc: 251,
    ugrave: 249,
    uuml: 252,
    yacute: 253,
    yuml: 255,
    copy: 169,
    reg: 174,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    sect: 167,
    uml: 168,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    macr: 175,
    deg: 176,
    plusmn: 177,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    times: 215,
    divide: 247,
    OElig: 338,
    oelig: 339,
    Scaron: 352,
    scaron: 353,
    Yuml: 376,
    fnof: 402,
    circ: 710,
    tilde: 732,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetasym: 977,
    upsih: 978,
    piv: 982,
    ensp: 8194,
    emsp: 8195,
    thinsp: 8201,
    zwnj: 8204,
    zwj: 8205,
    lrm: 8206,
    rlm: 8207,
    ndash: 8211,
    mdash: 8212,
    lsquo: 8216,
    rsquo: 8217,
    sbquo: 8218,
    ldquo: 8220,
    rdquo: 8221,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    bull: 8226,
    hellip: 8230,
    permil: 8240,
    prime: 8242,
    Prime: 8243,
    lsaquo: 8249,
    rsaquo: 8250,
    oline: 8254,
    frasl: 8260,
    euro: 8364,
    image: 8465,
    weierp: 8472,
    real: 8476,
    trade: 8482,
    alefsym: 8501,
    larr: 8592,
    uarr: 8593,
    rarr: 8594,
    darr: 8595,
    harr: 8596,
    crarr: 8629,
    lArr: 8656,
    uArr: 8657,
    rArr: 8658,
    dArr: 8659,
    hArr: 8660,
    forall: 8704,
    part: 8706,
    exist: 8707,
    empty: 8709,
    nabla: 8711,
    isin: 8712,
    notin: 8713,
    ni: 8715,
    prod: 8719,
    sum: 8721,
    minus: 8722,
    lowast: 8727,
    radic: 8730,
    prop: 8733,
    infin: 8734,
    ang: 8736,
    and: 8743,
    or: 8744,
    cap: 8745,
    cup: 8746,
    int: 8747,
    there4: 8756,
    sim: 8764,
    cong: 8773,
    asymp: 8776,
    ne: 8800,
    equiv: 8801,
    le: 8804,
    ge: 8805,
    sub: 8834,
    sup: 8835,
    nsub: 8836,
    sube: 8838,
    supe: 8839,
    oplus: 8853,
    otimes: 8855,
    perp: 8869,
    sdot: 8901,
    lceil: 8968,
    rceil: 8969,
    lfloor: 8970,
    rfloor: 8971,
    lang: 9001,
    rang: 9002,
    loz: 9674,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830
  }, Object.keys(e.ENTITIES).forEach(function(v) {
    var w = e.ENTITIES[v], C = typeof w == "number" ? String.fromCharCode(w) : w;
    e.ENTITIES[v] = C;
  });
  for (var j in e.STATE) e.STATE[e.STATE[j]] = j;
  S = e.STATE;
  function U(v, w, C) {
    v[w] && v[w](C);
  }
  function G(v, w, C) {
    v.textNode && He(v), U(v, w, C);
  }
  function He(v) {
    v.textNode = yt(v.opt, v.textNode), v.textNode && U(v, "ontext", v.textNode), v.textNode = "";
  }
  function yt(v, w) {
    return v.trim && (w = w.trim()), v.normalize && (w = w.replace(/\s+/g, " ")), w;
  }
  function D(v, w) {
    return He(v), v.trackPosition && (w += `
Line: ` + v.line + `
Column: ` + v.column + `
Char: ` + v.c), w = new Error(w), v.error = w, U(v, "onerror", w), v;
  }
  function N(v) {
    return v.sawRoot && !v.closedRoot && L(v, "Unclosed root tag"), v.state !== S.BEGIN && v.state !== S.BEGIN_WHITESPACE && v.state !== S.TEXT && D(v, "Unexpected end"), He(v), v.c = "", v.closed = !0, U(v, "onend"), n.call(v, v.strict, v.opt), v;
  }
  function L(v, w) {
    if (typeof v != "object" || !(v instanceof n)) throw new Error("bad call to strictFail");
    v.strict && D(v, w);
  }
  function Z(v) {
    v.strict || (v.tagName = v.tagName[v.looseCase]());
    var w = v.tags[v.tags.length - 1] || v, C = v.tag = {
      name: v.tagName,
      attributes: {}
    };
    v.opt.xmlns && (C.ns = w.ns), v.attribList.length = 0, G(v, "onopentagstart", C);
  }
  function ee(v, w) {
    var C = v.indexOf(":"), E = C < 0 ? ["", v] : v.split(":"), ae = E[0], ce = E[1];
    return w && v === "xmlns" && (ae = "xmlns", ce = ""), {
      prefix: ae,
      local: ce
    };
  }
  function q(v) {
    if (v.strict || (v.attribName = v.attribName[v.looseCase]()), v.attribList.indexOf(v.attribName) !== -1 || v.tag.attributes.hasOwnProperty(v.attribName)) {
      v.attribName = v.attribValue = "";
      return;
    }
    if (v.opt.xmlns) {
      var w = ee(v.attribName, !0), C = w.prefix, E = w.local;
      if (C === "xmlns") if (E === "xml" && v.attribValue !== f) L(v, "xml: prefix must be bound to " + f + `
Actual: ` + v.attribValue);
      else if (E === "xmlns" && v.attribValue !== h) L(v, "xmlns: prefix must be bound to " + h + `
Actual: ` + v.attribValue);
      else {
        var ae = v.tag, ce = v.tags[v.tags.length - 1] || v;
        ae.ns === ce.ns && (ae.ns = Object.create(ce.ns)), ae.ns[E] = v.attribValue;
      }
      v.attribList.push([v.attribName, v.attribValue]);
    } else
      v.tag.attributes[v.attribName] = v.attribValue, G(v, "onattribute", {
        name: v.attribName,
        value: v.attribValue
      });
    v.attribName = v.attribValue = "";
  }
  function ie(v, w) {
    if (v.opt.xmlns) {
      var C = v.tag, E = ee(v.tagName);
      C.prefix = E.prefix, C.local = E.local, C.uri = C.ns[E.prefix] || "", C.prefix && !C.uri && (L(v, "Unbound namespace prefix: " + JSON.stringify(v.tagName)), C.uri = E.prefix);
      var ae = v.tags[v.tags.length - 1] || v;
      C.ns && ae.ns !== C.ns && Object.keys(C.ns).forEach(function(Xr) {
        G(v, "onopennamespace", {
          prefix: Xr,
          uri: C.ns[Xr]
        });
      });
      for (var ce = 0, le = v.attribList.length; ce < le; ce++) {
        var fe = v.attribList[ce], Ae = fe[0], Oe = fe[1], Xe = ee(Ae, !0), dn = Xe.prefix, Cs = Xe.local, Wo = dn === "" ? "" : C.ns[dn] || "", V = {
          name: Ae,
          value: Oe,
          prefix: dn,
          local: Cs,
          uri: Wo
        };
        dn && dn !== "xmlns" && !Wo && (L(v, "Unbound namespace prefix: " + JSON.stringify(dn)), V.uri = dn), v.tag.attributes[Ae] = V, G(v, "onattribute", V);
      }
      v.attribList.length = 0;
    }
    v.tag.isSelfClosing = !!w, v.sawRoot = !0, v.tags.push(v.tag), G(v, "onopentag", v.tag), w || (!v.noscript && v.tagName.toLowerCase() === "script" ? v.state = S.SCRIPT : v.state = S.TEXT, v.tag = null, v.tagName = ""), v.attribName = v.attribValue = "", v.attribList.length = 0;
  }
  function Te(v) {
    if (!v.tagName) {
      L(v, "Weird empty close tag."), v.textNode += "</>", v.state = S.TEXT;
      return;
    }
    if (v.script) {
      if (v.tagName !== "script") {
        v.script += "</" + v.tagName + ">", v.tagName = "", v.state = S.SCRIPT;
        return;
      }
      G(v, "onscript", v.script), v.script = "";
    }
    var w = v.tags.length, C = v.tagName;
    v.strict || (C = C[v.looseCase]());
    for (var E = C; w--; ) {
      var ae = v.tags[w];
      if (ae.name !== E) L(v, "Unexpected close tag");
      else break;
    }
    if (w < 0) {
      L(v, "Unmatched closing tag: " + v.tagName), v.textNode += "</" + v.tagName + ">", v.state = S.TEXT;
      return;
    }
    v.tagName = C;
    for (var ce = v.tags.length; ce-- > w; ) {
      var le = v.tag = v.tags.pop();
      v.tagName = v.tag.name, G(v, "onclosetag", v.tagName);
      var fe = {};
      for (var Ae in le.ns) fe[Ae] = le.ns[Ae];
      var Oe = v.tags[v.tags.length - 1] || v;
      v.opt.xmlns && le.ns !== Oe.ns && Object.keys(le.ns).forEach(function(Xe) {
        var dn = le.ns[Xe];
        G(v, "onclosenamespace", {
          prefix: Xe,
          uri: dn
        });
      });
    }
    w === 0 && (v.closedRoot = !0), v.tagName = v.attribValue = v.attribName = "", v.attribList.length = 0, v.state = S.TEXT;
  }
  function me(v) {
    var w = v.entity, C = w.toLowerCase(), E, ae = "";
    return v.ENTITIES[w] ? v.ENTITIES[w] : v.ENTITIES[C] ? v.ENTITIES[C] : (w = C, w.charAt(0) === "#" && (w.charAt(1) === "x" ? (w = w.slice(2), E = parseInt(w, 16), ae = E.toString(16)) : (w = w.slice(1), E = parseInt(w, 10), ae = E.toString(10))), w = w.replace(/^0+/, ""), isNaN(E) || ae.toLowerCase() !== w ? (L(v, "Invalid character entity"), "&" + v.entity + ";") : String.fromCodePoint(E));
  }
  function Re(v, w) {
    w === "<" ? (v.state = S.OPEN_WAKA, v.startTagPosition = v.position) : b(w) || (L(v, "Non-whitespace before first tag."), v.textNode = w, v.state = S.TEXT);
  }
  function Be(v, w) {
    var C = "";
    return w < v.length && (C = v.charAt(w)), C;
  }
  function z(v) {
    var w = this;
    if (this.error) throw this.error;
    if (w.closed) return D(w, "Cannot write after close. Assign an onready handler.");
    if (v === null) return N(w);
    typeof v == "object" && (v = v.toString());
    for (var C = 0, E = ""; E = Be(v, C++), w.c = E, !!E; )
      switch (w.trackPosition && (w.position++, E === `
` ? (w.line++, w.column = 0) : w.column++), w.state) {
        case S.BEGIN:
          if (w.state = S.BEGIN_WHITESPACE, E === "\uFEFF") continue;
          Re(w, E);
          continue;
        case S.BEGIN_WHITESPACE:
          Re(w, E);
          continue;
        case S.TEXT:
          if (w.sawRoot && !w.closedRoot) {
            for (var ae = C - 1; E && E !== "<" && E !== "&"; )
              E = Be(v, C++), E && w.trackPosition && (w.position++, E === `
` ? (w.line++, w.column = 0) : w.column++);
            w.textNode += v.substring(ae, C - 1);
          }
          E === "<" && !(w.sawRoot && w.closedRoot && !w.strict) ? (w.state = S.OPEN_WAKA, w.startTagPosition = w.position) : (!b(E) && (!w.sawRoot || w.closedRoot) && L(w, "Text data outside of root node."), E === "&" ? w.state = S.TEXT_ENTITY : w.textNode += E);
          continue;
        case S.SCRIPT:
          E === "<" ? w.state = S.SCRIPT_ENDING : w.script += E;
          continue;
        case S.SCRIPT_ENDING:
          E === "/" ? w.state = S.CLOSE_TAG : (w.script += "<" + E, w.state = S.SCRIPT);
          continue;
        case S.OPEN_WAKA:
          if (E === "!")
            w.state = S.SGML_DECL, w.sgmlDecl = "";
          else if (!b(E)) if (k(g, E))
            w.state = S.OPEN_TAG, w.tagName = E;
          else if (E === "/")
            w.state = S.CLOSE_TAG, w.tagName = "";
          else if (E === "?")
            w.state = S.PROC_INST, w.procInstName = w.procInstBody = "";
          else {
            if (L(w, "Unencoded <"), w.startTagPosition + 1 < w.position) {
              var ce = w.position - w.startTagPosition;
              E = new Array(ce).join(" ") + E;
            }
            w.textNode += "<" + E, w.state = S.TEXT;
          }
          continue;
        case S.SGML_DECL:
          (w.sgmlDecl + E).toUpperCase() === l ? (G(w, "onopencdata"), w.state = S.CDATA, w.sgmlDecl = "", w.cdata = "") : w.sgmlDecl + E === "--" ? (w.state = S.COMMENT, w.comment = "", w.sgmlDecl = "") : (w.sgmlDecl + E).toUpperCase() === d ? (w.state = S.DOCTYPE, (w.doctype || w.sawRoot) && L(w, "Inappropriately located doctype declaration"), w.doctype = "", w.sgmlDecl = "") : E === ">" ? (G(w, "onsgmldeclaration", w.sgmlDecl), w.sgmlDecl = "", w.state = S.TEXT) : (T(E) && (w.state = S.SGML_DECL_QUOTED), w.sgmlDecl += E);
          continue;
        case S.SGML_DECL_QUOTED:
          E === w.q && (w.state = S.SGML_DECL, w.q = ""), w.sgmlDecl += E;
          continue;
        case S.DOCTYPE:
          E === ">" ? (w.state = S.TEXT, G(w, "ondoctype", w.doctype), w.doctype = !0) : (w.doctype += E, E === "[" ? w.state = S.DOCTYPE_DTD : T(E) && (w.state = S.DOCTYPE_QUOTED, w.q = E));
          continue;
        case S.DOCTYPE_QUOTED:
          w.doctype += E, E === w.q && (w.q = "", w.state = S.DOCTYPE);
          continue;
        case S.DOCTYPE_DTD:
          w.doctype += E, E === "]" ? w.state = S.DOCTYPE : T(E) && (w.state = S.DOCTYPE_DTD_QUOTED, w.q = E);
          continue;
        case S.DOCTYPE_DTD_QUOTED:
          w.doctype += E, E === w.q && (w.state = S.DOCTYPE_DTD, w.q = "");
          continue;
        case S.COMMENT:
          E === "-" ? w.state = S.COMMENT_ENDING : w.comment += E;
          continue;
        case S.COMMENT_ENDING:
          E === "-" ? (w.state = S.COMMENT_ENDED, w.comment = yt(w.opt, w.comment), w.comment && G(w, "oncomment", w.comment), w.comment = "") : (w.comment += "-" + E, w.state = S.COMMENT);
          continue;
        case S.COMMENT_ENDED:
          E !== ">" ? (L(w, "Malformed comment"), w.comment += "--" + E, w.state = S.COMMENT) : w.state = S.TEXT;
          continue;
        case S.CDATA:
          E === "]" ? w.state = S.CDATA_ENDING : w.cdata += E;
          continue;
        case S.CDATA_ENDING:
          E === "]" ? w.state = S.CDATA_ENDING_2 : (w.cdata += "]" + E, w.state = S.CDATA);
          continue;
        case S.CDATA_ENDING_2:
          E === ">" ? (w.cdata && G(w, "oncdata", w.cdata), G(w, "onclosecdata"), w.cdata = "", w.state = S.TEXT) : E === "]" ? w.cdata += "]" : (w.cdata += "]]" + E, w.state = S.CDATA);
          continue;
        case S.PROC_INST:
          E === "?" ? w.state = S.PROC_INST_ENDING : b(E) ? w.state = S.PROC_INST_BODY : w.procInstName += E;
          continue;
        case S.PROC_INST_BODY:
          if (!w.procInstBody && b(E)) continue;
          E === "?" ? w.state = S.PROC_INST_ENDING : w.procInstBody += E;
          continue;
        case S.PROC_INST_ENDING:
          E === ">" ? (G(w, "onprocessinginstruction", {
            name: w.procInstName,
            body: w.procInstBody
          }), w.procInstName = w.procInstBody = "", w.state = S.TEXT) : (w.procInstBody += "?" + E, w.state = S.PROC_INST_BODY);
          continue;
        case S.OPEN_TAG:
          k(m, E) ? w.tagName += E : (Z(w), E === ">" ? ie(w) : E === "/" ? w.state = S.OPEN_TAG_SLASH : (b(E) || L(w, "Invalid character in tag name"), w.state = S.ATTRIB));
          continue;
        case S.OPEN_TAG_SLASH:
          E === ">" ? (ie(w, !0), Te(w)) : (L(w, "Forward-slash in opening tag not followed by >"), w.state = S.ATTRIB);
          continue;
        case S.ATTRIB:
          if (b(E)) continue;
          E === ">" ? ie(w) : E === "/" ? w.state = S.OPEN_TAG_SLASH : k(g, E) ? (w.attribName = E, w.attribValue = "", w.state = S.ATTRIB_NAME) : L(w, "Invalid attribute name");
          continue;
        case S.ATTRIB_NAME:
          E === "=" ? w.state = S.ATTRIB_VALUE : E === ">" ? (L(w, "Attribute without value"), w.attribValue = w.attribName, q(w), ie(w)) : b(E) ? w.state = S.ATTRIB_NAME_SAW_WHITE : k(m, E) ? w.attribName += E : L(w, "Invalid attribute name");
          continue;
        case S.ATTRIB_NAME_SAW_WHITE:
          if (E === "=") w.state = S.ATTRIB_VALUE;
          else {
            if (b(E)) continue;
            L(w, "Attribute without value"), w.tag.attributes[w.attribName] = "", w.attribValue = "", G(w, "onattribute", {
              name: w.attribName,
              value: ""
            }), w.attribName = "", E === ">" ? ie(w) : k(g, E) ? (w.attribName = E, w.state = S.ATTRIB_NAME) : (L(w, "Invalid attribute name"), w.state = S.ATTRIB);
          }
          continue;
        case S.ATTRIB_VALUE:
          if (b(E)) continue;
          T(E) ? (w.q = E, w.state = S.ATTRIB_VALUE_QUOTED) : (L(w, "Unquoted attribute value"), w.state = S.ATTRIB_VALUE_UNQUOTED, w.attribValue = E);
          continue;
        case S.ATTRIB_VALUE_QUOTED:
          if (E !== w.q) {
            E === "&" ? w.state = S.ATTRIB_VALUE_ENTITY_Q : w.attribValue += E;
            continue;
          }
          q(w), w.q = "", w.state = S.ATTRIB_VALUE_CLOSED;
          continue;
        case S.ATTRIB_VALUE_CLOSED:
          b(E) ? w.state = S.ATTRIB : E === ">" ? ie(w) : E === "/" ? w.state = S.OPEN_TAG_SLASH : k(g, E) ? (L(w, "No whitespace between attributes"), w.attribName = E, w.attribValue = "", w.state = S.ATTRIB_NAME) : L(w, "Invalid attribute name");
          continue;
        case S.ATTRIB_VALUE_UNQUOTED:
          if (!x(E)) {
            E === "&" ? w.state = S.ATTRIB_VALUE_ENTITY_U : w.attribValue += E;
            continue;
          }
          q(w), E === ">" ? ie(w) : w.state = S.ATTRIB;
          continue;
        case S.CLOSE_TAG:
          if (w.tagName) E === ">" ? Te(w) : k(m, E) ? w.tagName += E : w.script ? (w.script += "</" + w.tagName, w.tagName = "", w.state = S.SCRIPT) : (b(E) || L(w, "Invalid tagname in closing tag"), w.state = S.CLOSE_TAG_SAW_WHITE);
          else {
            if (b(E)) continue;
            O(g, E) ? w.script ? (w.script += "</" + E, w.state = S.SCRIPT) : L(w, "Invalid tagname in closing tag.") : w.tagName = E;
          }
          continue;
        case S.CLOSE_TAG_SAW_WHITE:
          if (b(E)) continue;
          E === ">" ? Te(w) : L(w, "Invalid characters in closing tag");
          continue;
        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var le, fe;
          switch (w.state) {
            case S.TEXT_ENTITY:
              le = S.TEXT, fe = "textNode";
              break;
            case S.ATTRIB_VALUE_ENTITY_Q:
              le = S.ATTRIB_VALUE_QUOTED, fe = "attribValue";
              break;
            case S.ATTRIB_VALUE_ENTITY_U:
              le = S.ATTRIB_VALUE_UNQUOTED, fe = "attribValue";
              break;
          }
          if (E === ";") if (w.opt.unparsedEntities) {
            var Ae = me(w);
            w.entity = "", w.state = le, w.write(Ae);
          } else
            w[fe] += me(w), w.entity = "", w.state = le;
          else k(w.entity.length ? y : _, E) ? w.entity += E : (L(w, "Invalid character in entity name"), w[fe] += "&" + w.entity + E, w.entity = "", w.state = le);
          continue;
        default:
          throw new Error(w, "Unknown state: " + w.state);
      }
    return w.position >= w.bufferCheckPosition && r(w), w;
  }
  return String.fromCodePoint || (function() {
    var v = String.fromCharCode, w = Math.floor, C = function() {
      var E = 16384, ae = [], ce, le, fe = -1, Ae = arguments.length;
      if (!Ae) return "";
      for (var Oe = ""; ++fe < Ae; ) {
        var Xe = Number(arguments[fe]);
        if (!isFinite(Xe) || Xe < 0 || Xe > 1114111 || w(Xe) !== Xe) throw RangeError("Invalid code point: " + Xe);
        Xe <= 65535 ? ae.push(Xe) : (Xe -= 65536, ce = (Xe >> 10) + 55296, le = Xe % 1024 + 56320, ae.push(ce, le)), (fe + 1 === Ae || ae.length > E) && (Oe += v.apply(null, ae), ae.length = 0);
      }
      return Oe;
    };
    Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
      value: C,
      configurable: !0,
      writable: !0
    }) : String.fromCodePoint = C;
  })(), e;
}, HF = VF(), xp = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
var GF = class extends Kl {
  tags;
  constructor(e) {
    super(e), this.tags = e?.tags;
  }
  static lc_name() {
    return "XMLOutputParser";
  }
  lc_namespace = ["langchain_core", "output_parsers"];
  lc_serializable = !0;
  _diff(e, t) {
    if (t)
      return e ? Nm(e, t) : [{
        op: "replace",
        path: "",
        value: t
      }];
  }
  async parsePartialResult(e) {
    return Ep(e[0].text);
  }
  async parse(e) {
    return Ep(e);
  }
  getFormatInstructions() {
    return !!(this.tags && this.tags.length > 0) ? xp.replace("{tags}", this.tags?.join(", ") ?? "") : xp;
  }
};
const WF = (e) => e.split(`
`).map((t) => t.replace(/^\s+/, "")).join(`
`).trim(), kk = (e) => {
  if (Object.keys(e).length === 0) return {};
  const t = {};
  return e.children.length > 0 ? (t[e.name] = e.children.map(kk), t) : (t[e.name] = e.text ?? void 0, t);
};
function Ep(e) {
  const t = WF(e), n = HF.parser(!0);
  let r = {};
  const s = [];
  n.onopentag = (o) => {
    const u = {
      name: o.name,
      attributes: o.attributes,
      children: [],
      text: "",
      isSelfClosing: o.isSelfClosing
    };
    s.length > 0 ? s[s.length - 1].children.push(u) : r = u, o.isSelfClosing || s.push(u);
  }, n.onclosetag = () => {
    if (s.length > 0) {
      const o = s.pop();
      s.length === 0 && o && (r = o);
    }
  }, n.ontext = (o) => {
    if (s.length > 0) {
      const u = s[s.length - 1];
      u.text += o;
    }
  }, n.onattribute = (o) => {
    if (s.length > 0) {
      const u = s[s.length - 1];
      u.attributes[o.name] = o.value;
    }
  };
  const i = /```(xml)?(.*)```/s.exec(t), a = i ? i[2] : t;
  return n.write(a).close(), r && r.name === "?xml" && (r = r.children[0]), kk(r);
}
var JF = {};
$e(JF, {
  AsymmetricStructuredOutputParser: () => BF,
  BaseCumulativeTransformOutputParser: () => Kl,
  BaseLLMOutputParser: () => Wl,
  BaseOutputParser: () => Jl,
  BaseTransformOutputParser: () => qo,
  BytesOutputParser: () => LF,
  CommaSeparatedListOutputParser: () => DF,
  CustomListOutputParser: () => UF,
  JsonMarkdownStructuredOutputParser: () => Ek,
  JsonOutputParser: () => Ss,
  ListOutputParser: () => Bo,
  MarkdownListOutputParser: () => zF,
  NumberedListOutputParser: () => FF,
  OutputParserException: () => mn,
  StringOutputParser: () => qF,
  StructuredOutputParser: () => bs,
  XMLOutputParser: () => GF,
  XML_FORMAT_INSTRUCTIONS: () => xp,
  parseJsonMarkdown: () => Bh,
  parsePartialJson: () => yl,
  parseXMLMarkdown: () => Ep
});
function Yl(e, t) {
  if (e.function === void 0) return;
  let n;
  if (t?.partial) try {
    n = yl(e.function.arguments ?? "{}");
  } catch {
    return;
  }
  else try {
    n = JSON.parse(e.function.arguments);
  } catch (s) {
    throw new mn([
      `Function "${e.function.name}" arguments:`,
      "",
      e.function.arguments,
      "",
      "are not valid JSON.",
      `Error: ${s.message}`
    ].join(`
`));
  }
  const r = {
    name: e.function.name,
    args: n,
    type: "tool_call"
  };
  return t?.returnId && (r.id = e.id), r;
}
function Ok(e) {
  if (e.id === void 0) throw new Error('All OpenAI tool calls must have an "id" field.');
  return {
    id: e.id,
    type: "function",
    function: {
      name: e.name,
      arguments: JSON.stringify(e.args)
    }
  };
}
function io(e, t) {
  return {
    name: e.function?.name,
    args: e.function?.arguments,
    id: e.id,
    error: t,
    type: "invalid_tool_call"
  };
}
var Ik = class extends Kl {
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  returnId = !1;
  lc_namespace = [
    "langchain",
    "output_parsers",
    "openai_tools"
  ];
  lc_serializable = !0;
  constructor(e) {
    super(e), this.returnId = e?.returnId ?? this.returnId;
  }
  _diff() {
    throw new Error("Not supported.");
  }
  async parse() {
    throw new Error("Not implemented.");
  }
  async parseResult(e) {
    return await this.parsePartialResult(e, !1);
  }
  /**
  * Parses the output and returns a JSON object. If `argsOnly` is true,
  * only the arguments of the function call are returned.
  * @param generations The output of the LLM to parse.
  * @returns A JSON object representation of the function call or its arguments.
  */
  async parsePartialResult(e, t = !0) {
    const n = e[0].message;
    let r;
    if (Dr(n) && n.tool_calls?.length ? r = n.tool_calls.map((i) => {
      const { id: a, ...o } = i;
      return this.returnId ? {
        id: a,
        ...o
      } : o;
    }) : n.additional_kwargs.tool_calls !== void 0 && (r = JSON.parse(JSON.stringify(n.additional_kwargs.tool_calls)).map((a) => Yl(a, {
      returnId: this.returnId,
      partial: t
    }))), !r) return [];
    const s = [];
    for (const i of r) if (i !== void 0) {
      const a = {
        type: i.name,
        args: i.args,
        id: i.id
      };
      s.push(a);
    }
    return s;
  }
}, So = class extends Ik {
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  lc_namespace = [
    "langchain",
    "output_parsers",
    "openai_tools"
  ];
  lc_serializable = !0;
  returnId = !1;
  /** The type of tool calls to return. */
  keyName;
  /** Whether to return only the first tool call. */
  returnSingle = !1;
  zodSchema;
  constructor(e) {
    super(e), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    if (this.zodSchema === void 0) return e;
    const t = await Ul(this.zodSchema, e);
    if (t.success) return t.data;
    throw new mn(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(t.error?.issues)}`, JSON.stringify(e, null, 2));
  }
  async parsePartialResult(e) {
    const n = (await super.parsePartialResult(e)).filter((s) => s.type === this.keyName);
    let r = n;
    if (n.length)
      return this.returnId || (r = n.map((s) => s.args)), this.returnSingle ? r[0] : r;
  }
  async parseResult(e) {
    const n = (await super.parsePartialResult(e, !1)).filter((i) => i.type === this.keyName);
    let r = n;
    return n.length ? (this.returnId || (r = n.map((i) => i.args)), this.returnSingle ? this._validateResult(r[0]) : await Promise.all(r.map((i) => this._validateResult(i)))) : void 0;
  }
}, KF = {};
$e(KF, {
  JsonOutputKeyToolsParser: () => So,
  JsonOutputToolsParser: () => Ik,
  convertLangChainToolCallToOpenAI: () => Ok,
  makeInvalidToolCall: () => io,
  parseToolCall: () => Yl
});
var sg = class extends bi {
  temperature;
  topP;
  frequencyPenalty;
  presencePenalty;
  n;
  logitBias;
  model = "gpt-3.5-turbo";
  modelKwargs;
  stop;
  stopSequences;
  user;
  timeout;
  streaming = !1;
  streamUsage = !0;
  maxTokens;
  logprobs;
  topLogprobs;
  apiKey;
  organization;
  __includeRawResponse;
  /** @internal */
  client;
  /** @internal */
  clientConfig;
  /**
  * Whether the model supports the `strict` argument when passing in tools.
  * If `undefined` the `strict` argument will not be passed to OpenAI.
  */
  supportsStrictToolCalling;
  audio;
  modalities;
  reasoning;
  /**
  * Must be set to `true` in tenancies with Zero Data Retention. Setting to `true` will disable
  * output storage in the Responses API, but this DOES NOT enable Zero Data Retention in your
  * OpenAI organization or project. This must be configured directly with OpenAI.
  *
  * See:
  * https://platform.openai.com/docs/guides/your-data
  * https://platform.openai.com/docs/api-reference/responses/create#responses-create-store
  *
  * @default false
  */
  zdrEnabled;
  /**
  * Service tier to use for this request. Can be "auto", "default", or "flex" or "priority".
  * Specifies the service tier for prioritization and latency optimization.
  */
  service_tier;
  /**
  * Used by OpenAI to cache responses for similar requests to optimize your cache
  * hit rates.
  * [Learn more](https://platform.openai.com/docs/guides/prompt-caching).
  */
  promptCacheKey;
  /**
  * Used by OpenAI to set cache retention time
  */
  promptCacheRetention;
  /**
  * The verbosity of the model's response.
  */
  verbosity;
  defaultOptions;
  _llmType() {
    return "openai";
  }
  static lc_name() {
    return "ChatOpenAI";
  }
  get callKeys() {
    return [
      ...super.callKeys,
      "options",
      "function_call",
      "functions",
      "tools",
      "tool_choice",
      "promptIndex",
      "response_format",
      "seed",
      "reasoning",
      "service_tier"
    ];
  }
  lc_serializable = !0;
  get lc_secrets() {
    return {
      apiKey: "OPENAI_API_KEY",
      organization: "OPENAI_ORGANIZATION"
    };
  }
  get lc_aliases() {
    return {
      apiKey: "openai_api_key",
      modelName: "model"
    };
  }
  get lc_serializable_keys() {
    return [
      "configuration",
      "logprobs",
      "topLogprobs",
      "prefixMessages",
      "supportsStrictToolCalling",
      "modalities",
      "audio",
      "temperature",
      "maxTokens",
      "topP",
      "frequencyPenalty",
      "presencePenalty",
      "n",
      "logitBias",
      "user",
      "streaming",
      "streamUsage",
      "model",
      "modelName",
      "modelKwargs",
      "stop",
      "stopSequences",
      "timeout",
      "apiKey",
      "cache",
      "maxConcurrency",
      "maxRetries",
      "verbose",
      "callbacks",
      "tags",
      "metadata",
      "disableStreaming",
      "zdrEnabled",
      "reasoning",
      "promptCacheKey",
      "promptCacheRetention",
      "verbosity"
    ];
  }
  getLsParams(e) {
    const t = this.invocationParams(e);
    return {
      ls_provider: "openai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: t.temperature ?? void 0,
      ls_max_tokens: t.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams(),
      ...this.clientConfig
    };
  }
  /**
  * Get the identifying parameters for the model
  */
  identifyingParams() {
    return this._identifyingParams();
  }
  constructor(e) {
    super(e ?? {});
    const t = typeof e?.configuration?.apiKey == "string" || typeof e?.configuration?.apiKey == "function" ? e?.configuration?.apiKey : void 0;
    this.apiKey = e?.apiKey ?? t ?? on("OPENAI_API_KEY"), this.organization = e?.configuration?.organization ?? on("OPENAI_ORGANIZATION"), this.model = e?.model ?? e?.modelName ?? this.model, this.modelKwargs = e?.modelKwargs ?? {}, this.timeout = e?.timeout, this.temperature = e?.temperature ?? this.temperature, this.topP = e?.topP ?? this.topP, this.frequencyPenalty = e?.frequencyPenalty ?? this.frequencyPenalty, this.presencePenalty = e?.presencePenalty ?? this.presencePenalty, this.logprobs = e?.logprobs, this.topLogprobs = e?.topLogprobs, this.n = e?.n ?? this.n, this.logitBias = e?.logitBias, this.stop = e?.stopSequences ?? e?.stop, this.stopSequences = this.stop, this.user = e?.user, this.__includeRawResponse = e?.__includeRawResponse, this.audio = e?.audio, this.modalities = e?.modalities, this.reasoning = e?.reasoning, this.maxTokens = e?.maxCompletionTokens ?? e?.maxTokens, this.promptCacheKey = e?.promptCacheKey ?? this.promptCacheKey, this.promptCacheRetention = e?.promptCacheRetention ?? this.promptCacheRetention, this.verbosity = e?.verbosity ?? this.verbosity, this.disableStreaming = e?.disableStreaming === !0, this.streaming = e?.streaming === !0, this.disableStreaming && (this.streaming = !1), e?.streaming === !1 && (this.disableStreaming = !0), this.streamUsage = e?.streamUsage ?? this.streamUsage, this.disableStreaming && (this.streamUsage = !1), this.clientConfig = {
      apiKey: this.apiKey,
      organization: this.organization,
      dangerouslyAllowBrowser: !0,
      ...e?.configuration
    }, e?.supportsStrictToolCalling !== void 0 && (this.supportsStrictToolCalling = e.supportsStrictToolCalling), e?.service_tier !== void 0 && (this.service_tier = e.service_tier), this.zdrEnabled = e?.zdrEnabled ?? !1;
  }
  /**
  * Returns backwards compatible reasoning parameters from constructor params and call options
  * @internal
  */
  _getReasoningParams(e) {
    if (!Fo(this.model)) return;
    let t;
    return this.reasoning !== void 0 && (t = {
      ...t,
      ...this.reasoning
    }), e?.reasoning !== void 0 && (t = {
      ...t,
      ...e.reasoning
    }), t;
  }
  /**
  * Returns an openai compatible response format from a set of options
  * @internal
  */
  _getResponseFormat(e) {
    return e && e.type === "json_schema" && e.json_schema.schema && _t(e.json_schema.schema) ? nF(e.json_schema.schema, e.json_schema.name, { description: e.json_schema.description }) : e;
  }
  _combineCallOptions(e) {
    return {
      ...this.defaultOptions,
      ...e ?? {}
    };
  }
  /** @internal */
  _getClientOptions(e) {
    if (!this.client) {
      const n = { baseURL: this.clientConfig.baseURL }, r = kD(n), s = {
        ...this.clientConfig,
        baseURL: r,
        timeout: this.timeout,
        maxRetries: 0
      };
      s.baseURL || delete s.baseURL, s.defaultHeaders = AD(s.defaultHeaders), this.client = new xe(s);
    }
    return {
      ...this.clientConfig,
      ...e
    };
  }
  _convertChatOpenAIToolToCompletionsTool(e, t) {
    return Qc(e) ? qD(e.metadata.customTool) : vi(e) ? t?.strict !== void 0 ? {
      ...e,
      function: {
        ...e.function,
        strict: t.strict
      }
    } : e : RD(e, t);
  }
  bindTools(e, t) {
    let n;
    return t?.strict !== void 0 ? n = t.strict : this.supportsStrictToolCalling !== void 0 && (n = this.supportsStrictToolCalling), this.withConfig({
      tools: e.map((r) => Qm(r) || Qc(r) ? r : MD(r) ? r.extras.providerToolDefinition : this._convertChatOpenAIToolToCompletionsTool(r, { strict: n })),
      ...t
    });
  }
  async stream(e, t) {
    return super.stream(e, this._combineCallOptions(t));
  }
  async invoke(e, t) {
    return super.invoke(e, this._combineCallOptions(t));
  }
  /** @ignore */
  _combineLLMOutput(...e) {
    return e.reduce((t, n) => (n && n.tokenUsage && (t.tokenUsage.completionTokens += n.tokenUsage.completionTokens ?? 0, t.tokenUsage.promptTokens += n.tokenUsage.promptTokens ?? 0, t.tokenUsage.totalTokens += n.tokenUsage.totalTokens ?? 0), t), { tokenUsage: {
      completionTokens: 0,
      promptTokens: 0,
      totalTokens: 0
    } });
  }
  async getNumTokensFromMessages(e) {
    let t = 0, n = 0, r = 0;
    this.model === "gpt-3.5-turbo-0301" ? (n = 4, r = -1) : (n = 3, r = 1);
    const s = await Promise.all(e.map(async (i) => {
      const a = await this.getNumTokens(i.content), o = await this.getNumTokens(zo(i)), u = i.name !== void 0 ? r + await this.getNumTokens(i.name) : 0;
      let c = a + n + o + u;
      const l = i;
      if (l._getType() === "function" && (c -= 2), l.additional_kwargs?.function_call && (c += 3), l?.additional_kwargs.function_call?.name && (c += await this.getNumTokens(l.additional_kwargs.function_call?.name)), l.additional_kwargs.function_call?.arguments) try {
        c += await this.getNumTokens(JSON.stringify(JSON.parse(l.additional_kwargs.function_call?.arguments)));
      } catch (d) {
        console.error("Error parsing function arguments", d, JSON.stringify(l.additional_kwargs.function_call)), c += await this.getNumTokens(l.additional_kwargs.function_call?.arguments);
      }
      return t += c, c;
    }));
    return t += 3, {
      totalCount: t,
      countPerMessage: s
    };
  }
  /** @internal */
  async _getNumTokensFromGenerations(e) {
    return (await Promise.all(e.map(async (n) => n.message.additional_kwargs?.function_call ? (await this.getNumTokensFromMessages([n.message])).countPerMessage[0] : await this.getNumTokens(n.message.content)))).reduce((n, r) => n + r, 0);
  }
  /** @internal */
  async _getEstimatedTokenCountFromPrompt(e, t, n) {
    let r = (await this.getNumTokensFromMessages(e)).totalCount;
    if (t && n !== "auto") {
      const s = ND(t);
      r += await this.getNumTokens(s), r += 9;
    }
    return t && e.find((s) => s._getType() === "system") && (r -= 4), n === "none" ? r += 1 : typeof n == "object" && (r += await this.getNumTokens(n.name) + 4), r;
  }
  /**
  * Moderate content using OpenAI's Moderation API.
  *
  * This method checks whether content violates OpenAI's content policy by
  * analyzing text for categories such as hate, harassment, self-harm,
  * sexual content, violence, and more.
  *
  * @param input - The text or array of texts to moderate
  * @param params - Optional parameters for the moderation request
  * @param params.model - The moderation model to use. Defaults to "omni-moderation-latest".
  * @param params.options - Additional options to pass to the underlying request
  * @returns A promise that resolves to the moderation response containing results for each input
  *
  * @example
  * ```typescript
  * const model = new ChatOpenAI({ model: "gpt-4o-mini" });
  *
  * // Moderate a single text
  * const result = await model.moderateContent("This is a test message");
  * console.log(result.results[0].flagged); // false
  * console.log(result.results[0].categories); // { hate: false, harassment: false, ... }
  *
  * // Moderate multiple texts
  * const results = await model.moderateContent([
  *   "Hello, how are you?",
  *   "This is inappropriate content"
  * ]);
  * results.results.forEach((result, index) => {
  *   console.log(`Text ${index + 1} flagged:`, result.flagged);
  * });
  *
  * // Use a specific moderation model
  * const stableResult = await model.moderateContent(
  *   "Test content",
  *   { model: "omni-moderation-latest" }
  * );
  * ```
  */
  async moderateContent(e, t) {
    const n = this._getClientOptions(t?.options), r = t?.model ?? "omni-moderation-latest", s = {
      input: e,
      model: r
    };
    return this.caller.call(async () => {
      try {
        return await this.client.moderations.create(s, n);
      } catch (i) {
        throw om(i);
      }
    });
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatOpenAI({ model: "gpt-4o" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 128000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return iF[this.model] ?? {};
  }
  /** @internal */
  _getStructuredOutputMethod(e) {
    const t = { ...e };
    if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
      if (t?.method === void 0) return "jsonSchema";
    } else t.method === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
    return t.method;
  }
  /**
  * Add structured output to the model.
  *
  * The OpenAI model family supports the following structured output methods:
  * - `jsonSchema`: Use the `response_format` field in the response to return a JSON schema. Only supported with the `gpt-4o-mini`,
  *   `gpt-4o-mini-2024-07-18`, and `gpt-4o-2024-08-06` model snapshots and later.
  * - `functionCalling`: Function calling is useful when you are building an application that bridges the models and functionality
  *   of your application.
  * - `jsonMode`: JSON mode is a more basic version of the Structured Outputs feature. While JSON mode ensures that model
  *   output is valid JSON, Structured Outputs reliably matches the model's output to the schema you specify.
  *   We recommend you use `functionCalling` or `jsonSchema` if it is supported for your use case.
  *
  * The default method is `functionCalling`.
  *
  * @see https://platform.openai.com/docs/guides/structured-outputs
  * @param outputSchema - The schema to use for structured output.
  * @param config - The structured output method options.
  * @returns The model with structured output.
  */
  withStructuredOutput(e, t) {
    let n, r;
    const { schema: s, name: i, includeRaw: a } = {
      ...t,
      schema: e
    };
    if (t?.strict !== void 0 && t.method === "jsonMode") throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
    const o = eF(this.model, t?.method);
    if (o === "jsonMode") {
      _t(s) ? r = bs.fromZodSchema(s) : r = new Ss();
      const d = it(s);
      n = this.withConfig({
        outputVersion: "v0",
        response_format: { type: "json_object" },
        ls_structured_output_format: {
          kwargs: { method: "json_mode" },
          schema: {
            title: i ?? "extract",
            ...d
          }
        }
      });
    } else if (o === "jsonSchema") {
      const d = {
        name: i ?? "extract",
        description: zl(s),
        schema: s,
        strict: t?.strict
      }, f = it(d.schema);
      if (n = this.withConfig({
        outputVersion: "v0",
        response_format: {
          type: "json_schema",
          json_schema: d
        },
        ls_structured_output_format: {
          kwargs: { method: "json_schema" },
          schema: {
            title: d.name,
            description: d.description,
            ...f
          }
        }
      }), _t(s)) {
        const h = bs.fromZodSchema(s);
        r = _r.from((p) => "parsed" in p.additional_kwargs ? p.additional_kwargs.parsed : h);
      } else r = new Ss();
    } else {
      let d = i ?? "extract";
      if (_t(s)) {
        const f = it(s);
        n = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: {
              name: d,
              description: f.description,
              parameters: f
            }
          }],
          tool_choice: {
            type: "function",
            function: { name: d }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: d,
              ...f
            }
          },
          ...t?.strict !== void 0 ? { strict: t.strict } : {}
        }), r = new So({
          returnSingle: !0,
          keyName: d,
          zodSchema: s
        });
      } else {
        let f;
        typeof s.name == "string" && typeof s.parameters == "object" && s.parameters != null ? (f = s, d = s.name) : (d = s.title ?? d, f = {
          name: d,
          description: s.description ?? "",
          parameters: s
        });
        const h = it(s);
        n = this.withConfig({
          outputVersion: "v0",
          tools: [{
            type: "function",
            function: f
          }],
          tool_choice: {
            type: "function",
            function: { name: d }
          },
          ls_structured_output_format: {
            kwargs: { method: "function_calling" },
            schema: {
              title: d,
              ...h
            }
          },
          ...t?.strict !== void 0 ? { strict: t.strict } : {}
        }), r = new So({
          returnSingle: !0,
          keyName: d
        });
      }
    }
    if (!a) return n.pipe(r);
    const u = _n.assign({ parsed: (d, f) => r.invoke(d.raw, f) }), c = _n.assign({ parsed: () => null }), l = u.withFallbacks({ fallbacks: [c] });
    return Kr.from([{ raw: n }, l]);
  }
};
const Ak = {
  providerName: "ChatOpenAI",
  fromStandardTextBlock(e) {
    return {
      type: "text",
      text: e.text
    };
  },
  fromStandardImageBlock(e) {
    if (e.source_type === "url") return {
      type: "image_url",
      image_url: {
        url: e.url,
        ...e.metadata?.detail ? { detail: e.metadata.detail } : {}
      }
    };
    if (e.source_type === "base64")
      return {
        type: "image_url",
        image_url: {
          url: `data:${e.mime_type ?? ""};base64,${e.data}`,
          ...e.metadata?.detail ? { detail: e.metadata.detail } : {}
        }
      };
    throw new Error(`Image content blocks with source_type ${e.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardAudioBlock(e) {
    if (e.source_type === "url") {
      const t = Gn({ dataUrl: e.url });
      if (!t) throw new Error(`URL audio blocks with source_type ${e.source_type} must be formatted as a data URL for ChatOpenAI`);
      const n = t.mime_type || e.mime_type || "";
      let r;
      try {
        r = zh(n);
      } catch {
        throw new Error(`Audio blocks with source_type ${e.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (r.type !== "audio" || r.subtype !== "wav" && r.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${e.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: r.subtype,
          data: t.data
        }
      };
    }
    if (e.source_type === "base64") {
      let t;
      try {
        t = zh(e.mime_type ?? "");
      } catch {
        throw new Error(`Audio blocks with source_type ${e.source_type} must have mime type of audio/wav or audio/mp3`);
      }
      if (t.type !== "audio" || t.subtype !== "wav" && t.subtype !== "mp3") throw new Error(`Audio blocks with source_type ${e.source_type} must have mime type of audio/wav or audio/mp3`);
      return {
        type: "input_audio",
        input_audio: {
          format: t.subtype,
          data: e.data
        }
      };
    }
    throw new Error(`Audio content blocks with source_type ${e.source_type} are not supported for ChatOpenAI`);
  },
  fromStandardFileBlock(e) {
    if (e.source_type === "url") {
      const t = Gn({ dataUrl: e.url }), n = Kc(e);
      if (!t) throw new Error(`URL file blocks with source_type ${e.source_type} must be formatted as a data URL for ChatOpenAI`);
      return {
        type: "file",
        file: {
          file_data: e.url,
          ...e.metadata?.filename || e.metadata?.name ? { filename: n } : {}
        }
      };
    }
    if (e.source_type === "base64") {
      const t = Kc(e);
      return {
        type: "file",
        file: {
          file_data: `data:${e.mime_type ?? ""};base64,${e.data}`,
          ...e.metadata?.filename || e.metadata?.name || e.metadata?.title ? { filename: t } : {}
        }
      };
    }
    if (e.source_type === "id") return {
      type: "file",
      file: { file_id: e.id }
    };
    throw new Error(`File content blocks with source_type ${e.source_type} are not supported for ChatOpenAI`);
  }
}, YF = ({ message: e, rawResponse: t, includeRawResponse: n }) => {
  const r = e.tool_calls;
  switch (e.role) {
    case "assistant": {
      const s = [], i = [];
      for (const c of r ?? []) try {
        s.push(Yl(c, { returnId: !0 }));
      } catch (l) {
        i.push(io(c, l.message));
      }
      const a = {
        function_call: e.function_call,
        tool_calls: r
      };
      n !== void 0 && (a.__raw_response = t);
      const o = {
        model_provider: "openai",
        model_name: t.model,
        ...t.system_fingerprint ? {
          usage: { ...t.usage },
          system_fingerprint: t.system_fingerprint
        } : {}
      };
      e.audio && (a.audio = e.audio);
      const u = rF(e.content || "", t.choices?.[0]?.message);
      return new rt({
        content: u,
        tool_calls: s,
        invalid_tool_calls: i,
        additional_kwargs: a,
        response_metadata: o,
        id: t.id
      });
    }
    default:
      return new Hr(e.content || "", e.role ?? "unknown");
  }
}, XF = ({ delta: e, rawResponse: t, includeRawResponse: n, defaultRole: r }) => {
  const s = e.role ?? r, i = e.content ?? "";
  let a;
  e.function_call ? a = { function_call: e.function_call } : e.tool_calls ? a = { tool_calls: e.tool_calls } : a = {}, n && (a.__raw_response = t), e.audio && (a.audio = {
    ...e.audio,
    index: t.choices[0].index
  });
  const o = {
    model_provider: "openai",
    usage: { ...t.usage }
  };
  if (s === "user") return new Mo({
    content: i,
    response_metadata: o
  });
  if (s === "assistant") {
    const u = [];
    if (Array.isArray(e.tool_calls)) for (const c of e.tool_calls) u.push({
      name: c.function?.name,
      args: c.function?.arguments,
      id: c.id,
      index: c.index,
      type: "tool_call_chunk"
    });
    return new We({
      content: i,
      tool_call_chunks: u,
      additional_kwargs: a,
      id: t.id,
      response_metadata: o
    });
  } else return s === "system" ? new Lr({
    content: i,
    response_metadata: o
  }) : s === "developer" ? new Lr({
    content: i,
    response_metadata: o,
    additional_kwargs: { __openai_role__: "developer" }
  }) : s === "function" ? new No({
    content: i,
    additional_kwargs: a,
    name: e.name,
    response_metadata: o
  }) : s === "tool" ? new Ro({
    content: i,
    additional_kwargs: a,
    tool_call_id: e.tool_call_id,
    response_metadata: o
  }) : new Po({
    content: i,
    role: s,
    response_metadata: o
  });
}, QF = (e) => {
  if (e.type === "image") {
    if (e.url) return {
      type: "image_url",
      image_url: { url: e.url }
    };
    if (e.data) return {
      type: "image_url",
      image_url: { url: `data:${e.mimeType};base64,${e.data}` }
    };
  }
  if (e.type === "audio" && e.data) {
    const t = $T(() => {
      const [, n] = e.mimeType.split("/");
      return n === "wav" || n === "mp3" ? n : "wav";
    });
    return {
      type: "input_audio",
      input_audio: {
        data: e.data.toString(),
        format: t
      }
    };
  }
  if (e.type === "file") {
    if (e.data) {
      const t = Kc(e);
      return {
        type: "file",
        file: {
          file_data: `data:${e.mimeType};base64,${e.data}`,
          filename: t
        }
      };
    }
    if (e.fileId) return {
      type: "file",
      file: { file_id: e.fileId }
    };
  }
}, ez = ({ message: e, model: t }) => {
  let n = zo(e);
  if (n === "system" && Fo(t) && (n = "developer"), n === "developer") return {
    role: "developer",
    content: e.contentBlocks.filter((s) => s.type === "text")
  };
  if (n === "system") return {
    role: "system",
    content: e.contentBlocks.filter((s) => s.type === "text")
  };
  if (n === "assistant") return {
    role: "assistant",
    content: e.contentBlocks.filter((s) => s.type === "text")
  };
  if (n === "tool" && Jn.isInstance(e)) return {
    role: "tool",
    tool_call_id: e.tool_call_id,
    content: e.contentBlocks.filter((s) => s.type === "text")
  };
  if (n === "function") return {
    role: "function",
    name: e.name ?? "",
    content: e.contentBlocks.filter((s) => s.type === "text").join("")
  };
  function* r(s) {
    for (const i of s) {
      i.type === "text" && (yield {
        type: "text",
        text: i.text
      });
      const a = QF(i);
      a && (yield a);
    }
  }
  return {
    role: "user",
    content: Array.from(r(e.contentBlocks))
  };
}, s0 = ({ messages: e, model: t }) => e.flatMap((n) => {
  if ("output_version" in n.response_metadata && n.response_metadata?.output_version === "v1") return ez({ message: n });
  let r = zo(n);
  r === "system" && Fo(t) && (r = "developer");
  const s = typeof n.content == "string" ? n.content : n.content.map((a) => gn(a) ? Co(a, Ak) : a), i = {
    role: r,
    content: s
  };
  if (n.name != null && (i.name = n.name), n.additional_kwargs.function_call != null && (i.function_call = n.additional_kwargs.function_call), rt.isInstance(n) && n.tool_calls?.length ? i.tool_calls = n.tool_calls.map(Ok) : (n.additional_kwargs.tool_calls != null && (i.tool_calls = n.additional_kwargs.tool_calls), Jn.isInstance(n) && n.tool_call_id != null && (i.tool_call_id = n.tool_call_id)), n.additional_kwargs.audio && typeof n.additional_kwargs.audio == "object" && "id" in n.additional_kwargs.audio) {
    const a = {
      role: "assistant",
      audio: { id: n.additional_kwargs.audio.id }
    };
    return [i, a];
  }
  return i;
});
var tz = class extends sg {
  /** @internal */
  invocationParams(e, t) {
    let n;
    e?.strict !== void 0 ? n = e.strict : this.supportsStrictToolCalling !== void 0 && (n = this.supportsStrictToolCalling);
    let r = {};
    e?.stream_options !== void 0 ? r = { stream_options: e.stream_options } : this.streamUsage && (this.streaming || t?.streaming) && (r = { stream_options: { include_usage: !0 } });
    const s = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      frequency_penalty: this.frequencyPenalty,
      presence_penalty: this.presencePenalty,
      logprobs: this.logprobs,
      top_logprobs: this.topLogprobs,
      n: this.n,
      logit_bias: this.logitBias,
      stop: e?.stop ?? this.stopSequences,
      user: this.user,
      stream: this.streaming,
      functions: e?.functions,
      function_call: e?.function_call,
      tools: e?.tools?.length ? e.tools.map((a) => this._convertChatOpenAIToolToCompletionsTool(a, { strict: n })) : void 0,
      tool_choice: nk(e?.tool_choice),
      response_format: this._getResponseFormat(e?.response_format),
      seed: e?.seed,
      ...r,
      parallel_tool_calls: e?.parallel_tool_calls,
      ...this.audio || e?.audio ? { audio: this.audio || e?.audio } : {},
      ...this.modalities || e?.modalities ? { modalities: this.modalities || e?.modalities } : {},
      ...this.modelKwargs,
      prompt_cache_key: e?.promptCacheKey ?? this.promptCacheKey,
      prompt_cache_retention: e?.promptCacheRetention ?? this.promptCacheRetention,
      verbosity: e?.verbosity ?? this.verbosity
    };
    e?.prediction !== void 0 && (s.prediction = e.prediction), this.service_tier !== void 0 && (s.service_tier = this.service_tier), e?.service_tier !== void 0 && (s.service_tier = e.service_tier);
    const i = this._getReasoningParams(e);
    return i !== void 0 && i.effort !== void 0 && (s.reasoning_effort = i.effort), Fo(s.model) ? s.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens : s.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens, s;
  }
  async _generate(e, t, n) {
    const r = {}, s = this.invocationParams(t), i = s0({
      messages: e,
      model: this.model
    });
    if (s.stream) {
      const a = this._streamResponseChunks(e, t, n), o = {};
      for await (const h of a) {
        h.message.response_metadata = {
          ...h.generationInfo,
          ...h.message.response_metadata
        };
        const p = h.generationInfo?.completion ?? 0;
        o[p] === void 0 ? o[p] = h : o[p] = o[p].concat(h);
      }
      const u = Object.entries(o).sort(([h], [p]) => parseInt(h, 10) - parseInt(p, 10)).map(([h, p]) => p), { functions: c, function_call: l } = this.invocationParams(t), d = await this._getEstimatedTokenCountFromPrompt(e, c, l), f = await this._getNumTokensFromGenerations(u);
      return r.input_tokens = d, r.output_tokens = f, r.total_tokens = d + f, {
        generations: u,
        llmOutput: { estimatedTokenUsage: {
          promptTokens: r.input_tokens,
          completionTokens: r.output_tokens,
          totalTokens: r.total_tokens
        } }
      };
    } else {
      const a = await this.completionWithRetry({
        ...s,
        stream: !1,
        messages: i
      }, {
        signal: t?.signal,
        ...t?.options
      }), { completion_tokens: o, prompt_tokens: u, total_tokens: c, prompt_tokens_details: l, completion_tokens_details: d } = a?.usage ?? {};
      o && (r.output_tokens = (r.output_tokens ?? 0) + o), u && (r.input_tokens = (r.input_tokens ?? 0) + u), c && (r.total_tokens = (r.total_tokens ?? 0) + c), (l?.audio_tokens !== null || l?.cached_tokens !== null) && (r.input_token_details = {
        ...l?.audio_tokens !== null && { audio: l?.audio_tokens },
        ...l?.cached_tokens !== null && { cache_read: l?.cached_tokens }
      }), (d?.audio_tokens !== null || d?.reasoning_tokens !== null) && (r.output_token_details = {
        ...d?.audio_tokens !== null && { audio: d?.audio_tokens },
        ...d?.reasoning_tokens !== null && { reasoning: d?.reasoning_tokens }
      });
      const f = [];
      for (const h of a?.choices ?? []) {
        const g = {
          text: h.message?.content ?? "",
          message: this._convertCompletionsMessageToBaseMessage(h.message ?? { role: "assistant" }, a)
        };
        g.generationInfo = {
          ...h.finish_reason ? { finish_reason: h.finish_reason } : {},
          ...h.logprobs ? { logprobs: h.logprobs } : {}
        }, Dr(g.message) && (g.message.usage_metadata = r), g.message = new rt(Object.fromEntries(Object.entries(g.message).filter(([m]) => !m.startsWith("lc_")))), f.push(g);
      }
      return {
        generations: f,
        llmOutput: { tokenUsage: {
          promptTokens: r.input_tokens,
          completionTokens: r.output_tokens,
          totalTokens: r.total_tokens
        } }
      };
    }
  }
  async *_streamResponseChunks(e, t, n) {
    const r = s0({
      messages: e,
      model: this.model
    }), s = {
      ...this.invocationParams(t, { streaming: !0 }),
      messages: r,
      stream: !0
    };
    let i;
    const a = await this.completionWithRetry(s, t);
    let o;
    for await (const u of a) {
      const c = u?.choices?.[0];
      if (u.usage && (o = u.usage), !c) continue;
      const { delta: l } = c;
      if (!l) continue;
      const d = this._convertCompletionsDeltaToBaseMessageChunk(l, u, i);
      i = l.role ?? i;
      const f = {
        prompt: t.promptIndex ?? 0,
        completion: c.index ?? 0
      };
      if (typeof d.content != "string") {
        console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
        continue;
      }
      const h = { ...f };
      c.finish_reason != null && (h.finish_reason = c.finish_reason, h.system_fingerprint = u.system_fingerprint, h.model_name = u.model, h.service_tier = u.service_tier), this.logprobs && (h.logprobs = c.logprobs);
      const p = new Xn({
        message: d,
        text: d.content,
        generationInfo: h
      });
      yield p, await n?.handleLLMNewToken(p.text ?? "", f, void 0, void 0, void 0, { chunk: p });
    }
    if (o) {
      const u = {
        ...o.prompt_tokens_details?.audio_tokens !== null && { audio: o.prompt_tokens_details?.audio_tokens },
        ...o.prompt_tokens_details?.cached_tokens !== null && { cache_read: o.prompt_tokens_details?.cached_tokens }
      }, c = {
        ...o.completion_tokens_details?.audio_tokens !== null && { audio: o.completion_tokens_details?.audio_tokens },
        ...o.completion_tokens_details?.reasoning_tokens !== null && { reasoning: o.completion_tokens_details?.reasoning_tokens }
      };
      yield new Xn({
        message: new We({
          content: "",
          response_metadata: { usage: { ...o } },
          usage_metadata: {
            input_tokens: o.prompt_tokens,
            output_tokens: o.completion_tokens,
            total_tokens: o.total_tokens,
            ...Object.keys(u).length > 0 && { input_token_details: u },
            ...Object.keys(c).length > 0 && { output_token_details: c }
          }
        }),
        text: ""
      });
    }
    if (t.signal?.aborted) throw new Error("AbortError");
  }
  async completionWithRetry(e, t) {
    const n = this._getClientOptions(t), r = e.response_format && e.response_format.type === "json_schema";
    return this.caller.call(async () => {
      try {
        return r && !e.stream ? await this.client.chat.completions.parse(e, n) : await this.client.chat.completions.create(e, n);
      } catch (s) {
        throw om(s);
      }
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsDeltaToBaseMessageChunk(e, t, n) {
    return XF({
      delta: e,
      rawResponse: t,
      includeRawResponse: this.__includeRawResponse,
      defaultRole: n
    });
  }
  /**
  * @deprecated
  * This function was hoisted into a publicly accessible function from a
  * different export, but to maintain backwards compatibility with chat models
  * that depend on ChatOpenAICompletions, we'll keep it here as an overridable
  * method. This will be removed in a future release
  */
  _convertCompletionsMessageToBaseMessage(e, t) {
    return YF({
      message: e,
      rawResponse: t,
      includeRawResponse: this.__includeRawResponse
    });
  }
};
const nl = "__openai_function_call_ids__", Ck = (e) => {
  const t = { ...e?.input_tokens_details?.cached_tokens != null && { cache_read: e?.input_tokens_details?.cached_tokens } }, n = { ...e?.output_tokens_details?.reasoning_tokens != null && { reasoning: e?.output_tokens_details?.reasoning_tokens } };
  return {
    input_tokens: e?.input_tokens ?? 0,
    output_tokens: e?.output_tokens ?? 0,
    total_tokens: e?.total_tokens ?? 0,
    input_token_details: t,
    output_token_details: n
  };
}, $k = (e) => {
  if (e.error) {
    const o = new Error(e.error.message);
    throw o.name = e.error.code, o;
  }
  let t;
  const n = [], r = [], s = [], i = {
    model_provider: "openai",
    model: e.model,
    created_at: e.created_at,
    id: e.id,
    incomplete_details: e.incomplete_details,
    metadata: e.metadata,
    object: e.object,
    status: e.status,
    user: e.user,
    service_tier: e.service_tier,
    model_name: e.model
  }, a = {};
  for (const o of e.output) if (o.type === "message")
    t = o.id, n.push(...o.content.flatMap((u) => u.type === "output_text" ? ("parsed" in u && u.parsed != null && (a.parsed = u.parsed), {
      type: "text",
      text: u.text,
      annotations: u.annotations
    }) : u.type === "refusal" ? (a.refusal = u.refusal, []) : u));
  else if (o.type === "function_call") {
    const u = {
      function: {
        name: o.name,
        arguments: o.arguments
      },
      id: o.call_id
    };
    try {
      r.push(Yl(u, { returnId: !0 }));
    } catch (c) {
      let l;
      typeof c == "object" && c != null && "message" in c && typeof c.message == "string" && (l = c.message), s.push(io(u, l));
    }
    a[nl] ??= {}, o.id && (a[nl][o.call_id] = o.id);
  } else if (o.type === "reasoning") a.reasoning = o;
  else if (o.type === "custom_tool_call") {
    const u = LD(o);
    u ? r.push(u) : s.push(io(o, "Malformed custom tool call"));
  } else if (o.type === "computer_call") {
    const u = DD(o);
    u ? r.push(u) : s.push(io(o, "Malformed computer call"));
  } else
    a.tool_outputs ??= [], a.tool_outputs.push(o);
  return new rt({
    id: t,
    content: n,
    tool_calls: r,
    invalid_tool_calls: s,
    usage_metadata: Ck(e.usage),
    additional_kwargs: a,
    response_metadata: i
  });
}, nz = (e) => {
  const t = (e.summary.length > 1 ? e.summary.reduce((n, r) => {
    const s = n[n.length - 1];
    return s.index === r.index ? s.text += r.text : n.push(r), n;
  }, [{ ...e.summary[0] }]) : e.summary).map((n) => Object.fromEntries(Object.entries(n).filter(([r]) => r !== "index")));
  return {
    ...e,
    summary: t
  };
}, rz = (e) => {
  const t = [];
  let n = {}, r;
  const s = [], i = { model_provider: "openai" }, a = {};
  let o;
  if (e.type === "response.output_text.delta") t.push({
    type: "text",
    text: e.delta,
    index: e.content_index
  });
  else if (e.type === "response.output_text.annotation.added") t.push({
    type: "text",
    text: "",
    annotations: [e.annotation],
    index: e.content_index
  });
  else if (e.type === "response.output_item.added" && e.item.type === "message") o = e.item.id;
  else if (e.type === "response.output_item.added" && e.item.type === "function_call")
    s.push({
      type: "tool_call_chunk",
      name: e.item.name,
      args: e.item.arguments,
      id: e.item.call_id,
      index: e.output_index
    }), a[nl] = { [e.item.call_id]: e.item.id };
  else if (e.type === "response.output_item.done" && e.item.type === "computer_call")
    s.push({
      type: "tool_call_chunk",
      name: "computer_use",
      args: JSON.stringify({ action: e.item.action }),
      id: e.item.call_id,
      index: e.output_index
    }), a.tool_outputs = [e.item];
  else if (e.type === "response.output_item.done" && [
    "web_search_call",
    "file_search_call",
    "code_interpreter_call",
    "mcp_call",
    "mcp_list_tools",
    "mcp_approval_request",
    "image_generation_call",
    "custom_tool_call"
  ].includes(e.item.type)) a.tool_outputs = [e.item];
  else if (e.type === "response.created")
    i.id = e.response.id, i.model_name = e.response.model, i.model = e.response.model;
  else if (e.type === "response.completed") {
    const u = $k(e.response);
    r = Ck(e.response.usage), e.response.text?.format?.type === "json_schema" && (a.parsed ??= JSON.parse(u.text));
    for (const [c, l] of Object.entries(e.response)) c !== "id" && (i[c] = l);
  } else if (e.type === "response.function_call_arguments.delta" || e.type === "response.custom_tool_call_input.delta") s.push({
    type: "tool_call_chunk",
    args: e.delta,
    index: e.output_index
  });
  else if (e.type === "response.web_search_call.completed" || e.type === "response.file_search_call.completed") n = { tool_outputs: {
    id: e.item_id,
    type: e.type.replace("response.", "").replace(".completed", ""),
    status: "completed"
  } };
  else if (e.type === "response.refusal.done") a.refusal = e.refusal;
  else if (e.type === "response.output_item.added" && "item" in e && e.item.type === "reasoning") {
    const u = e.item.summary ? e.item.summary.map((c, l) => ({
      ...c,
      index: l
    })) : void 0;
    a.reasoning = {
      id: e.item.id,
      type: e.item.type,
      ...u ? { summary: u } : {}
    };
  } else if (e.type === "response.reasoning_summary_part.added") a.reasoning = {
    type: "reasoning",
    summary: [{
      ...e.part,
      index: e.summary_index
    }]
  };
  else if (e.type === "response.reasoning_summary_text.delta") a.reasoning = {
    type: "reasoning",
    summary: [{
      text: e.delta,
      type: "summary_text",
      index: e.summary_index
    }]
  };
  else return e.type === "response.image_generation_call.partial_image", null;
  return new Xn({
    text: t.map((u) => u.text).join(""),
    message: new We({
      id: o,
      content: t,
      tool_call_chunks: s,
      usage_metadata: r,
      additional_kwargs: a,
      response_metadata: i
    }),
    generationInfo: n
  });
}, sz = (e) => {
  const t = rt.isInstance(e) && e.response_metadata?.model_provider === "openai";
  function* n() {
    const r = ys(() => {
      try {
        const _ = zo(e);
        return _ === "system" || _ === "developer" || _ === "assistant" || _ === "user" ? _ : "assistant";
      } catch {
        return "assistant";
      }
    });
    let s;
    const i = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
    function* c() {
      if (!s) return;
      const _ = s.content;
      (typeof _ == "string" && _.length > 0 || Array.isArray(_) && _.length > 0) && (yield s), s = void 0;
    }
    const l = (_) => {
      s || (s = {
        type: "message",
        role: r,
        content: []
      }), typeof s.content == "string" ? s.content = s.content.length > 0 ? [{
        type: "input_text",
        text: s.content
      }, ..._] : [..._] : s.content.push(..._);
    }, d = (_) => {
      if (typeof _ == "string") return _;
      try {
        return JSON.stringify(_ ?? {});
      } catch {
        return "{}";
      }
    }, f = (_) => {
      const y = ys(() => {
        const b = _.metadata?.detail;
        return b === "low" || b === "high" || b === "auto" ? b : "auto";
      });
      if (_.fileId) return {
        type: "input_image",
        detail: y,
        file_id: _.fileId
      };
      if (_.url) return {
        type: "input_image",
        detail: y,
        image_url: _.url
      };
      if (_.data) {
        const b = typeof _.data == "string" ? _.data : Buffer.from(_.data).toString("base64"), T = _.mimeType ?? "image/png";
        return {
          type: "input_image",
          detail: y,
          image_url: `data:${T};base64,${b}`
        };
      }
    }, h = (_) => {
      const y = Kc(_);
      if (_.fileId && typeof y == "string") return {
        type: "input_file",
        file_id: _.fileId,
        ...y ? { filename: y } : {}
      };
      if (_.url && typeof y == "string") return {
        type: "input_file",
        file_url: _.url,
        ...y ? { filename: y } : {}
      };
      if (_.data && typeof y == "string") {
        const b = typeof _.data == "string" ? _.data : Buffer.from(_.data).toString("base64");
        return {
          type: "input_file",
          file_data: `data:${_.mimeType ?? "application/octet-stream"};base64,${b}`,
          ...y ? { filename: y } : {}
        };
      }
    }, p = (_) => {
      const y = ys(() => {
        if (Array.isArray(_.summary)) {
          const k = _.summary?.map((O) => O?.text).filter((O) => typeof O == "string") ?? [];
          if (k.length > 0) return k;
        }
        return _.reasoning ? [_.reasoning] : [];
      }), b = y.length > 0 ? y.map((x) => ({
        type: "summary_text",
        text: x
      })) : [{
        type: "summary_text",
        text: ""
      }], T = {
        type: "reasoning",
        id: _.id ?? "",
        summary: b
      };
      return _.reasoning && (T.content = [{
        type: "reasoning_text",
        text: _.reasoning
      }]), T;
    }, g = (_) => ({
      type: "function_call",
      name: _.name ?? "",
      call_id: _.id ?? "",
      arguments: d(_.args)
    }), m = (_) => {
      const y = d(_.output), b = _.status === "success" ? "completed" : _.status === "error" ? "incomplete" : void 0;
      return {
        type: "function_call_output",
        call_id: _.toolCallId ?? "",
        output: y,
        ...b ? { status: b } : {}
      };
    };
    for (const _ of e.contentBlocks) if (_.type === "text") l([{
      type: "input_text",
      text: _.text
    }]);
    else if (_.type !== "invalid_tool_call") {
      if (_.type === "reasoning")
        yield* c(), yield p(_);
      else if (_.type === "tool_call") {
        yield* c();
        const y = _.id ?? "";
        y && (i.add(y), o.delete(y)), yield g(_);
      } else if (_.type === "tool_call_chunk") {
        if (_.id) {
          const y = o.get(_.id) ?? {
            name: _.name,
            args: []
          };
          _.name && (y.name = _.name), _.args && y.args.push(_.args), o.set(_.id, y);
        }
      } else if (_.type === "server_tool_call") {
        yield* c();
        const y = _.id ?? "";
        y && (a.add(y), u.delete(y)), yield g(_);
      } else if (_.type === "server_tool_call_chunk") {
        if (_.id) {
          const y = u.get(_.id) ?? {
            name: _.name,
            args: []
          };
          _.name && (y.name = _.name), _.args && y.args.push(_.args), u.set(_.id, y);
        }
      } else if (_.type === "server_tool_call_result")
        yield* c(), yield m(_);
      else if (_.type !== "audio") if (_.type === "file") {
        const y = h(_);
        y && l([y]);
      } else if (_.type === "image") {
        const y = f(_);
        y && l([y]);
      } else if (_.type === "video") {
        const y = h(_);
        y && l([y]);
      } else _.type === "text-plain" ? _.text && l([{
        type: "input_text",
        text: _.text
      }]) : _.type === "non_standard" && t && (yield* c(), yield _.value);
    }
    yield* c();
    for (const [_, y] of o) {
      if (!_ || i.has(_)) continue;
      const b = y.args.join("");
      !y.name && !b || (yield {
        type: "function_call",
        call_id: _,
        name: y.name ?? "",
        arguments: b
      });
    }
    for (const [_, y] of u) {
      if (!_ || a.has(_)) continue;
      const b = y.args.join("");
      !y.name && !b || (yield {
        type: "function_call",
        call_id: _,
        name: y.name ?? "",
        arguments: b
      });
    }
  }
  return Array.from(n());
}, i0 = ({ messages: e, zdrEnabled: t, model: n }) => e.flatMap((r) => {
  const s = r.response_metadata;
  if (s?.output_version === "v1") return sz(r);
  const i = r.additional_kwargs;
  let a = zo(r);
  if (a === "system" && Fo(n) && (a = "developer"), a === "function") throw new Error("Function messages are not supported in Responses API");
  if (a === "tool") {
    const o = r;
    if (i?.type === "computer_call_output")
      return {
        type: "computer_call_output",
        output: (() => {
          if (typeof o.content == "string") return {
            type: "input_image",
            image_url: o.content
          };
          if (Array.isArray(o.content)) {
            const l = o.content.find((h) => h.type === "input_image");
            if (l) return l;
            const d = o.content.find((h) => h.type === "computer_screenshot");
            if (d) return d;
            const f = o.content.find((h) => h.type === "image_url");
            if (f) return {
              type: "input_image",
              image_url: typeof f.image_url == "string" ? f.image_url : f.image_url.url
            };
          }
          throw new Error("Invalid computer call output");
        })(),
        call_id: o.tool_call_id
      };
    if (o.additional_kwargs?.customTool) return {
      type: "custom_tool_call_output",
      call_id: o.tool_call_id,
      output: o.content
    };
    const u = Array.isArray(o.content) && o.content.every((c) => typeof c == "object" && c !== null && "type" in c && (c.type === "input_file" || c.type === "input_image" || c.type === "input_text"));
    return {
      type: "function_call_output",
      call_id: o.tool_call_id,
      id: o.id?.startsWith("fc_") ? o.id : void 0,
      output: u ? o.content : typeof o.content != "string" ? JSON.stringify(o.content) : o.content
    };
  }
  if (a === "assistant") {
    if (!t && s?.output != null && Array.isArray(s?.output) && s?.output.length > 0 && s?.output.every((f) => "type" in f)) return s?.output;
    const o = [];
    if (i?.reasoning && !t) {
      const f = nz(i.reasoning);
      o.push(f);
    }
    let { content: u } = r;
    i?.refusal && (typeof u == "string" && (u = [{
      type: "output_text",
      text: u,
      annotations: []
    }]), u = [...u, {
      type: "refusal",
      refusal: i.refusal
    }]), (typeof u == "string" || u.length > 0) && o.push({
      type: "message",
      role: "assistant",
      ...r.id && !t && r.id.startsWith("msg_") ? { id: r.id } : {},
      content: ys(() => typeof u == "string" ? u : u.flatMap((f) => f.type === "text" ? {
        type: "output_text",
        text: f.text,
        annotations: f.annotations ?? []
      } : f.type === "output_text" || f.type === "refusal" ? f : []))
    });
    const c = i?.[nl];
    rt.isInstance(r) && r.tool_calls?.length ? o.push(...r.tool_calls.map((f) => FD(f) ? {
      type: "custom_tool_call",
      id: f.call_id,
      call_id: f.id ?? "",
      input: f.args.input,
      name: f.name
    } : UD(f) ? {
      type: "computer_call",
      id: f.call_id,
      call_id: f.id ?? "",
      action: f.args.action
    } : {
      type: "function_call",
      name: f.name,
      arguments: JSON.stringify(f.args),
      call_id: f.id,
      ...t ? {} : { id: c?.[f.id] }
    })) : i?.tool_calls && o.push(...i.tool_calls.map((f) => ({
      type: "function_call",
      name: f.function.name,
      call_id: f.id,
      arguments: f.function.arguments,
      ...t ? {} : { id: c?.[f.id] }
    })));
    const l = s?.output?.length ? s?.output : i.tool_outputs, d = [
      "computer_call",
      "mcp_call",
      "code_interpreter_call",
      "image_generation_call"
    ];
    if (l != null) {
      const h = l?.filter((p) => d.includes(p.type));
      h.length > 0 && o.push(...h);
    }
    return o;
  }
  if (a === "user" || a === "system" || a === "developer") {
    if (typeof r.content == "string") return {
      type: "message",
      role: a,
      content: r.content
    };
    const o = [], u = r.content.flatMap((c) => {
      if (c.type === "mcp_approval_response" && o.push({
        type: "mcp_approval_response",
        approval_request_id: c.approval_request_id,
        approve: c.approve
      }), gn(c)) return Co(c, Ak);
      if (c.type === "text") return {
        type: "input_text",
        text: c.text
      };
      if (c.type === "image_url") {
        const l = ys(() => {
          if (typeof c.image_url == "string") return c.image_url;
          if (typeof c.image_url == "object" && c.image_url !== null && "url" in c.image_url) return c.image_url.url;
        }), d = ys(() => {
          if (typeof c.image_url == "string") return "auto";
          if (typeof c.image_url == "object" && c.image_url !== null && "detail" in c.image_url) return c.image_url.detail;
        });
        return {
          type: "input_image",
          image_url: l,
          detail: d
        };
      }
      return c.type === "input_text" || c.type === "input_image" || c.type === "input_file" ? c : [];
    });
    return u.length > 0 && o.push({
      type: "message",
      role: a,
      content: u
    }), o;
  }
  return console.warn(`Unsupported role found when converting to OpenAI Responses API: ${a}`), [];
});
var iz = class extends sg {
  invocationParams(e) {
    let t;
    e?.strict !== void 0 && (t = e.strict), t === void 0 && this.supportsStrictToolCalling !== void 0 && (t = this.supportsStrictToolCalling);
    const n = {
      model: this.model,
      temperature: this.temperature,
      top_p: this.topP,
      user: this.user,
      stream: this.streaming,
      previous_response_id: e?.previous_response_id,
      truncation: e?.truncation,
      include: e?.include,
      tools: e?.tools?.length ? this._reduceChatOpenAITools(e.tools, {
        stream: this.streaming,
        strict: t
      }) : void 0,
      tool_choice: jD(e?.tool_choice) ? e?.tool_choice : (() => {
        const s = nk(e?.tool_choice);
        if (typeof s == "object" && "type" in s) {
          if (s.type === "function") return {
            type: "function",
            name: s.function.name
          };
          if (s.type === "allowed_tools") return {
            type: "allowed_tools",
            mode: s.allowed_tools.mode,
            tools: s.allowed_tools.tools
          };
          if (s.type === "custom") return {
            type: "custom",
            name: s.custom.name
          };
        }
      })(),
      text: (() => {
        if (e?.text) return e.text;
        const s = this._getResponseFormat(e?.response_format);
        return s?.type === "json_schema" ? s.json_schema.schema != null ? {
          format: {
            type: "json_schema",
            schema: s.json_schema.schema,
            description: s.json_schema.description,
            name: s.json_schema.name,
            strict: s.json_schema.strict
          },
          verbosity: e?.verbosity
        } : void 0 : {
          format: s,
          verbosity: e?.verbosity
        };
      })(),
      parallel_tool_calls: e?.parallel_tool_calls,
      max_output_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
      prompt_cache_key: e?.promptCacheKey ?? this.promptCacheKey,
      prompt_cache_retention: e?.promptCacheRetention ?? this.promptCacheRetention,
      ...this.zdrEnabled ? { store: !1 } : {},
      ...this.modelKwargs
    }, r = this._getReasoningParams(e);
    return r !== void 0 && (n.reasoning = r), n;
  }
  async _generate(e, t, n) {
    const r = this.invocationParams(t);
    if (r.stream) {
      const s = this._streamResponseChunks(e, t, n);
      let i;
      for await (const a of s)
        a.message.response_metadata = {
          ...a.generationInfo,
          ...a.message.response_metadata
        }, i = i?.concat(a) ?? a;
      return {
        generations: i ? [i] : [],
        llmOutput: { estimatedTokenUsage: i?.message?.usage_metadata }
      };
    } else {
      const s = await this.completionWithRetry({
        input: i0({
          messages: e,
          zdrEnabled: this.zdrEnabled ?? !1,
          model: this.model
        }),
        ...r,
        stream: !1
      }, {
        signal: t?.signal,
        ...t?.options
      });
      return {
        generations: [{
          text: s.output_text,
          message: $k(s)
        }],
        llmOutput: {
          id: s.id,
          estimatedTokenUsage: s.usage ? {
            promptTokens: s.usage.input_tokens,
            completionTokens: s.usage.output_tokens,
            totalTokens: s.usage.total_tokens
          } : void 0
        }
      };
    }
  }
  async *_streamResponseChunks(e, t, n) {
    const r = await this.completionWithRetry({
      ...this.invocationParams(t),
      input: i0({
        messages: e,
        zdrEnabled: this.zdrEnabled ?? !1,
        model: this.model
      }),
      stream: !0
    }, t);
    for await (const s of r) {
      const i = rz(s);
      i != null && (yield i, await n?.handleLLMNewToken(i.text || "", {
        prompt: t.promptIndex ?? 0,
        completion: 0
      }, void 0, void 0, void 0, { chunk: i }));
    }
  }
  async completionWithRetry(e, t) {
    return this.caller.call(async () => {
      const n = this._getClientOptions(t);
      try {
        return e.text?.format?.type === "json_schema" && !e.stream ? await this.client.responses.parse(e, n) : await this.client.responses.create(e, n);
      } catch (r) {
        throw om(r);
      }
    });
  }
  /** @internal */
  _reduceChatOpenAITools(e, t) {
    const n = [];
    for (const r of e) if (Qm(r))
      r.type === "image_generation" && t?.stream && (r.partial_images = 1), n.push(r);
    else if (Qc(r)) {
      const s = r.metadata.customTool;
      n.push({
        type: "custom",
        name: s.name,
        description: s.description,
        format: s.format
      });
    } else vi(r) ? n.push({
      type: "function",
      name: r.function.name,
      parameters: r.function.parameters,
      description: r.function.description,
      strict: t?.strict ?? null
    }) : rk(r) && n.push(zD(r));
    return n;
  }
}, az = class Rk extends sg {
  /**
  * Whether to use the responses API for all requests. If `false` the responses API will be used
  * only when required in order to fulfill the request.
  */
  useResponsesApi = !1;
  responses;
  completions;
  get lc_serializable_keys() {
    return [...super.lc_serializable_keys, "useResponsesApi"];
  }
  get callKeys() {
    return [...super.callKeys, "useResponsesApi"];
  }
  constructor(t) {
    super(t), this.fields = t, this.useResponsesApi = t?.useResponsesApi ?? !1, this.responses = t?.responses ?? new iz(t), this.completions = t?.completions ?? new tz(t);
  }
  _useResponsesApi(t) {
    const n = t?.tools?.some(Qm), r = t?.previous_response_id != null || t?.text != null || t?.truncation != null || t?.include != null || t?.reasoning?.summary != null || this.reasoning?.summary != null, s = t?.tools?.some(rk) || t?.tools?.some(Qc);
    return this.useResponsesApi || n || r || s || ED(this.model);
  }
  getLsParams(t) {
    const n = this._combineCallOptions(t);
    return this._useResponsesApi(t) ? this.responses.getLsParams(n) : this.completions.getLsParams(n);
  }
  invocationParams(t) {
    const n = this._combineCallOptions(t);
    return this._useResponsesApi(t) ? this.responses.invocationParams(n) : this.completions.invocationParams(n);
  }
  /** @ignore */
  async _generate(t, n, r) {
    return this._useResponsesApi(n) ? this.responses._generate(t, n) : this.completions._generate(t, n, r);
  }
  async *_streamResponseChunks(t, n, r) {
    if (this._useResponsesApi(n)) {
      yield* this.responses._streamResponseChunks(t, this._combineCallOptions(n), r);
      return;
    }
    yield* this.completions._streamResponseChunks(t, this._combineCallOptions(n), r);
  }
  withConfig(t) {
    const n = new Rk(this.fields);
    return n.defaultOptions = {
      ...this.defaultOptions,
      ...t
    }, n;
  }
}, oz = {};
$e(oz, {
  BaseLLM: () => Pk,
  LLM: () => uz
});
var Pk = class Wa extends rg {
  lc_namespace = [
    "langchain",
    "llms",
    this._llmType()
  ];
  /**
  * This method takes an input and options, and returns a string. It
  * converts the input to a prompt value and generates a result based on
  * the prompt.
  * @param input Input for the LLM.
  * @param options Options for the LLM call.
  * @returns A string result based on the prompt.
  */
  async invoke(t, n) {
    const r = Wa._convertInputToPromptValue(t);
    return (await this.generatePrompt([r], n, n?.callbacks)).generations[0][0].text;
  }
  async *_streamResponseChunks(t, n, r) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptionsCompat(t) {
    const [n, r] = super._separateRunnableConfigFromCallOptions(t);
    return r.signal = n.signal, [n, r];
  }
  async *_streamIterator(t, n) {
    if (this._streamResponseChunks === Wa.prototype._streamResponseChunks) yield this.invoke(t, n);
    else {
      const r = Wa._convertInputToPromptValue(t), [s, i] = this._separateRunnableConfigFromCallOptionsCompat(n), a = await Vt.configure(s.callbacks, this.callbacks, s.tags, this.tags, s.metadata, this.metadata, { verbose: this.verbose }), o = {
        options: i,
        invocation_params: this?.invocationParams(i),
        batch_size: 1
      }, u = await a?.handleLLMStart(this.toJSON(), [r.toString()], s.runId, void 0, o, void 0, void 0, s.runName);
      let c = new ii({ text: "" });
      try {
        for await (const l of this._streamResponseChunks(r.toString(), i, u?.[0]))
          c ? c = c.concat(l) : c = l, typeof l.text == "string" && (yield l.text);
      } catch (l) {
        throw await Promise.all((u ?? []).map((d) => d?.handleLLMError(l))), l;
      }
      await Promise.all((u ?? []).map((l) => l?.handleLLMEnd({ generations: [[c]] })));
    }
  }
  /**
  * This method takes prompt values, options, and callbacks, and generates
  * a result based on the prompts.
  * @param promptValues Prompt values for the LLM.
  * @param options Options for the LLM call.
  * @param callbacks Callbacks for the LLM call.
  * @returns An LLMResult based on the prompts.
  */
  async generatePrompt(t, n, r) {
    const s = t.map((i) => i.toString());
    return this.generate(s, n, r);
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(t) {
    return {};
  }
  _flattenLLMResult(t) {
    const n = [];
    for (let r = 0; r < t.generations.length; r += 1) {
      const s = t.generations[r];
      if (r === 0) n.push({
        generations: [s],
        llmOutput: t.llmOutput
      });
      else {
        const i = t.llmOutput ? {
          ...t.llmOutput,
          tokenUsage: {}
        } : void 0;
        n.push({
          generations: [s],
          llmOutput: i
        });
      }
    }
    return n;
  }
  /** @ignore */
  async _generateUncached(t, n, r, s) {
    let i;
    if (s !== void 0 && s.length === t.length) i = s;
    else {
      const c = await Vt.configure(r.callbacks, this.callbacks, r.tags, this.tags, r.metadata, this.metadata, { verbose: this.verbose }), l = {
        options: n,
        invocation_params: this?.invocationParams(n),
        batch_size: t.length
      };
      i = await c?.handleLLMStart(this.toJSON(), t, r.runId, void 0, l, void 0, void 0, r?.runName);
    }
    const a = !!i?.[0].handlers.find(Tm);
    let o;
    if (a && t.length === 1 && this._streamResponseChunks !== Wa.prototype._streamResponseChunks) try {
      const c = await this._streamResponseChunks(t[0], n, i?.[0]);
      let l;
      for await (const d of c) l === void 0 ? l = d : l = hr(l, d);
      if (l === void 0) throw new Error("Received empty response from chat model call.");
      o = {
        generations: [[l]],
        llmOutput: {}
      }, await i?.[0].handleLLMEnd(o);
    } catch (c) {
      throw await i?.[0].handleLLMError(c), c;
    }
    else {
      try {
        o = await this._generate(t, n, i?.[0]);
      } catch (l) {
        throw await Promise.all((i ?? []).map((d) => d?.handleLLMError(l))), l;
      }
      const c = this._flattenLLMResult(o);
      await Promise.all((i ?? []).map((l, d) => l?.handleLLMEnd(c[d])));
    }
    const u = i?.map((c) => c.runId) || void 0;
    return Object.defineProperty(o, go, {
      value: u ? { runIds: u } : void 0,
      configurable: !0
    }), o;
  }
  async _generateCached({ prompts: t, cache: n, llmStringKey: r, parsedOptions: s, handledOptions: i, runId: a }) {
    const o = await Vt.configure(i.callbacks, this.callbacks, i.tags, this.tags, i.metadata, this.metadata, { verbose: this.verbose }), u = {
      options: s,
      invocation_params: this?.invocationParams(s),
      batch_size: t.length
    }, c = await o?.handleLLMStart(this.toJSON(), t, a, void 0, u, void 0, void 0, i?.runName), l = [], f = (await Promise.allSettled(t.map(async (g, m) => {
      const _ = await n.lookup(g, r);
      return _ == null && l.push(m), _;
    }))).map((g, m) => ({
      result: g,
      runManager: c?.[m]
    })).filter(({ result: g }) => g.status === "fulfilled" && g.value != null || g.status === "rejected"), h = [];
    await Promise.all(f.map(async ({ result: g, runManager: m }, _) => {
      if (g.status === "fulfilled") {
        const y = g.value;
        return h[_] = y.map((b) => (b.generationInfo = {
          ...b.generationInfo,
          tokenUsage: {}
        }, b)), y.length && await m?.handleLLMNewToken(y[0].text), m?.handleLLMEnd({ generations: [y] }, void 0, void 0, void 0, { cached: !0 });
      } else
        return await m?.handleLLMError(g.reason, void 0, void 0, void 0, { cached: !0 }), Promise.reject(g.reason);
    }));
    const p = {
      generations: h,
      missingPromptIndices: l,
      startedRunManagers: c
    };
    return Object.defineProperty(p, go, {
      value: c ? { runIds: c?.map((g) => g.runId) } : void 0,
      configurable: !0
    }), p;
  }
  /**
  * Run the LLM on the given prompts and input, handling caching.
  */
  async generate(t, n, r) {
    if (!Array.isArray(t)) throw new Error("Argument 'prompts' is expected to be a string[]");
    let s;
    Array.isArray(n) ? s = { stop: n } : s = n;
    const [i, a] = this._separateRunnableConfigFromCallOptionsCompat(s);
    if (i.callbacks = i.callbacks ?? r, !this.cache) return this._generateUncached(t, a, i);
    const { cache: o } = this, u = this._getSerializedCacheKeyParametersForCall(a), { generations: c, missingPromptIndices: l, startedRunManagers: d } = await this._generateCached({
      prompts: t,
      cache: o,
      llmStringKey: u,
      parsedOptions: a,
      handledOptions: i,
      runId: i.runId
    });
    let f = {};
    if (l.length > 0) {
      const h = await this._generateUncached(l.map((p) => t[p]), a, i, d !== void 0 ? l.map((p) => d?.[p]) : void 0);
      await Promise.all(h.generations.map(async (p, g) => {
        const m = l[g];
        return c[m] = p, o.update(t[m], u, p);
      })), f = h.llmOutput ?? {};
    }
    return {
      generations: c,
      llmOutput: f
    };
  }
  /**
  * Get the identifying parameters of the LLM.
  */
  _identifyingParams() {
    return {};
  }
  _modelType() {
    return "base_llm";
  }
}, uz = class extends Pk {
  async _generate(e, t, n) {
    return { generations: await Promise.all(e.map((s, i) => this._call(s, {
      ...t,
      promptIndex: i
    }, n).then((a) => [{ text: a }]))) };
  }
}, cz = {};
$e(cz, { chunkArray: () => lz });
const lz = (e, t) => e.reduce((n, r, s) => {
  const i = Math.floor(s / t), a = n[i] || [];
  return n[i] = a.concat([r]), n;
}, []);
var dz = {};
$e(dz, { Embeddings: () => fz });
var fz = class {
  /**
  * The async caller should be used by subclasses to make any async calls,
  * which will thus benefit from the concurrency and retry logic.
  */
  caller;
  constructor(e) {
    this.caller = new Uo(e ?? {});
  }
}, hz = {};
$e(hz, {
  BaseToolkit: () => pz,
  DynamicStructuredTool: () => jk,
  DynamicTool: () => Mk,
  StructuredTool: () => ig,
  Tool: () => Nk,
  ToolInputParsingException: () => Ac,
  isLangChainTool: () => Br,
  isRunnableToolLike: () => Ym,
  isStructuredTool: () => Km,
  isStructuredToolParams: () => Xm,
  tool: () => mz
});
var ig = class extends ng {
  /**
  * Optional provider-specific extra fields for the tool.
  *
  * This is used to pass provider-specific configuration that doesn't fit into
  * standard tool fields.
  */
  extras;
  /**
  * Whether to return the tool's output directly.
  *
  * Setting this to true means that after the tool is called,
  * an agent should stop looping.
  */
  returnDirect = !1;
  verboseParsingErrors = !1;
  get lc_namespace() {
    return ["langchain", "tools"];
  }
  /**
  * The tool response format.
  *
  * If "content" then the output of the tool is interpreted as the contents of a
  * ToolMessage. If "content_and_artifact" then the output is expected to be a
  * two-tuple corresponding to the (content, artifact) of a ToolMessage.
  *
  * @default "content"
  */
  responseFormat = "content";
  /**
  * Default config object for the tool runnable.
  */
  defaultConfig;
  constructor(e) {
    super(e ?? {}), this.verboseParsingErrors = e?.verboseParsingErrors ?? this.verboseParsingErrors, this.responseFormat = e?.responseFormat ?? this.responseFormat, this.defaultConfig = e?.defaultConfig ?? this.defaultConfig, this.metadata = e?.metadata ?? this.metadata, this.extras = e?.extras ?? this.extras;
  }
  /**
  * Invokes the tool with the provided input and configuration.
  * @param input The input for the tool.
  * @param config Optional configuration for the tool.
  * @returns A Promise that resolves with the tool's output.
  */
  async invoke(e, t) {
    let n, r = Ne(Pc(this.defaultConfig, t));
    return to(e) ? (n = e.args, r = {
      ...r,
      toolCall: e
    }) : n = e, this.call(n, r);
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument, configuration, and tags. It
  * parses the input according to the schema, handles any errors, and
  * manages callbacks.
  * @param arg The input argument for the tool.
  * @param configArg Optional configuration or callbacks for the tool.
  * @param tags Optional tags for the tool.
  * @returns A Promise that resolves with a string.
  */
  async call(e, t, n) {
    const r = to(e) ? e.args : e;
    let s;
    if (_t(this.schema)) try {
      s = await Fl(this.schema, r);
    } catch (h) {
      let p = "Received tool input did not match expected schema";
      throw this.verboseParsingErrors && (p = `${p}
Details: ${h.message}`), $E(h) && (p = `${p}

${nN(h)}`), new Ac(p, JSON.stringify(e));
    }
    else {
      const h = Ge(r, this.schema);
      if (!h.valid) {
        let p = "Received tool input did not match expected schema";
        throw this.verboseParsingErrors && (p = `${p}
Details: ${h.errors.map((g) => `${g.keywordLocation}: ${g.error}`).join(`
`)}`), new Ac(p, JSON.stringify(e));
      }
      s = r;
    }
    const i = Al(t), o = await Vt.configure(i.callbacks, this.callbacks, i.tags || n, this.tags, i.metadata, this.metadata, { verbose: this.verbose })?.handleToolStart(this.toJSON(), typeof e == "string" ? e : JSON.stringify(e), i.runId, void 0, void 0, void 0, i.runName);
    delete i.runId;
    let u;
    try {
      u = await this._call(s, o, i);
    } catch (h) {
      throw await o?.handleToolError(h), h;
    }
    let c, l;
    if (this.responseFormat === "content_and_artifact") if (Array.isArray(u) && u.length === 2) [c, l] = u;
    else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(u)}`);
    else c = u;
    let d;
    to(e) && (d = e.id), !d && PA(i) && (d = i.toolCall.id);
    const f = gz({
      content: c,
      artifact: l,
      toolCallId: d,
      name: this.name,
      metadata: this.metadata
    });
    return await o?.handleToolEnd(f), f;
  }
}, Nk = class extends ig {
  schema = Zl({ input: Bl().optional() }).transform((e) => e.input);
  constructor(e) {
    super(e);
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  *
  * Calls the tool with the provided argument and callbacks. It handles
  * string inputs specifically.
  * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
  * @param callbacks Optional callbacks for the tool.
  * @returns A Promise that resolves with a string.
  */
  call(e, t) {
    const n = typeof e == "string" || e == null ? { input: e } : e;
    return super.call(n, t);
  }
}, Mk = class extends Nk {
  static lc_name() {
    return "DynamicTool";
  }
  name;
  description;
  func;
  constructor(e) {
    super(e), this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect;
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(e, t) {
    const n = Al(t);
    return n.runName === void 0 && (n.runName = this.name), super.call(e, n);
  }
  /** @ignore */
  async _call(e, t, n) {
    return this.func(e, t, n);
  }
}, jk = class extends ig {
  static lc_name() {
    return "DynamicStructuredTool";
  }
  description;
  func;
  schema;
  constructor(e) {
    super(e), this.name = e.name, this.description = e.description, this.func = e.func, this.returnDirect = e.returnDirect ?? this.returnDirect, this.schema = e.schema;
  }
  /**
  * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
  */
  async call(e, t, n) {
    const r = Al(t);
    return r.runName === void 0 && (r.runName = this.name), super.call(e, r, n);
  }
  _call(e, t, n) {
    return this.func(e, t, n);
  }
}, pz = class {
  getTools() {
    return this.tools;
  }
};
function mz(e, t) {
  const n = qm(t.schema), r = so(t.schema);
  if (!t.schema || n || r) return new Mk({
    ...t,
    description: t.description ?? t.schema?.description ?? `${t.name} tool`,
    func: async (a, o, u) => new Promise((c, l) => {
      const d = Ze(u, { callbacks: o?.getChild() });
      Mn.runWithConfig(dr(d), async () => {
        try {
          c(e(a, d));
        } catch (f) {
          l(f);
        }
      });
    })
  });
  const s = t.schema, i = t.description ?? t.schema.description ?? `${t.name} tool`;
  return new jk({
    ...t,
    description: i,
    schema: s,
    func: async (a, o, u) => new Promise((c, l) => {
      let d;
      const f = () => {
        u?.signal && d && u.signal.removeEventListener("abort", d);
      };
      u?.signal && (d = () => {
        f(), l(po(u.signal));
      }, u.signal.addEventListener("abort", d));
      const h = Ze(u, { callbacks: o?.getChild() });
      Mn.runWithConfig(dr(h), async () => {
        try {
          const p = await e(a, h);
          if (u?.signal?.aborted) {
            f();
            return;
          }
          f(), c(p);
        } catch (p) {
          f(), l(p);
        }
      });
    })
  });
}
function gz(e) {
  const { content: t, artifact: n, toolCallId: r, metadata: s } = e;
  return r && !mm(t) ? typeof t == "string" || Array.isArray(t) && t.every((i) => typeof i == "object") ? new Jn({
    status: "success",
    content: t,
    artifact: n,
    tool_call_id: r,
    name: e.name,
    metadata: s
  }) : new Jn({
    status: "success",
    content: _z(t),
    artifact: n,
    tool_call_id: r,
    name: e.name,
    metadata: s
  }) : t;
}
function _z(e) {
  try {
    return JSON.stringify(e, null, 2) ?? "";
  } catch {
    return `${e}`;
  }
}
const yz = we({ type: Ee("screenshot") }), wz = we({
  type: Ee("click"),
  x: ze(),
  y: ze(),
  button: Vl([
    "left",
    "right",
    "wheel",
    "back",
    "forward"
  ]).default("left")
}), vz = we({
  type: Ee("double_click"),
  x: ze(),
  y: ze(),
  button: Vl([
    "left",
    "right",
    "wheel",
    "back",
    "forward"
  ]).default("left")
}), bz = we({
  type: Ee("drag"),
  path: vs(we({
    x: ze(),
    y: ze()
  }))
}), Sz = we({
  type: Ee("keypress"),
  keys: vs(Ie())
}), Tz = we({
  type: Ee("move"),
  x: ze(),
  y: ze()
}), xz = we({
  type: Ee("scroll"),
  x: ze(),
  y: ze(),
  scroll_x: ze(),
  scroll_y: ze()
}), Ez = we({
  type: Ee("type"),
  text: Ie()
}), kz = we({
  type: Ee("wait"),
  duration: ze().optional()
}), Oz = As("type", [
  yz,
  wz,
  vz,
  bz,
  Sz,
  Tz,
  xz,
  Ez,
  kz
]);
we({ action: Oz });
const Iz = we({
  type: Ee("exec"),
  command: vs(Ie()),
  env: z4(Ie(), Ie()).optional(),
  working_directory: Ie().optional(),
  timeout_ms: ze().optional(),
  user: Ie().optional()
});
As("type", [Iz]);
we({
  commands: vs(Ie()).describe("Array of shell commands to execute"),
  timeout_ms: ze().optional().describe("Optional timeout in milliseconds for the commands"),
  max_output_length: ze().optional().describe("Optional maximum number of characters to return from each command")
});
const Az = we({
  type: Ee("create_file"),
  path: Ie(),
  diff: Ie()
}), Cz = we({
  type: Ee("update_file"),
  path: Ie(),
  diff: Ie()
}), $z = we({
  type: Ee("delete_file"),
  path: Ie()
});
As("type", [
  Az,
  Cz,
  $z
]);
var a0 = class extends Wl {
  static lc_name() {
    return "AnthropicToolsOutputParser";
  }
  lc_namespace = [
    "langchain",
    "anthropic",
    "output_parsers"
  ];
  returnId = !1;
  /** The type of tool calls to return. */
  keyName;
  /** Whether to return only the first tool call. */
  returnSingle = !1;
  zodSchema;
  constructor(e) {
    super(e), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    let t = e;
    if (typeof e == "string") try {
      t = JSON.parse(e);
    } catch (r) {
      throw new mn(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(r.message)}`, e);
    }
    else t = e;
    if (this.zodSchema === void 0) return t;
    const n = await Ul(this.zodSchema, t);
    if (n.success) return n.data;
    throw new mn(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(n.error.issues)}`, JSON.stringify(t, null, 2));
  }
  async parseResult(e) {
    const t = e.flatMap((s) => {
      const { message: i } = s;
      return Array.isArray(i.content) ? Lk(i.content)[0] : [];
    });
    if (t[0] === void 0) throw new Error("No parseable tool calls provided to AnthropicToolsOutputParser.");
    const [n] = t;
    return await this._validateResult(n.args);
  }
};
function Lk(e) {
  const t = [];
  for (const n of e) n.type === "tool_use" && t.push({
    name: n.name,
    args: n.input,
    id: n.id,
    type: "tool_call"
  });
  return t;
}
function Rz(e) {
  if (e) return e === "any" ? { type: "any" } : e === "auto" ? { type: "auto" } : e === "none" ? { type: "none" } : typeof e == "string" ? {
    type: "tool",
    name: e
  } : e;
}
const Pz = we({
  cache_control: sU().optional().nullable(),
  defer_loading: C4().optional(),
  input_examples: vs(el()).optional(),
  allowed_callers: vs(el()).optional()
}), o0 = {
  tool_search_tool_regex_20251119: "advanced-tool-use-2025-11-20",
  tool_search_tool_bm25_20251119: "advanced-tool-use-2025-11-20",
  memory_20250818: "context-management-2025-06-27",
  web_fetch_20250910: "web-fetch-2025-09-10",
  code_execution_20250825: "code-execution-2025-08-25",
  computer_20251124: "computer-use-2025-11-24",
  computer_20250124: "computer-use-2025-01-24",
  mcp_toolset: "mcp-client-2025-11-20"
};
function Nz(e) {
  return typeof e == "object" && e !== null && "type" in e && e.type === "thinking";
}
function Mz(e) {
  return typeof e == "object" && e !== null && "type" in e && e.type === "redacted_thinking";
}
function jz(e) {
  return typeof e == "object" && e !== null && "type" in e && e.type === "search_result";
}
function Lz(e) {
  return typeof e != "object" || e == null || !("type" in e) || e.type !== "image" || !("source" in e) || typeof e.source != "object" || e.source == null || !("type" in e.source) ? !1 : e.source.type === "base64" ? !(!("media_type" in e.source) || typeof e.source.media_type != "string" || !("data" in e.source) || typeof e.source.data != "string") : e.source.type === "url" ? !(!("url" in e.source) || typeof e.source.url != "string") : !1;
}
const Dz = {
  providerName: "anthropic",
  fromStandardTextBlock(e) {
    return {
      type: "text",
      text: e.text,
      ..."citations" in (e.metadata ?? {}) ? { citations: e.metadata.citations } : {},
      ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {}
    };
  },
  fromStandardImageBlock(e) {
    if (e.source_type === "url") {
      const t = Gn({
        dataUrl: e.url,
        asTypedArray: !1
      });
      return t ? {
        type: "image",
        source: {
          type: "base64",
          data: t.data,
          media_type: t.mime_type
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {}
      } : {
        type: "image",
        source: {
          type: "url",
          url: e.url
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {}
      };
    } else {
      if (e.source_type === "base64") return {
        type: "image",
        source: {
          type: "base64",
          data: e.data,
          media_type: e.mime_type ?? ""
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {}
      };
      throw new Error(`Unsupported image source type: ${e.source_type}`);
    }
  },
  fromStandardFileBlock(e) {
    const t = (e.mime_type ?? "").split(";")[0];
    if (e.source_type === "url") {
      if (t === "application/pdf" || t === "") return {
        type: "document",
        source: {
          type: "url",
          url: e.url
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {},
        ..."citations" in (e.metadata ?? {}) ? { citations: e.metadata.citations } : {},
        ..."context" in (e.metadata ?? {}) ? { context: e.metadata.context } : {},
        ..."title" in (e.metadata ?? {}) ? { title: e.metadata.title } : {}
      };
      throw new Error(`Unsupported file mime type for file url source: ${e.mime_type}`);
    } else if (e.source_type === "text") {
      if (t === "text/plain" || t === "") return {
        type: "document",
        source: {
          type: "text",
          data: e.text,
          media_type: e.mime_type ?? ""
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {},
        ..."citations" in (e.metadata ?? {}) ? { citations: e.metadata.citations } : {},
        ..."context" in (e.metadata ?? {}) ? { context: e.metadata.context } : {},
        ..."title" in (e.metadata ?? {}) ? { title: e.metadata.title } : {}
      };
      throw new Error(`Unsupported file mime type for file text source: ${e.mime_type}`);
    } else if (e.source_type === "base64") {
      if (t === "application/pdf" || t === "") return {
        type: "document",
        source: {
          type: "base64",
          data: e.data,
          media_type: "application/pdf"
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {},
        ..."citations" in (e.metadata ?? {}) ? { citations: e.metadata.citations } : {},
        ..."context" in (e.metadata ?? {}) ? { context: e.metadata.context } : {},
        ..."title" in (e.metadata ?? {}) ? { title: e.metadata.title } : {}
      };
      if ([
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp"
      ].includes(t)) return {
        type: "document",
        source: {
          type: "content",
          content: [{
            type: "image",
            source: {
              type: "base64",
              data: e.data,
              media_type: t
            }
          }]
        },
        ..."cache_control" in (e.metadata ?? {}) ? { cache_control: e.metadata.cache_control } : {},
        ..."citations" in (e.metadata ?? {}) ? { citations: e.metadata.citations } : {},
        ..."context" in (e.metadata ?? {}) ? { context: e.metadata.context } : {},
        ..."title" in (e.metadata ?? {}) ? { title: e.metadata.title } : {}
      };
      throw new Error(`Unsupported file mime type for file base64 source: ${e.mime_type}`);
    } else throw new Error(`Unsupported file source type: ${e.source_type}`);
  }
}, Uz = (e) => e();
function Fz(e) {
  return typeof e == "object" && e !== null && "type" in e && e.type === "citation";
}
function zz(e) {
  function* t() {
    for (const n of e) Fz(n) && (n.source === "char" ? yield {
      type: "char_location",
      file_id: n.url ?? "",
      start_char_index: n.startIndex ?? 0,
      end_char_index: n.endIndex ?? 0,
      document_title: n.title ?? null,
      document_index: 0,
      cited_text: n.citedText ?? ""
    } : n.source === "page" ? yield {
      type: "page_location",
      file_id: n.url ?? "",
      start_page_number: n.startIndex ?? 0,
      end_page_number: n.endIndex ?? 0,
      document_title: n.title ?? null,
      document_index: 0,
      cited_text: n.citedText ?? ""
    } : n.source === "block" ? yield {
      type: "content_block_location",
      file_id: n.url ?? "",
      start_block_index: n.startIndex ?? 0,
      end_block_index: n.endIndex ?? 0,
      document_title: n.title ?? null,
      document_index: 0,
      cited_text: n.citedText ?? ""
    } : n.source === "url" ? yield {
      type: "web_search_result_location",
      url: n.url ?? "",
      title: n.title ?? null,
      encrypted_index: String(n.startIndex ?? 0),
      cited_text: n.citedText ?? ""
    } : n.source === "search" && (yield {
      type: "search_result_location",
      title: n.title ?? null,
      start_block_index: n.startIndex ?? 0,
      end_block_index: n.endIndex ?? 0,
      search_result_index: 0,
      source: n.source ?? "",
      cited_text: n.citedText ?? ""
    }));
  }
  return Array.from(t());
}
function na(e) {
  return typeof e == "string" ? e : qz(e);
}
function qz(e) {
  const t = [];
  for (let n = 0, { length: r } = e; n < r; n++) t.push(String.fromCharCode(e[n]));
  return btoa(t.join(""));
}
function lh(e) {
  return (e ?? "").split(";")[0].toLowerCase();
}
function Ja(e, t) {
  if (e != null && typeof e == "object" && t in e) return e[t];
}
function Ls(e, t) {
  const n = Ja(t, "cache_control");
  n !== void 0 && (e.cache_control = n);
  const r = Ja(t, "citations");
  r !== void 0 && (e.citations = r);
  const s = Ja(t, "context");
  s !== void 0 && (e.context = s);
  const i = Ja(t, "title");
  return i !== void 0 && (e.title = i), e;
}
function dh(e, t) {
  const n = Ja(t, "cache_control");
  return n !== void 0 && (e.cache_control = n), e;
}
function u0(e) {
  return (/* @__PURE__ */ new Set([
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp"
  ])).has(e);
}
function Bz(e) {
  const t = [], n = e.response_metadata, r = "model_provider" in n && n?.model_provider === "anthropic";
  for (const s of e.contentBlocks) if (s.type === "text") s.annotations ? t.push({
    type: "text",
    text: s.text,
    citations: zz(s.annotations)
  }) : t.push({
    type: "text",
    text: s.text
  });
  else if (s.type === "tool_call") t.push({
    type: "tool_use",
    id: s.id ?? "",
    name: s.name,
    input: s.args
  });
  else if (s.type === "tool_call_chunk") {
    const i = Uz(() => {
      if (typeof s.args != "string") return s.args;
      try {
        return JSON.parse(s.args);
      } catch {
        return {};
      }
    });
    t.push({
      type: "tool_use",
      id: s.id ?? "",
      name: s.name ?? "",
      input: i
    });
  } else if (s.type === "reasoning" && r) t.push({
    type: "thinking",
    thinking: s.reasoning,
    signature: String(s.signature)
  });
  else if (s.type === "server_tool_call" && r)
    s.name === "web_search" ? t.push({
      type: "server_tool_use",
      name: s.name,
      id: s.id ?? "",
      input: s.args
    }) : s.name === "code_execution" && t.push({
      type: "server_tool_use",
      name: s.name,
      id: s.id ?? "",
      input: s.args
    });
  else if (s.type === "server_tool_call_result" && r)
    if (s.name === "web_search" && Array.isArray(s.output.urls)) {
      const i = s.output.urls.map((a) => ({
        type: "web_search_result",
        title: "",
        encrypted_content: "",
        url: a
      }));
      t.push({
        type: "web_search_tool_result",
        tool_use_id: s.toolCallId ?? "",
        content: i
      });
    } else s.name === "code_execution" ? t.push({
      type: "code_execution_tool_result",
      tool_use_id: s.toolCallId ?? "",
      content: s.output
    }) : s.name === "mcp_tool_result" && t.push({
      type: "mcp_tool_result",
      tool_use_id: s.toolCallId ?? "",
      content: s.output
    });
  else {
    if (s.type === "audio") throw new Error("Anthropic does not support audio content blocks.");
    if (s.type === "file") {
      const i = s.metadata;
      if (s.fileId) {
        t.push(Ls({
          type: "document",
          source: {
            type: "file",
            file_id: s.fileId
          }
        }, i));
        continue;
      }
      if (s.url) {
        const a = lh(s.mimeType);
        if (a === "application/pdf" || a === "") {
          t.push(Ls({
            type: "document",
            source: {
              type: "url",
              url: s.url
            }
          }, i));
          continue;
        }
      }
      if (s.data) {
        const a = lh(s.mimeType);
        if (a === "" || a === "application/pdf") t.push(Ls({
          type: "document",
          source: {
            type: "base64",
            data: na(s.data),
            media_type: "application/pdf"
          }
        }, i));
        else if (a === "text/plain") t.push(Ls({
          type: "document",
          source: {
            type: "text",
            data: na(s.data),
            media_type: "text/plain"
          }
        }, i));
        else if (u0(a)) t.push(Ls({
          type: "document",
          source: {
            type: "content",
            content: [{
              type: "image",
              source: {
                type: "base64",
                data: na(s.data),
                media_type: a
              }
            }]
          }
        }, i));
        else throw new Error(`Unsupported file mime type for Anthropic base64 source: ${a}`);
        continue;
      }
      throw new Error("File content block must include a fileId, url, or data property.");
    } else if (s.type === "image") {
      const i = s.metadata;
      if (s.fileId) {
        t.push(dh({
          type: "image",
          source: {
            type: "file",
            file_id: s.fileId
          }
        }, i));
        continue;
      }
      if (s.url) {
        t.push(dh({
          type: "image",
          source: {
            type: "url",
            url: s.url
          }
        }, i));
        continue;
      }
      if (s.data) {
        const a = lh(s.mimeType) || "image/png";
        u0(a) && t.push(dh({
          type: "image",
          source: {
            type: "base64",
            data: na(s.data),
            media_type: a
          }
        }, i));
        continue;
      }
      throw new Error("Image content block must include a fileId, url, or data property.");
    } else s.type === "video" || (s.type === "text-plain" ? s.data && t.push(Ls({
      type: "document",
      source: {
        type: "text",
        data: na(s.data),
        media_type: "text/plain"
      }
    }, s.metadata)) : s.type === "non_standard" && r && t.push(s.value));
  }
  return t;
}
function c0(e) {
  const t = Gn({ dataUrl: e });
  if (t) return {
    type: "base64",
    media_type: t.mime_type,
    data: t.data
  };
  let n;
  try {
    n = new URL(e);
  } catch {
    throw new Error([
      `Malformed image URL: ${JSON.stringify(e)}. Content blocks of type 'image_url' must be a valid http, https, or base64-encoded data URL.`,
      "Example: data:image/png;base64,/9j/4AAQSk...",
      "Example: https://example.com/image.jpg"
    ].join(`

`));
  }
  if (n.protocol === "http:" || n.protocol === "https:") return {
    type: "url",
    url: e
  };
  throw new Error([
    `Invalid image URL protocol: ${JSON.stringify(n.protocol)}. Anthropic only supports images as http, https, or base64-encoded data URLs on 'image_url' content blocks.`,
    "Example: data:image/png;base64,/9j/4AAQSk...",
    "Example: https://example.com/image.jpg"
  ].join(`

`));
}
function Zz(e) {
  const t = [];
  for (const n of e) if (n._getType() === "tool") if (typeof n.content == "string") {
    const r = t[t.length - 1];
    r?._getType() === "human" && Array.isArray(r.content) && "type" in r.content[0] && r.content[0].type === "tool_result" ? r.content.push({
      type: "tool_result",
      content: n.content,
      tool_use_id: n.tool_call_id
    }) : t.push(new Zt({ content: [{
      type: "tool_result",
      content: n.content,
      tool_use_id: n.tool_call_id
    }] }));
  } else t.push(new Zt({ content: [{
    type: "tool_result",
    ...n.content != null ? { content: kp(n) } : {},
    tool_use_id: n.tool_call_id
  }] }));
  else t.push(n);
  return t;
}
function l0(e) {
  if (e.id === void 0) throw new Error('Anthropic requires all tool calls to have an "id".');
  return {
    type: "tool_use",
    id: e.id,
    name: e.name,
    input: e.args
  };
}
function* Vz(e) {
  const t = [
    "bash_code_execution_tool_result",
    "input_json_delta",
    "server_tool_use",
    "text_editor_code_execution_tool_result",
    "tool_result",
    "tool_use",
    "web_search_result",
    "web_search_tool_result"
  ], n = ["text", "text_delta"];
  for (const r of e) {
    gn(r) && (yield Co(r, Dz));
    const s = "cache_control" in r ? r.cache_control : void 0;
    if (r.type === "image_url") {
      let i;
      typeof r.image_url == "string" ? i = c0(r.image_url) : typeof r.image_url == "object" && r.image_url !== null && "url" in r.image_url && typeof r.image_url.url == "string" && (i = c0(r.image_url.url)), i && (yield {
        type: "image",
        source: i,
        ...s ? { cache_control: s } : {}
      });
    } else {
      if (Lz(r)) return r;
      if (r.type === "document") yield {
        ...r,
        ...s ? { cache_control: s } : {}
      };
      else if (Nz(r))
        yield {
          type: "thinking",
          thinking: r.thinking,
          signature: r.signature,
          ...s ? { cache_control: s } : {}
        };
      else if (Mz(r))
        yield {
          type: "redacted_thinking",
          data: r.data,
          ...s ? { cache_control: s } : {}
        };
      else if (jz(r))
        yield {
          type: "search_result",
          title: r.title,
          source: r.source,
          ..."cache_control" in r && r.cache_control ? { cache_control: r.cache_control } : {},
          ..."citations" in r && r.citations ? { citations: r.citations } : {},
          content: r.content
        };
      else if (n.find((i) => i === r.type) && "text" in r) yield {
        type: "text",
        text: r.text,
        ...s ? { cache_control: s } : {},
        ..."citations" in r && r.citations ? { citations: r.citations } : {}
      };
      else if (t.find((i) => i === r.type)) {
        const i = { ...r };
        if ("index" in i && delete i.index, i.type === "input_json_delta" && (i.type = "tool_use"), "input" in i && typeof i.input == "string")
          try {
            i.input = JSON.parse(i.input);
          } catch {
            i.input = {};
          }
        yield {
          ...i,
          ...s ? { cache_control: s } : {}
        };
      } else r.type === "container_upload" && (yield {
        ...r,
        ...s ? { cache_control: s } : {}
      });
    }
  }
}
function kp(e) {
  const { content: t } = e;
  return typeof t == "string" ? t : Array.from(Vz(t));
}
function d0(e) {
  const t = Zz(e);
  let n;
  t.length > 0 && t[0]._getType() === "system" && (n = e[0].content);
  const s = (n !== void 0 ? t.slice(1) : t).map((i) => {
    let a;
    if (i._getType() === "human") a = "user";
    else if (i._getType() === "ai") a = "assistant";
    else if (i._getType() === "tool") a = "user";
    else throw i._getType() === "system" ? new Error("System messages are only permitted as the first passed message.") : new Error(`Message type "${i.type}" is not supported.`);
    if (Dr(i) && i.response_metadata?.output_version === "v1") return {
      role: a,
      content: Bz(i)
    };
    if (Dr(i) && i.tool_calls?.length) {
      if (typeof i.content == "string") return i.content === "" ? {
        role: a,
        content: i.tool_calls.map(l0)
      } : {
        role: a,
        content: [{
          type: "text",
          text: i.content
        }, ...i.tool_calls.map(l0)]
      };
      {
        const { content: o } = i;
        return !i.tool_calls.every((c) => o.find((l) => (l.type === "tool_use" || l.type === "input_json_delta" || l.type === "server_tool_use") && l.id === c.id)) && console.warn('The "tool_calls" field on a message is only respected if content is a string.'), {
          role: a,
          content: kp(i)
        };
      }
    } else return {
      role: a,
      content: kp(i)
    };
  });
  return {
    messages: Hz(s),
    system: n
  };
}
function Hz(e) {
  if (!e || e.length <= 1) return e;
  const t = [];
  let n = e[0];
  const r = (i) => typeof i == "string" ? [{
    type: "text",
    text: i
  }] : i, s = (i) => i.role !== "user" || typeof i.content == "string" ? !1 : Array.isArray(i.content) && i.content.every((a) => a.type === "tool_result");
  for (let i = 1; i < e.length; i += 1) {
    const a = e[i];
    s(n) && s(a) ? n = {
      ...n,
      content: [...r(n.content), ...r(a.content)]
    } : (t.push(n), n = a);
  }
  return t.push(n), t;
}
function Gz(e, t) {
  const n = { model_provider: "anthropic" };
  if (e.type === "message_start") {
    const { content: r, usage: s, ...i } = e.message, a = {};
    for (const [f, h] of Object.entries(i)) h != null && (a[f] = h);
    const { input_tokens: o, output_tokens: u, ...c } = s ?? {}, l = o + c.cache_creation_input_tokens + c.cache_read_input_tokens, d = {
      input_tokens: l,
      output_tokens: u,
      total_tokens: l + u,
      input_token_details: {
        cache_creation: c.cache_creation_input_tokens,
        cache_read: c.cache_read_input_tokens
      }
    };
    return { chunk: new We({
      content: t.coerceContentToString ? "" : [],
      additional_kwargs: a,
      usage_metadata: t.streamUsage ? d : void 0,
      response_metadata: {
        ...n,
        usage: { ...c }
      },
      id: e.message.id
    }) };
  } else if (e.type === "message_delta") {
    const r = {
      input_tokens: 0,
      output_tokens: e.usage.output_tokens,
      total_tokens: e.usage.output_tokens,
      input_token_details: {
        cache_creation: e.usage.cache_creation_input_tokens,
        cache_read: e.usage.cache_read_input_tokens
      }
    }, s = "context_management" in e.delta ? { context_management: e.delta.context_management } : void 0;
    return { chunk: new We({
      content: t.coerceContentToString ? "" : [],
      response_metadata: s,
      additional_kwargs: { ...e.delta },
      usage_metadata: t.streamUsage ? r : void 0
    }) };
  } else if (e.type === "content_block_start" && [
    "tool_use",
    "document",
    "server_tool_use",
    "web_search_tool_result"
  ].includes(e.content_block.type)) {
    const r = e.content_block;
    let s;
    return r.type === "tool_use" ? s = [{
      id: r.id,
      index: e.index,
      name: r.name,
      args: ""
    }] : s = [], { chunk: new We({
      content: t.coerceContentToString ? "" : [{
        index: e.index,
        ...e.content_block,
        input: r.type === "server_tool_use" || r.type === "tool_use" ? "" : void 0
      }],
      response_metadata: n,
      additional_kwargs: {},
      tool_call_chunks: s
    }) };
  } else if (e.type === "content_block_delta" && [
    "text_delta",
    "citations_delta",
    "thinking_delta",
    "signature_delta"
  ].includes(e.delta.type)) {
    if (t.coerceContentToString && "text" in e.delta) return { chunk: new We({ content: e.delta.text }) };
    {
      const r = e.delta;
      return "citation" in r && (r.citations = [r.citation], delete r.citation), r.type === "thinking_delta" || r.type === "signature_delta" ? { chunk: new We({
        content: [{
          index: e.index,
          ...r,
          type: "thinking"
        }],
        response_metadata: n
      }) } : { chunk: new We({
        content: [{
          index: e.index,
          ...r,
          type: "text"
        }],
        response_metadata: n
      }) };
    }
  } else {
    if (e.type === "content_block_delta" && e.delta.type === "input_json_delta") return { chunk: new We({
      content: t.coerceContentToString ? "" : [{
        index: e.index,
        input: e.delta.partial_json,
        type: e.delta.type
      }],
      response_metadata: n,
      additional_kwargs: {},
      tool_call_chunks: [{
        index: e.index,
        args: e.delta.partial_json
      }]
    }) };
    if (e.type === "content_block_start" && e.content_block.type === "text") {
      const r = e.content_block?.text;
      if (r !== void 0) return { chunk: new We({
        content: t.coerceContentToString ? r : [{
          index: e.index,
          ...e.content_block
        }],
        response_metadata: n,
        additional_kwargs: {}
      }) };
    } else {
      if (e.type === "content_block_start" && e.content_block.type === "redacted_thinking") return { chunk: new We({
        content: t.coerceContentToString ? "" : [{
          index: e.index,
          ...e.content_block
        }],
        response_metadata: n
      }) };
      if (e.type === "content_block_start" && e.content_block.type === "thinking") {
        const r = e.content_block.thinking;
        return { chunk: new We({
          content: t.coerceContentToString ? r : [{
            index: e.index,
            ...e.content_block
          }],
          response_metadata: n
        }) };
      }
    }
  }
  return null;
}
function Wz(e, t) {
  const n = {
    ...t,
    model_provider: "anthropic"
  }, r = t.usage, s = r != null ? {
    input_tokens: r.input_tokens ?? 0,
    output_tokens: r.output_tokens ?? 0,
    total_tokens: (r.input_tokens ?? 0) + (r.output_tokens ?? 0),
    input_token_details: {
      cache_creation: r.cache_creation_input_tokens,
      cache_read: r.cache_read_input_tokens
    }
  } : void 0;
  if (e.length === 1 && e[0].type === "text") return [{
    text: e[0].text,
    message: new rt({
      content: e[0].text,
      additional_kwargs: t,
      usage_metadata: s,
      response_metadata: n,
      id: t.id
    })
  }];
  {
    const i = Lk(e);
    return [{
      text: "",
      message: new rt({
        content: e,
        additional_kwargs: t,
        tool_calls: i,
        usage_metadata: s,
        response_metadata: n,
        id: t.id
      })
    }];
  }
}
function $u(e, t) {
  return e.lc_error_code = t, e.message = `${e.message}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${t}/
`, e;
}
function f0(e) {
  let t;
  return e.status === 400 && e.message.includes("tool") ? t = $u(e, "INVALID_TOOL_RESULTS") : e.status === 401 ? t = $u(e, "MODEL_AUTHENTICATION") : e.status === 404 ? t = $u(e, "MODEL_NOT_FOUND") : e.status === 429 ? t = $u(e, "MODEL_RATE_LIMIT") : t = e, t;
}
const Jz = {
  "claude-opus-4-0": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-5-sonnet-20241022": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-opus-4-1": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-haiku-4-5": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-5-sonnet-20240620": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-5-haiku-latest": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-opus-20240229": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-sonnet-4-5": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-sonnet-4-5-20250929": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-sonnet-4-20250514": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-opus-4-20250514": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-5-haiku-20241022": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-haiku-20240307": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-7-sonnet-20250219": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-7-sonnet-latest": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-sonnet-4-0": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-opus-4-1-20250805": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 32e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-3-sonnet-20240229": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 4096,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  },
  "claude-haiku-4-5-20251001": {
    maxInputTokens: 2e5,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !0,
    videoInputs: !1,
    maxOutputTokens: 64e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1,
    imageUrlInputs: !0,
    pdfToolMessage: !0,
    imageToolMessage: !0
  }
};
var Kz = Jz;
function W(e, t, n, r, s) {
  if (typeof t == "function" ? e !== t || !0 : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
}
function A(e, t, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}
let Dk = function() {
  const { crypto: e } = globalThis;
  if (e?.randomUUID)
    return Dk = e.randomUUID.bind(e), e.randomUUID();
  const t = new Uint8Array(1), n = e ? () => e.getRandomValues(t)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (r) => (+r ^ n() & 15 >> +r / 4).toString(16));
};
function To(e) {
  return typeof e == "object" && e !== null && // Spec-compliant fetch implementations
  ("name" in e && e.name === "AbortError" || // Expo fetch
  "message" in e && String(e.message).includes("FetchRequestCanceledException"));
}
const Op = (e) => {
  if (e instanceof Error)
    return e;
  if (typeof e == "object" && e !== null) {
    try {
      if (Object.prototype.toString.call(e) === "[object Error]") {
        const t = new Error(e.message, e.cause ? { cause: e.cause } : {});
        return e.stack && (t.stack = e.stack), e.cause && !t.cause && (t.cause = e.cause), e.name && (t.name = e.name), t;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(e));
    } catch {
    }
  }
  return new Error(e);
};
class Se extends Error {
}
class Ct extends Se {
  constructor(t, n, r, s) {
    super(`${Ct.makeMessage(t, n, r)}`), this.status = t, this.headers = s, this.requestID = s?.get("request-id"), this.error = n;
  }
  static makeMessage(t, n, r) {
    const s = n?.message ? typeof n.message == "string" ? n.message : JSON.stringify(n.message) : n ? JSON.stringify(n) : r;
    return t && s ? `${t} ${s}` : t ? `${t} status code (no body)` : s || "(no status code or body)";
  }
  static generate(t, n, r, s) {
    if (!t || !s)
      return new Xl({ message: r, cause: Op(n) });
    const i = n;
    return t === 400 ? new Fk(t, i, r, s) : t === 401 ? new zk(t, i, r, s) : t === 403 ? new qk(t, i, r, s) : t === 404 ? new Bk(t, i, r, s) : t === 409 ? new Zk(t, i, r, s) : t === 422 ? new Vk(t, i, r, s) : t === 429 ? new Hk(t, i, r, s) : t >= 500 ? new Gk(t, i, r, s) : new Ct(t, i, r, s);
  }
}
class Pn extends Ct {
  constructor({ message: t } = {}) {
    super(void 0, void 0, t || "Request was aborted.", void 0);
  }
}
class Xl extends Ct {
  constructor({ message: t, cause: n }) {
    super(void 0, void 0, t || "Connection error.", void 0), n && (this.cause = n);
  }
}
class Uk extends Xl {
  constructor({ message: t } = {}) {
    super({ message: t ?? "Request timed out." });
  }
}
class Fk extends Ct {
}
class zk extends Ct {
}
class qk extends Ct {
}
class Bk extends Ct {
}
class Zk extends Ct {
}
class Vk extends Ct {
}
class Hk extends Ct {
}
class Gk extends Ct {
}
const Yz = /^[a-z][a-z0-9+.-]*:/i, Xz = (e) => Yz.test(e);
let Ip = (e) => (Ip = Array.isArray, Ip(e)), h0 = Ip;
function Ap(e) {
  return typeof e != "object" ? {} : e ?? {};
}
function Qz(e) {
  if (!e)
    return !0;
  for (const t in e)
    return !1;
  return !0;
}
function e9(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
const t9 = (e, t) => {
  if (typeof t != "number" || !Number.isInteger(t))
    throw new Se(`${e} must be an integer`);
  if (t < 0)
    throw new Se(`${e} must be a positive integer`);
  return t;
}, Wk = (e) => {
  try {
    return JSON.parse(e);
  } catch {
    return;
  }
}, Ft = (e, t) => {
  const n = e[t];
  return delete e[t], n;
}, n9 = (e) => new Promise((t) => setTimeout(t, e)), Gs = "0.71.2", r9 = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function s9() {
  return typeof Deno < "u" && Deno.build != null ? "deno" : typeof EdgeRuntime < "u" ? "edge" : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]" ? "node" : "unknown";
}
const i9 = () => {
  const e = s9();
  if (e === "deno")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Gs,
      "X-Stainless-OS": m0(Deno.build.os),
      "X-Stainless-Arch": p0(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Gs,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  if (e === "node")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Gs,
      "X-Stainless-OS": m0(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": p0(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  const t = a9();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Gs,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Gs,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function a9() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const e = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: t, pattern: n } of e) {
    const r = n.exec(navigator.userAgent);
    if (r) {
      const s = r[1] || 0, i = r[2] || 0, a = r[3] || 0;
      return { browser: t, version: `${s}.${i}.${a}` };
    }
  }
  return null;
}
const p0 = (e) => e === "x32" ? "x32" : e === "x86_64" || e === "x64" ? "x64" : e === "arm" ? "arm" : e === "aarch64" || e === "arm64" ? "arm64" : e ? `other:${e}` : "unknown", m0 = (e) => (e = e.toLowerCase(), e.includes("ios") ? "iOS" : e === "android" ? "Android" : e === "darwin" ? "MacOS" : e === "win32" ? "Windows" : e === "freebsd" ? "FreeBSD" : e === "openbsd" ? "OpenBSD" : e === "linux" ? "Linux" : e ? `Other:${e}` : "Unknown");
let g0;
const o9 = () => g0 ?? (g0 = i9());
function u9() {
  if (typeof fetch < "u")
    return fetch;
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function Jk(...e) {
  const t = globalThis.ReadableStream;
  if (typeof t > "u")
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  return new t(...e);
}
function Kk(e) {
  let t = Symbol.asyncIterator in e ? e[Symbol.asyncIterator]() : e[Symbol.iterator]();
  return Jk({
    start() {
    },
    async pull(n) {
      const { done: r, value: s } = await t.next();
      r ? n.close() : n.enqueue(s);
    },
    async cancel() {
      await t.return?.();
    }
  });
}
function ag(e) {
  if (e[Symbol.asyncIterator])
    return e;
  const t = e.getReader();
  return {
    async next() {
      try {
        const n = await t.read();
        return n?.done && t.releaseLock(), n;
      } catch (n) {
        throw t.releaseLock(), n;
      }
    },
    async return() {
      const n = t.cancel();
      return t.releaseLock(), await n, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function c9(e) {
  if (e === null || typeof e != "object")
    return;
  if (e[Symbol.asyncIterator]) {
    await e[Symbol.asyncIterator]().return?.();
    return;
  }
  const t = e.getReader(), n = t.cancel();
  t.releaseLock(), await n;
}
const l9 = ({ headers: e, body: t }) => ({
  bodyHeaders: {
    "content-type": "application/json"
  },
  body: JSON.stringify(t)
});
function d9(e) {
  let t = 0;
  for (const s of e)
    t += s.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const s of e)
    n.set(s, r), r += s.length;
  return n;
}
let _0;
function og(e) {
  let t;
  return (_0 ?? (t = new globalThis.TextEncoder(), _0 = t.encode.bind(t)))(e);
}
let y0;
function w0(e) {
  let t;
  return (y0 ?? (t = new globalThis.TextDecoder(), y0 = t.decode.bind(t)))(e);
}
var nn, rn;
class Zo {
  constructor() {
    nn.set(this, void 0), rn.set(this, void 0), W(this, nn, new Uint8Array()), W(this, rn, null);
  }
  decode(t) {
    if (t == null)
      return [];
    const n = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? og(t) : t;
    W(this, nn, d9([A(this, nn, "f"), n]));
    const r = [];
    let s;
    for (; (s = f9(A(this, nn, "f"), A(this, rn, "f"))) != null; ) {
      if (s.carriage && A(this, rn, "f") == null) {
        W(this, rn, s.index);
        continue;
      }
      if (A(this, rn, "f") != null && (s.index !== A(this, rn, "f") + 1 || s.carriage)) {
        r.push(w0(A(this, nn, "f").subarray(0, A(this, rn, "f") - 1))), W(this, nn, A(this, nn, "f").subarray(A(this, rn, "f"))), W(this, rn, null);
        continue;
      }
      const i = A(this, rn, "f") !== null ? s.preceding - 1 : s.preceding, a = w0(A(this, nn, "f").subarray(0, i));
      r.push(a), W(this, nn, A(this, nn, "f").subarray(s.index)), W(this, rn, null);
    }
    return r;
  }
  flush() {
    return A(this, nn, "f").length ? this.decode(`
`) : [];
  }
}
nn = /* @__PURE__ */ new WeakMap(), rn = /* @__PURE__ */ new WeakMap();
Zo.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r"]);
Zo.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function f9(e, t) {
  for (let s = t ?? 0; s < e.length; s++) {
    if (e[s] === 10)
      return { preceding: s, index: s + 1, carriage: !1 };
    if (e[s] === 13)
      return { preceding: s, index: s + 1, carriage: !0 };
  }
  return null;
}
function h9(e) {
  for (let r = 0; r < e.length - 1; r++) {
    if (e[r] === 10 && e[r + 1] === 10 || e[r] === 13 && e[r + 1] === 13)
      return r + 2;
    if (e[r] === 13 && e[r + 1] === 10 && r + 3 < e.length && e[r + 2] === 13 && e[r + 3] === 10)
      return r + 4;
  }
  return -1;
}
const rl = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
}, v0 = (e, t, n) => {
  if (e) {
    if (e9(rl, e))
      return e;
    Mt(n).warn(`${t} was set to ${JSON.stringify(e)}, expected one of ${JSON.stringify(Object.keys(rl))}`);
  }
};
function Ka() {
}
function Ru(e, t, n) {
  return !t || rl[e] > rl[n] ? Ka : t[e].bind(t);
}
const p9 = {
  error: Ka,
  warn: Ka,
  info: Ka,
  debug: Ka
};
let b0 = /* @__PURE__ */ new WeakMap();
function Mt(e) {
  const t = e.logger, n = e.logLevel ?? "off";
  if (!t)
    return p9;
  const r = b0.get(t);
  if (r && r[0] === n)
    return r[1];
  const s = {
    error: Ru("error", t, n),
    warn: Ru("warn", t, n),
    info: Ru("info", t, n),
    debug: Ru("debug", t, n)
  };
  return b0.set(t, [n, s]), s;
}
const us = (e) => (e.options && (e.options = { ...e.options }, delete e.options.headers), e.headers && (e.headers = Object.fromEntries((e.headers instanceof Headers ? [...e.headers] : Object.entries(e.headers)).map(([t, n]) => [
  t,
  t.toLowerCase() === "x-api-key" || t.toLowerCase() === "authorization" || t.toLowerCase() === "cookie" || t.toLowerCase() === "set-cookie" ? "***" : n
]))), "retryOfRequestLogID" in e && (e.retryOfRequestLogID && (e.retryOf = e.retryOfRequestLogID), delete e.retryOfRequestLogID), e);
var ra;
class Hn {
  constructor(t, n, r) {
    this.iterator = t, ra.set(this, void 0), this.controller = n, W(this, ra, r);
  }
  static fromSSEResponse(t, n, r) {
    let s = !1;
    const i = r ? Mt(r) : console;
    async function* a() {
      if (s)
        throw new Se("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const u of m9(t, n)) {
          if (u.event === "completion")
            try {
              yield JSON.parse(u.data);
            } catch (c) {
              throw i.error("Could not parse message into JSON:", u.data), i.error("From chunk:", u.raw), c;
            }
          if (u.event === "message_start" || u.event === "message_delta" || u.event === "message_stop" || u.event === "content_block_start" || u.event === "content_block_delta" || u.event === "content_block_stop")
            try {
              yield JSON.parse(u.data);
            } catch (c) {
              throw i.error("Could not parse message into JSON:", u.data), i.error("From chunk:", u.raw), c;
            }
          if (u.event !== "ping" && u.event === "error")
            throw new Ct(void 0, Wk(u.data) ?? u.data, void 0, t.headers);
        }
        o = !0;
      } catch (u) {
        if (To(u))
          return;
        throw u;
      } finally {
        o || n.abort();
      }
    }
    return new Hn(a, n, r);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(t, n, r) {
    let s = !1;
    async function* i() {
      const o = new Zo(), u = ag(t);
      for await (const c of u)
        for (const l of o.decode(c))
          yield l;
      for (const c of o.flush())
        yield c;
    }
    async function* a() {
      if (s)
        throw new Se("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      s = !0;
      let o = !1;
      try {
        for await (const u of i())
          o || u && (yield JSON.parse(u));
        o = !0;
      } catch (u) {
        if (To(u))
          return;
        throw u;
      } finally {
        o || n.abort();
      }
    }
    return new Hn(a, n, r);
  }
  [(ra = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const t = [], n = [], r = this.iterator(), s = (i) => ({
      next: () => {
        if (i.length === 0) {
          const a = r.next();
          t.push(a), n.push(a);
        }
        return i.shift();
      }
    });
    return [
      new Hn(() => s(t), this.controller, A(this, ra, "f")),
      new Hn(() => s(n), this.controller, A(this, ra, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const t = this;
    let n;
    return Jk({
      async start() {
        n = t[Symbol.asyncIterator]();
      },
      async pull(r) {
        try {
          const { value: s, done: i } = await n.next();
          if (i)
            return r.close();
          const a = og(JSON.stringify(s) + `
`);
          r.enqueue(a);
        } catch (s) {
          r.error(s);
        }
      },
      async cancel() {
        await n.return?.();
      }
    });
  }
}
async function* m9(e, t) {
  if (!e.body)
    throw t.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new Se("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new Se("Attempted to iterate over a response with no body");
  const n = new _9(), r = new Zo(), s = ag(e.body);
  for await (const i of g9(s))
    for (const a of r.decode(i)) {
      const o = n.decode(a);
      o && (yield o);
    }
  for (const i of r.flush()) {
    const a = n.decode(i);
    a && (yield a);
  }
}
async function* g9(e) {
  let t = new Uint8Array();
  for await (const n of e) {
    if (n == null)
      continue;
    const r = n instanceof ArrayBuffer ? new Uint8Array(n) : typeof n == "string" ? og(n) : n;
    let s = new Uint8Array(t.length + r.length);
    s.set(t), s.set(r, t.length), t = s;
    let i;
    for (; (i = h9(t)) !== -1; )
      yield t.slice(0, i), t = t.slice(i);
  }
  t.length > 0 && (yield t);
}
class _9 {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(t) {
    if (t.endsWith("\r") && (t = t.substring(0, t.length - 1)), !t) {
      if (!this.event && !this.data.length)
        return null;
      const i = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], i;
    }
    if (this.chunks.push(t), t.startsWith(":"))
      return null;
    let [n, r, s] = y9(t, ":");
    return s.startsWith(" ") && (s = s.substring(1)), n === "event" ? this.event = s : n === "data" && this.data.push(s), null;
  }
}
function y9(e, t) {
  const n = e.indexOf(t);
  return n !== -1 ? [e.substring(0, n), t, e.substring(n + t.length)] : [e, "", ""];
}
async function Yk(e, t) {
  const { response: n, requestLogID: r, retryOfRequestLogID: s, startTime: i } = t, a = await (async () => {
    if (t.options.stream)
      return Mt(e).debug("response", n.status, n.url, n.headers, n.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(n, t.controller) : Hn.fromSSEResponse(n, t.controller);
    if (n.status === 204)
      return null;
    if (t.options.__binaryResponse)
      return n;
    const u = n.headers.get("content-type")?.split(";")[0]?.trim();
    if (u?.includes("application/json") || u?.endsWith("+json")) {
      const d = await n.json();
      return Xk(d, n);
    }
    return await n.text();
  })();
  return Mt(e).debug(`[${r}] response parsed`, us({
    retryOfRequestLogID: s,
    url: n.url,
    status: n.status,
    body: a,
    durationMs: Date.now() - i
  })), a;
}
function Xk(e, t) {
  return !e || typeof e != "object" || Array.isArray(e) ? e : Object.defineProperty(e, "_request_id", {
    value: t.headers.get("request-id"),
    enumerable: !1
  });
}
var Ya;
class Ql extends Promise {
  constructor(t, n, r = Yk) {
    super((s) => {
      s(null);
    }), this.responsePromise = n, this.parseResponse = r, Ya.set(this, void 0), W(this, Ya, t);
  }
  _thenUnwrap(t) {
    return new Ql(A(this, Ya, "f"), this.responsePromise, async (n, r) => Xk(t(await this.parseResponse(n, r), r), r.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((t) => t.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [t, n] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: t, response: n, request_id: n.headers.get("request-id") };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then((t) => this.parseResponse(A(this, Ya, "f"), t))), this.parsedPromise;
  }
  then(t, n) {
    return this.parse().then(t, n);
  }
  catch(t) {
    return this.parse().catch(t);
  }
  finally(t) {
    return this.parse().finally(t);
  }
}
Ya = /* @__PURE__ */ new WeakMap();
var Pu;
class Qk {
  constructor(t, n, r, s) {
    Pu.set(this, void 0), W(this, Pu, t), this.options = s, this.response = n, this.body = r;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageRequestOptions() != null : !1;
  }
  async getNextPage() {
    const t = this.nextPageRequestOptions();
    if (!t)
      throw new Se("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    return await A(this, Pu, "f").requestAPIList(this.constructor, t);
  }
  async *iterPages() {
    let t = this;
    for (yield t; t.hasNextPage(); )
      t = await t.getNextPage(), yield t;
  }
  async *[(Pu = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const t of this.iterPages())
      for (const n of t.getPaginatedItems())
        yield n;
  }
}
class w9 extends Ql {
  constructor(t, n, r) {
    super(t, n, async (s, i) => new r(s, i.response, await Yk(s, i), i.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const t = await this;
    for await (const n of t)
      yield n;
  }
}
class Vo extends Qk {
  constructor(t, n, r, s) {
    super(t, n, r, s), this.data = r.data || [], this.has_more = r.has_more || !1, this.first_id = r.first_id || null, this.last_id = r.last_id || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    if (this.options.query?.before_id) {
      const n = this.first_id;
      return n ? {
        ...this.options,
        query: {
          ...Ap(this.options.query),
          before_id: n
        }
      } : null;
    }
    const t = this.last_id;
    return t ? {
      ...this.options,
      query: {
        ...Ap(this.options.query),
        after_id: t
      }
    } : null;
  }
}
class eO extends Qk {
  constructor(t, n, r, s) {
    super(t, n, r, s), this.data = r.data || [], this.has_more = r.has_more || !1, this.next_page = r.next_page || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    return this.has_more === !1 ? !1 : super.hasNextPage();
  }
  nextPageRequestOptions() {
    const t = this.next_page;
    return t ? {
      ...this.options,
      query: {
        ...Ap(this.options.query),
        page: t
      }
    } : null;
  }
}
const tO = () => {
  if (typeof File > "u") {
    const { process: e } = globalThis, t = typeof e?.versions?.node == "string" && parseInt(e.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (t ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function ni(e, t, n) {
  return tO(), new File(e, t ?? "unknown_file", n);
}
function pc(e) {
  return (typeof e == "object" && e !== null && ("name" in e && e.name && String(e.name) || "url" in e && e.url && String(e.url) || "filename" in e && e.filename && String(e.filename) || "path" in e && e.path && String(e.path)) || "").split(/[\\/]/).pop() || void 0;
}
const nO = (e) => e != null && typeof e == "object" && typeof e[Symbol.asyncIterator] == "function", ug = async (e, t) => ({ ...e, body: await b9(e.body, t) }), S0 = /* @__PURE__ */ new WeakMap();
function v9(e) {
  const t = typeof e == "function" ? e : e.fetch, n = S0.get(t);
  if (n)
    return n;
  const r = (async () => {
    try {
      const s = "Response" in t ? t.Response : (await t("data:,")).constructor, i = new FormData();
      return i.toString() !== await new s(i).text();
    } catch {
      return !0;
    }
  })();
  return S0.set(t, r), r;
}
const b9 = async (e, t) => {
  if (!await v9(t))
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  const n = new FormData();
  return await Promise.all(Object.entries(e || {}).map(([r, s]) => Cp(n, r, s))), n;
}, S9 = (e) => e instanceof Blob && "name" in e, Cp = async (e, t, n) => {
  if (n !== void 0) {
    if (n == null)
      throw new TypeError(`Received null for "${t}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof n == "string" || typeof n == "number" || typeof n == "boolean")
      e.append(t, String(n));
    else if (n instanceof Response) {
      let r = {};
      const s = n.headers.get("Content-Type");
      s && (r = { type: s }), e.append(t, ni([await n.blob()], pc(n), r));
    } else if (nO(n))
      e.append(t, ni([await new Response(Kk(n)).blob()], pc(n)));
    else if (S9(n))
      e.append(t, ni([n], pc(n), { type: n.type }));
    else if (Array.isArray(n))
      await Promise.all(n.map((r) => Cp(e, t + "[]", r)));
    else if (typeof n == "object")
      await Promise.all(Object.entries(n).map(([r, s]) => Cp(e, `${t}[${r}]`, s)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`);
  }
}, rO = (e) => e != null && typeof e == "object" && typeof e.size == "number" && typeof e.type == "string" && typeof e.text == "function" && typeof e.slice == "function" && typeof e.arrayBuffer == "function", T9 = (e) => e != null && typeof e == "object" && typeof e.name == "string" && typeof e.lastModified == "number" && rO(e), x9 = (e) => e != null && typeof e == "object" && typeof e.url == "string" && typeof e.blob == "function";
async function E9(e, t, n) {
  if (tO(), e = await e, t || (t = pc(e)), T9(e))
    return e instanceof File && t == null && n == null ? e : ni([await e.arrayBuffer()], t ?? e.name, {
      type: e.type,
      lastModified: e.lastModified,
      ...n
    });
  if (x9(e)) {
    const s = await e.blob();
    return t || (t = new URL(e.url).pathname.split(/[\\/]/).pop()), ni(await $p(s), t, n);
  }
  const r = await $p(e);
  if (!n?.type) {
    const s = r.find((i) => typeof i == "object" && "type" in i && i.type);
    typeof s == "string" && (n = { ...n, type: s });
  }
  return ni(r, t, n);
}
async function $p(e) {
  let t = [];
  if (typeof e == "string" || ArrayBuffer.isView(e) || // includes Uint8Array, Buffer, etc.
  e instanceof ArrayBuffer)
    t.push(e);
  else if (rO(e))
    t.push(e instanceof Blob ? e : await e.arrayBuffer());
  else if (nO(e))
    for await (const n of e)
      t.push(...await $p(n));
  else {
    const n = e?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof e}${n ? `; constructor: ${n}` : ""}${k9(e)}`);
  }
  return t;
}
function k9(e) {
  return typeof e != "object" || e === null ? "" : `; props: [${Object.getOwnPropertyNames(e).map((n) => `"${n}"`).join(", ")}]`;
}
class zn {
  constructor(t) {
    this._client = t;
  }
}
const sO = /* @__PURE__ */ Symbol.for("brand.privateNullableHeaders");
function* O9(e) {
  if (!e)
    return;
  if (sO in e) {
    const { values: r, nulls: s } = e;
    yield* r.entries();
    for (const i of s)
      yield [i, null];
    return;
  }
  let t = !1, n;
  e instanceof Headers ? n = e.entries() : h0(e) ? n = e : (t = !0, n = Object.entries(e ?? {}));
  for (let r of n) {
    const s = r[0];
    if (typeof s != "string")
      throw new TypeError("expected header name to be a string");
    const i = h0(r[1]) ? r[1] : [r[1]];
    let a = !1;
    for (const o of i)
      o !== void 0 && (t && !a && (a = !0, yield [s, null]), yield [s, o]);
  }
}
const Ce = (e) => {
  const t = new Headers(), n = /* @__PURE__ */ new Set();
  for (const r of e) {
    const s = /* @__PURE__ */ new Set();
    for (const [i, a] of O9(r)) {
      const o = i.toLowerCase();
      s.has(o) || (t.delete(i), s.add(o)), a === null ? (t.delete(i), n.add(o)) : (t.append(i, a), n.delete(o));
    }
  }
  return { [sO]: !0, values: t, nulls: n };
};
function iO(e) {
  return e.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const T0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null)), I9 = (e = iO) => function(n, ...r) {
  if (n.length === 1)
    return n[0];
  let s = !1;
  const i = [], a = n.reduce((l, d, f) => {
    /[?#]/.test(d) && (s = !0);
    const h = r[f];
    let p = (s ? encodeURIComponent : e)("" + h);
    return f !== r.length && (h == null || typeof h == "object" && // handle values from other realms
    h.toString === Object.getPrototypeOf(Object.getPrototypeOf(h.hasOwnProperty ?? T0) ?? T0)?.toString) && (p = h + "", i.push({
      start: l.length + d.length,
      length: p.length,
      error: `Value of type ${Object.prototype.toString.call(h).slice(8, -1)} is not a valid path parameter`
    })), l + d + (f === r.length ? "" : p);
  }, ""), o = a.split(/[?#]/, 1)[0], u = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let c;
  for (; (c = u.exec(o)) !== null; )
    i.push({
      start: c.index,
      length: c[0].length,
      error: `Value "${c[0]}" can't be safely passed as a path parameter`
    });
  if (i.sort((l, d) => l.start - d.start), i.length > 0) {
    let l = 0;
    const d = i.reduce((f, h) => {
      const p = " ".repeat(h.start - l), g = "^".repeat(h.length);
      return l = h.start + h.length, f + p + g;
    }, "");
    throw new Se(`Path parameters result in path with invalid segments:
${i.map((f) => f.error).join(`
`)}
${a}
${d}`);
  }
  return a;
}, kt = /* @__PURE__ */ I9(iO);
class aO extends zn {
  /**
   * List Files
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fileMetadata of client.beta.files.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    const { betas: r, ...s } = t ?? {};
    return this._client.getAPIList("/v1/files", Vo, {
      query: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "files-api-2025-04-14"].toString() },
        n?.headers
      ])
    });
  }
  /**
   * Delete File
   *
   * @example
   * ```ts
   * const deletedFile = await client.beta.files.delete(
   *   'file_id',
   * );
   * ```
   */
  delete(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.delete(kt`/v1/files/${t}`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "files-api-2025-04-14"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * Download File
   *
   * @example
   * ```ts
   * const response = await client.beta.files.download(
   *   'file_id',
   * );
   *
   * const content = await response.blob();
   * console.log(content);
   * ```
   */
  download(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.get(kt`/v1/files/${t}/content`, {
      ...r,
      headers: Ce([
        {
          "anthropic-beta": [...s ?? [], "files-api-2025-04-14"].toString(),
          Accept: "application/binary"
        },
        r?.headers
      ]),
      __binaryResponse: !0
    });
  }
  /**
   * Get File Metadata
   *
   * @example
   * ```ts
   * const fileMetadata =
   *   await client.beta.files.retrieveMetadata('file_id');
   * ```
   */
  retrieveMetadata(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.get(kt`/v1/files/${t}`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "files-api-2025-04-14"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * Upload File
   *
   * @example
   * ```ts
   * const fileMetadata = await client.beta.files.upload({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  upload(t, n) {
    const { betas: r, ...s } = t;
    return this._client.post("/v1/files", ug({
      body: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "files-api-2025-04-14"].toString() },
        n?.headers
      ])
    }, this._client));
  }
}
let oO = class extends zn {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   *
   * @example
   * ```ts
   * const betaModelInfo = await client.beta.models.retrieve(
   *   'model_id',
   * );
   * ```
   */
  retrieve(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.get(kt`/v1/models/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { ...s?.toString() != null ? { "anthropic-beta": s?.toString() } : void 0 },
        r?.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaModelInfo of client.beta.models.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    const { betas: r, ...s } = t ?? {};
    return this._client.getAPIList("/v1/models?beta=true", Vo, {
      query: s,
      ...n,
      headers: Ce([
        { ...r?.toString() != null ? { "anthropic-beta": r?.toString() } : void 0 },
        n?.headers
      ])
    });
  }
};
const uO = {
  "claude-opus-4-20250514": 8192,
  "claude-opus-4-0": 8192,
  "claude-4-opus-20250514": 8192,
  "anthropic.claude-opus-4-20250514-v1:0": 8192,
  "claude-opus-4@20250514": 8192,
  "claude-opus-4-1-20250805": 8192,
  "anthropic.claude-opus-4-1-20250805-v1:0": 8192,
  "claude-opus-4-1@20250805": 8192
};
function x0(e, t, n) {
  return !t || !("parse" in (t.output_format ?? {})) ? {
    ...e,
    content: e.content.map((r) => {
      if (r.type === "text") {
        const s = Object.defineProperty({ ...r }, "parsed_output", {
          value: null,
          enumerable: !1
        });
        return Object.defineProperty(s, "parsed", {
          get() {
            return n.logger.warn("The `parsed` property on `text` blocks is deprecated, please use `parsed_output` instead."), null;
          },
          enumerable: !1
        });
      }
      return r;
    }),
    parsed_output: null
  } : cO(e, t, n);
}
function cO(e, t, n) {
  let r = null;
  const s = e.content.map((i) => {
    if (i.type === "text") {
      const a = A9(t, i.text);
      r === null && (r = a);
      const o = Object.defineProperty({ ...i }, "parsed_output", {
        value: a,
        enumerable: !1
      });
      return Object.defineProperty(o, "parsed", {
        get() {
          return n.logger.warn("The `parsed` property on `text` blocks is deprecated, please use `parsed_output` instead."), a;
        },
        enumerable: !1
      });
    }
    return i;
  });
  return {
    ...e,
    content: s,
    parsed_output: r
  };
}
function A9(e, t) {
  if (e.output_format?.type !== "json_schema")
    return null;
  try {
    return "parse" in e.output_format ? e.output_format.parse(t) : JSON.parse(t);
  } catch (n) {
    throw new Se(`Failed to parse structured output: ${n}`);
  }
}
const C9 = (e) => {
  let t = 0, n = [];
  for (; t < e.length; ) {
    let r = e[t];
    if (r === "\\") {
      t++;
      continue;
    }
    if (r === "{") {
      n.push({
        type: "brace",
        value: "{"
      }), t++;
      continue;
    }
    if (r === "}") {
      n.push({
        type: "brace",
        value: "}"
      }), t++;
      continue;
    }
    if (r === "[") {
      n.push({
        type: "paren",
        value: "["
      }), t++;
      continue;
    }
    if (r === "]") {
      n.push({
        type: "paren",
        value: "]"
      }), t++;
      continue;
    }
    if (r === ":") {
      n.push({
        type: "separator",
        value: ":"
      }), t++;
      continue;
    }
    if (r === ",") {
      n.push({
        type: "delimiter",
        value: ","
      }), t++;
      continue;
    }
    if (r === '"') {
      let o = "", u = !1;
      for (r = e[++t]; r !== '"'; ) {
        if (t === e.length) {
          u = !0;
          break;
        }
        if (r === "\\") {
          if (t++, t === e.length) {
            u = !0;
            break;
          }
          o += r + e[t], r = e[++t];
        } else
          o += r, r = e[++t];
      }
      r = e[++t], u || n.push({
        type: "string",
        value: o
      });
      continue;
    }
    if (r && /\s/.test(r)) {
      t++;
      continue;
    }
    let i = /[0-9]/;
    if (r && i.test(r) || r === "-" || r === ".") {
      let o = "";
      for (r === "-" && (o += r, r = e[++t]); r && i.test(r) || r === "."; )
        o += r, r = e[++t];
      n.push({
        type: "number",
        value: o
      });
      continue;
    }
    let a = /[a-z]/i;
    if (r && a.test(r)) {
      let o = "";
      for (; r && a.test(r) && t !== e.length; )
        o += r, r = e[++t];
      if (o == "true" || o == "false" || o === "null")
        n.push({
          type: "name",
          value: o
        });
      else {
        t++;
        continue;
      }
      continue;
    }
    t++;
  }
  return n;
}, Ws = (e) => {
  if (e.length === 0)
    return e;
  let t = e[e.length - 1];
  switch (t.type) {
    case "separator":
      return e = e.slice(0, e.length - 1), Ws(e);
    case "number":
      let n = t.value[t.value.length - 1];
      if (n === "." || n === "-")
        return e = e.slice(0, e.length - 1), Ws(e);
    case "string":
      let r = e[e.length - 2];
      if (r?.type === "delimiter")
        return e = e.slice(0, e.length - 1), Ws(e);
      if (r?.type === "brace" && r.value === "{")
        return e = e.slice(0, e.length - 1), Ws(e);
      break;
    case "delimiter":
      return e = e.slice(0, e.length - 1), Ws(e);
  }
  return e;
}, $9 = (e) => {
  let t = [];
  return e.map((n) => {
    n.type === "brace" && (n.value === "{" ? t.push("}") : t.splice(t.lastIndexOf("}"), 1)), n.type === "paren" && (n.value === "[" ? t.push("]") : t.splice(t.lastIndexOf("]"), 1));
  }), t.length > 0 && t.reverse().map((n) => {
    n === "}" ? e.push({
      type: "brace",
      value: "}"
    }) : n === "]" && e.push({
      type: "paren",
      value: "]"
    });
  }), e;
}, R9 = (e) => {
  let t = "";
  return e.map((n) => {
    n.type === "string" ? t += '"' + n.value + '"' : t += n.value;
  }), t;
}, lO = (e) => JSON.parse(R9($9(Ws(C9(e)))));
var fn, Er, Ds, sa, Nu, ia, aa, Mu, oa, nr, ua, ju, Lu, es, Du, Uu, ca, fh, E0, Fu, hh, ph, mh, k0;
const O0 = "__json_buf";
function I0(e) {
  return e.type === "tool_use" || e.type === "server_tool_use" || e.type === "mcp_tool_use";
}
class sl {
  constructor(t, n) {
    fn.add(this), this.messages = [], this.receivedMessages = [], Er.set(this, void 0), Ds.set(this, null), this.controller = new AbortController(), sa.set(this, void 0), Nu.set(this, () => {
    }), ia.set(this, () => {
    }), aa.set(this, void 0), Mu.set(this, () => {
    }), oa.set(this, () => {
    }), nr.set(this, {}), ua.set(this, !1), ju.set(this, !1), Lu.set(this, !1), es.set(this, !1), Du.set(this, void 0), Uu.set(this, void 0), ca.set(this, void 0), Fu.set(this, (r) => {
      if (W(this, ju, !0), To(r) && (r = new Pn()), r instanceof Pn)
        return W(this, Lu, !0), this._emit("abort", r);
      if (r instanceof Se)
        return this._emit("error", r);
      if (r instanceof Error) {
        const s = new Se(r.message);
        return s.cause = r, this._emit("error", s);
      }
      return this._emit("error", new Se(String(r)));
    }), W(this, sa, new Promise((r, s) => {
      W(this, Nu, r, "f"), W(this, ia, s, "f");
    })), W(this, aa, new Promise((r, s) => {
      W(this, Mu, r, "f"), W(this, oa, s, "f");
    })), A(this, sa, "f").catch(() => {
    }), A(this, aa, "f").catch(() => {
    }), W(this, Ds, t), W(this, ca, n?.logger ?? console);
  }
  get response() {
    return A(this, Du, "f");
  }
  get request_id() {
    return A(this, Uu, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    W(this, es, !0);
    const t = await A(this, sa, "f");
    if (!t)
      throw new Error("Could not resolve a `Response` object");
    return {
      data: this,
      response: t,
      request_id: t.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(t) {
    const n = new sl(null);
    return n._run(() => n._fromReadableStream(t)), n;
  }
  static createMessage(t, n, r, { logger: s } = {}) {
    const i = new sl(n, { logger: s });
    for (const a of n.messages)
      i._addMessageParam(a);
    return W(i, Ds, { ...n, stream: !0 }), i._run(() => i._createMessage(t, { ...n, stream: !0 }, { ...r, headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" } })), i;
  }
  _run(t) {
    t().then(() => {
      this._emitFinal(), this._emit("end");
    }, A(this, Fu, "f"));
  }
  _addMessageParam(t) {
    this.messages.push(t);
  }
  _addMessage(t, n = !0) {
    this.receivedMessages.push(t), n && this._emit("message", t);
  }
  async _createMessage(t, n, r) {
    const s = r?.signal;
    let i;
    s && (s.aborted && this.controller.abort(), i = this.controller.abort.bind(this.controller), s.addEventListener("abort", i));
    try {
      A(this, fn, "m", hh).call(this);
      const { response: a, data: o } = await t.create({ ...n, stream: !0 }, { ...r, signal: this.controller.signal }).withResponse();
      this._connected(a);
      for await (const u of o)
        A(this, fn, "m", ph).call(this, u);
      if (o.controller.signal?.aborted)
        throw new Pn();
      A(this, fn, "m", mh).call(this);
    } finally {
      s && i && s.removeEventListener("abort", i);
    }
  }
  _connected(t) {
    this.ended || (W(this, Du, t), W(this, Uu, t?.headers.get("request-id")), A(this, Nu, "f").call(this, t), this._emit("connect"));
  }
  get ended() {
    return A(this, ua, "f");
  }
  get errored() {
    return A(this, ju, "f");
  }
  get aborted() {
    return A(this, Lu, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(t, n) {
    return (A(this, nr, "f")[t] || (A(this, nr, "f")[t] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(t, n) {
    const r = A(this, nr, "f")[t];
    if (!r)
      return this;
    const s = r.findIndex((i) => i.listener === n);
    return s >= 0 && r.splice(s, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(t, n) {
    return (A(this, nr, "f")[t] || (A(this, nr, "f")[t] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(t) {
    return new Promise((n, r) => {
      W(this, es, !0), t !== "error" && this.once("error", r), this.once(t, n);
    });
  }
  async done() {
    W(this, es, !0), await A(this, aa, "f");
  }
  get currentMessage() {
    return A(this, Er, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   * If structured outputs were used, this will be a ParsedMessage with a `parsed` field.
   */
  async finalMessage() {
    return await this.done(), A(this, fn, "m", fh).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    return await this.done(), A(this, fn, "m", E0).call(this);
  }
  _emit(t, ...n) {
    if (A(this, ua, "f"))
      return;
    t === "end" && (W(this, ua, !0), A(this, Mu, "f").call(this));
    const r = A(this, nr, "f")[t];
    if (r && (A(this, nr, "f")[t] = r.filter((s) => !s.once), r.forEach(({ listener: s }) => s(...n))), t === "abort") {
      const s = n[0];
      !A(this, es, "f") && !r?.length && Promise.reject(s), A(this, ia, "f").call(this, s), A(this, oa, "f").call(this, s), this._emit("end");
      return;
    }
    if (t === "error") {
      const s = n[0];
      !A(this, es, "f") && !r?.length && Promise.reject(s), A(this, ia, "f").call(this, s), A(this, oa, "f").call(this, s), this._emit("end");
    }
  }
  _emitFinal() {
    this.receivedMessages.at(-1) && this._emit("finalMessage", A(this, fn, "m", fh).call(this));
  }
  async _fromReadableStream(t, n) {
    const r = n?.signal;
    let s;
    r && (r.aborted && this.controller.abort(), s = this.controller.abort.bind(this.controller), r.addEventListener("abort", s));
    try {
      A(this, fn, "m", hh).call(this), this._connected(null);
      const i = Hn.fromReadableStream(t, this.controller);
      for await (const a of i)
        A(this, fn, "m", ph).call(this, a);
      if (i.controller.signal?.aborted)
        throw new Pn();
      A(this, fn, "m", mh).call(this);
    } finally {
      r && s && r.removeEventListener("abort", s);
    }
  }
  [(Er = /* @__PURE__ */ new WeakMap(), Ds = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), Nu = /* @__PURE__ */ new WeakMap(), ia = /* @__PURE__ */ new WeakMap(), aa = /* @__PURE__ */ new WeakMap(), Mu = /* @__PURE__ */ new WeakMap(), oa = /* @__PURE__ */ new WeakMap(), nr = /* @__PURE__ */ new WeakMap(), ua = /* @__PURE__ */ new WeakMap(), ju = /* @__PURE__ */ new WeakMap(), Lu = /* @__PURE__ */ new WeakMap(), es = /* @__PURE__ */ new WeakMap(), Du = /* @__PURE__ */ new WeakMap(), Uu = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), Fu = /* @__PURE__ */ new WeakMap(), fn = /* @__PURE__ */ new WeakSet(), fh = function() {
    if (this.receivedMessages.length === 0)
      throw new Se("stream ended without producing a Message with role=assistant");
    return this.receivedMessages.at(-1);
  }, E0 = function() {
    if (this.receivedMessages.length === 0)
      throw new Se("stream ended without producing a Message with role=assistant");
    const n = this.receivedMessages.at(-1).content.filter((r) => r.type === "text").map((r) => r.text);
    if (n.length === 0)
      throw new Se("stream ended without producing a content block with type=text");
    return n.join(" ");
  }, hh = function() {
    this.ended || W(this, Er, void 0);
  }, ph = function(n) {
    if (this.ended)
      return;
    const r = A(this, fn, "m", k0).call(this, n);
    switch (this._emit("streamEvent", n, r), n.type) {
      case "content_block_delta": {
        const s = r.content.at(-1);
        switch (n.delta.type) {
          case "text_delta": {
            s.type === "text" && this._emit("text", n.delta.text, s.text || "");
            break;
          }
          case "citations_delta": {
            s.type === "text" && this._emit("citation", n.delta.citation, s.citations ?? []);
            break;
          }
          case "input_json_delta": {
            I0(s) && s.input && this._emit("inputJson", n.delta.partial_json, s.input);
            break;
          }
          case "thinking_delta": {
            s.type === "thinking" && this._emit("thinking", n.delta.thinking, s.thinking);
            break;
          }
          case "signature_delta": {
            s.type === "thinking" && this._emit("signature", s.signature);
            break;
          }
          default:
            n.delta;
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(r), this._addMessage(x0(r, A(this, Ds, "f"), { logger: A(this, ca, "f") }), !0);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", r.content.at(-1));
        break;
      }
      case "message_start": {
        W(this, Er, r);
        break;
      }
    }
  }, mh = function() {
    if (this.ended)
      throw new Se("stream has ended, this shouldn't happen");
    const n = A(this, Er, "f");
    if (!n)
      throw new Se("request ended without sending any chunks");
    return W(this, Er, void 0), x0(n, A(this, Ds, "f"), { logger: A(this, ca, "f") });
  }, k0 = function(n) {
    let r = A(this, Er, "f");
    if (n.type === "message_start") {
      if (r)
        throw new Se(`Unexpected event order, got ${n.type} before receiving "message_stop"`);
      return n.message;
    }
    if (!r)
      throw new Se(`Unexpected event order, got ${n.type} before "message_start"`);
    switch (n.type) {
      case "message_stop":
        return r;
      case "message_delta":
        return r.container = n.delta.container, r.stop_reason = n.delta.stop_reason, r.stop_sequence = n.delta.stop_sequence, r.usage.output_tokens = n.usage.output_tokens, r.context_management = n.context_management, n.usage.input_tokens != null && (r.usage.input_tokens = n.usage.input_tokens), n.usage.cache_creation_input_tokens != null && (r.usage.cache_creation_input_tokens = n.usage.cache_creation_input_tokens), n.usage.cache_read_input_tokens != null && (r.usage.cache_read_input_tokens = n.usage.cache_read_input_tokens), n.usage.server_tool_use != null && (r.usage.server_tool_use = n.usage.server_tool_use), r;
      case "content_block_start":
        return r.content.push(n.content_block), r;
      case "content_block_delta": {
        const s = r.content.at(n.index);
        switch (n.delta.type) {
          case "text_delta": {
            s?.type === "text" && (r.content[n.index] = {
              ...s,
              text: (s.text || "") + n.delta.text
            });
            break;
          }
          case "citations_delta": {
            s?.type === "text" && (r.content[n.index] = {
              ...s,
              citations: [...s.citations ?? [], n.delta.citation]
            });
            break;
          }
          case "input_json_delta": {
            if (s && I0(s)) {
              let i = s[O0] || "";
              i += n.delta.partial_json;
              const a = { ...s };
              if (Object.defineProperty(a, O0, {
                value: i,
                enumerable: !1,
                writable: !0
              }), i)
                try {
                  a.input = lO(i);
                } catch (o) {
                  const u = new Se(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${o}. JSON: ${i}`);
                  A(this, Fu, "f").call(this, u);
                }
              r.content[n.index] = a;
            }
            break;
          }
          case "thinking_delta": {
            s?.type === "thinking" && (r.content[n.index] = {
              ...s,
              thinking: s.thinking + n.delta.thinking
            });
            break;
          }
          case "signature_delta": {
            s?.type === "thinking" && (r.content[n.index] = {
              ...s,
              signature: n.delta.signature
            });
            break;
          }
          default:
            n.delta;
        }
        return r;
      }
      case "content_block_stop":
        return r;
    }
  }, Symbol.asyncIterator)]() {
    const t = [], n = [];
    let r = !1;
    return this.on("streamEvent", (s) => {
      const i = n.shift();
      i ? i.resolve(s) : t.push(s);
    }), this.on("end", () => {
      r = !0;
      for (const s of n)
        s.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), this.on("error", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), {
      next: async () => t.length ? { value: t.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((i, a) => n.push({ resolve: i, reject: a })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new Hn(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
const P9 = 1e5, N9 = `You have been working on the task described above but have not yet completed it. Write a continuation summary that will allow you (or another instance of yourself) to resume work efficiently in a future context window where the conversation history will be replaced with this summary. Your summary should be structured, concise, and actionable. Include:
1. Task Overview
The user's core request and success criteria
Any clarifications or constraints they specified
2. Current State
What has been completed so far
Files created, modified, or analyzed (with paths if relevant)
Key outputs or artifacts produced
3. Important Discoveries
Technical constraints or requirements uncovered
Decisions made and their rationale
Errors encountered and how they were resolved
What approaches were tried that didn't work (and why)
4. Next Steps
Specific actions needed to complete the task
Any blockers or open questions to resolve
Priority order if multiple steps remain
5. Context to Preserve
User preferences or style requirements
Domain-specific details that aren't obvious
Any promises made to the user
Be concise but completeerr on the side of including information that would prevent duplicate work or repeated mistakes. Write in a way that enables immediate resumption of the task.
Wrap your summary in <summary></summary> tags.`;
var la, Us, ts, lt, da, Xt, or, kr, fa, A0, Rp;
function C0() {
  let e, t;
  return { promise: new Promise((r, s) => {
    e = r, t = s;
  }), resolve: e, reject: t };
}
class dO {
  constructor(t, n, r) {
    la.add(this), this.client = t, Us.set(this, !1), ts.set(this, !1), lt.set(this, void 0), da.set(this, void 0), Xt.set(this, void 0), or.set(this, void 0), kr.set(this, void 0), fa.set(this, 0), W(this, lt, {
      params: {
        // You can't clone the entire params since there are functions as handlers.
        // You also don't really need to clone params.messages, but it probably will prevent a foot gun
        // somewhere.
        ...n,
        messages: structuredClone(n.messages)
      }
    }), W(this, da, {
      ...r,
      headers: Ce([{ "x-stainless-helper": "BetaToolRunner" }, r?.headers])
    }), W(this, kr, C0());
  }
  async *[(Us = /* @__PURE__ */ new WeakMap(), ts = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakMap(), da = /* @__PURE__ */ new WeakMap(), Xt = /* @__PURE__ */ new WeakMap(), or = /* @__PURE__ */ new WeakMap(), kr = /* @__PURE__ */ new WeakMap(), fa = /* @__PURE__ */ new WeakMap(), la = /* @__PURE__ */ new WeakSet(), A0 = async function() {
    const n = A(this, lt, "f").params.compactionControl;
    if (!n || !n.enabled)
      return !1;
    let r = 0;
    if (A(this, Xt, "f") !== void 0)
      try {
        const c = await A(this, Xt, "f");
        r = c.usage.input_tokens + (c.usage.cache_creation_input_tokens ?? 0) + (c.usage.cache_read_input_tokens ?? 0) + c.usage.output_tokens;
      } catch {
        return !1;
      }
    const s = n.contextTokenThreshold ?? P9;
    if (r < s)
      return !1;
    const i = n.model ?? A(this, lt, "f").params.model, a = n.summaryPrompt ?? N9, o = A(this, lt, "f").params.messages;
    if (o[o.length - 1].role === "assistant") {
      const c = o[o.length - 1];
      if (Array.isArray(c.content)) {
        const l = c.content.filter((d) => d.type !== "tool_use");
        l.length === 0 ? o.pop() : c.content = l;
      }
    }
    const u = await this.client.beta.messages.create({
      model: i,
      messages: [
        ...o,
        {
          role: "user",
          content: [
            {
              type: "text",
              text: a
            }
          ]
        }
      ],
      max_tokens: A(this, lt, "f").params.max_tokens
    }, {
      headers: { "x-stainless-helper": "compaction" }
    });
    if (u.content[0]?.type !== "text")
      throw new Se("Expected text response for compaction");
    return A(this, lt, "f").params.messages = [
      {
        role: "user",
        content: u.content
      }
    ], !0;
  }, Symbol.asyncIterator)]() {
    var t;
    if (A(this, Us, "f"))
      throw new Se("Cannot iterate over a consumed stream");
    W(this, Us, !0), W(this, ts, !0), W(this, or, void 0);
    try {
      for (; ; ) {
        let n;
        try {
          if (A(this, lt, "f").params.max_iterations && A(this, fa, "f") >= A(this, lt, "f").params.max_iterations)
            break;
          W(this, ts, !1, "f"), W(this, or, void 0, "f"), W(this, fa, (t = A(this, fa, "f"), t++, t), "f"), W(this, Xt, void 0, "f");
          const { max_iterations: r, compactionControl: s, ...i } = A(this, lt, "f").params;
          if (i.stream ? (n = this.client.beta.messages.stream({ ...i }, A(this, da, "f")), W(this, Xt, n.finalMessage(), "f"), A(this, Xt, "f").catch(() => {
          }), yield n) : (W(this, Xt, this.client.beta.messages.create({ ...i, stream: !1 }, A(this, da, "f")), "f"), yield A(this, Xt, "f")), !await A(this, la, "m", A0).call(this)) {
            if (!A(this, ts, "f")) {
              const { role: u, content: c } = await A(this, Xt, "f");
              A(this, lt, "f").params.messages.push({ role: u, content: c });
            }
            const o = await A(this, la, "m", Rp).call(this, A(this, lt, "f").params.messages.at(-1));
            if (o)
              A(this, lt, "f").params.messages.push(o);
            else if (!A(this, ts, "f"))
              break;
          }
        } finally {
          n && n.abort();
        }
      }
      if (!A(this, Xt, "f"))
        throw new Se("ToolRunner concluded without a message from the server");
      A(this, kr, "f").resolve(await A(this, Xt, "f"));
    } catch (n) {
      throw W(this, Us, !1), A(this, kr, "f").promise.catch(() => {
      }), A(this, kr, "f").reject(n), W(this, kr, C0()), n;
    }
  }
  setMessagesParams(t) {
    typeof t == "function" ? A(this, lt, "f").params = t(A(this, lt, "f").params) : A(this, lt, "f").params = t, W(this, ts, !0), W(this, or, void 0);
  }
  /**
   * Get the tool response for the last message from the assistant.
   * Avoids redundant tool executions by caching results.
   *
   * @returns A promise that resolves to a BetaMessageParam containing tool results, or null if no tools need to be executed
   *
   * @example
   * const toolResponse = await runner.generateToolResponse();
   * if (toolResponse) {
   *   console.log('Tool results:', toolResponse.content);
   * }
   */
  async generateToolResponse() {
    const t = await A(this, Xt, "f") ?? this.params.messages.at(-1);
    return t ? A(this, la, "m", Rp).call(this, t) : null;
  }
  /**
   * Wait for the async iterator to complete. This works even if the async iterator hasn't yet started, and
   * will wait for an instance to start and go to completion.
   *
   * @returns A promise that resolves to the final BetaMessage when the iterator completes
   *
   * @example
   * // Start consuming the iterator
   * for await (const message of runner) {
   *   console.log('Message:', message.content);
   * }
   *
   * // Meanwhile, wait for completion from another part of the code
   * const finalMessage = await runner.done();
   * console.log('Final response:', finalMessage.content);
   */
  done() {
    return A(this, kr, "f").promise;
  }
  /**
   * Returns a promise indicating that the stream is done. Unlike .done(), this will eagerly read the stream:
   * * If the iterator has not been consumed, consume the entire iterator and return the final message from the
   * assistant.
   * * If the iterator has been consumed, waits for it to complete and returns the final message.
   *
   * @returns A promise that resolves to the final BetaMessage from the conversation
   * @throws {AnthropicError} If no messages were processed during the conversation
   *
   * @example
   * const finalMessage = await runner.runUntilDone();
   * console.log('Final response:', finalMessage.content);
   */
  async runUntilDone() {
    if (!A(this, Us, "f"))
      for await (const t of this)
        ;
    return this.done();
  }
  /**
   * Get the current parameters being used by the ToolRunner.
   *
   * @returns A readonly view of the current ToolRunnerParams
   *
   * @example
   * const currentParams = runner.params;
   * console.log('Current model:', currentParams.model);
   * console.log('Message count:', currentParams.messages.length);
   */
  get params() {
    return A(this, lt, "f").params;
  }
  /**
   * Add one or more messages to the conversation history.
   *
   * @param messages - One or more BetaMessageParam objects to add to the conversation
   *
   * @example
   * runner.pushMessages(
   *   { role: 'user', content: 'Also, what about the weather in NYC?' }
   * );
   *
   * @example
   * // Adding multiple messages
   * runner.pushMessages(
   *   { role: 'user', content: 'What about NYC?' },
   *   { role: 'user', content: 'And Boston?' }
   * );
   */
  pushMessages(...t) {
    this.setMessagesParams((n) => ({
      ...n,
      messages: [...n.messages, ...t]
    }));
  }
  /**
   * Makes the ToolRunner directly awaitable, equivalent to calling .runUntilDone()
   * This allows using `await runner` instead of `await runner.runUntilDone()`
   */
  then(t, n) {
    return this.runUntilDone().then(t, n);
  }
}
Rp = async function(t) {
  return A(this, or, "f") !== void 0 ? A(this, or, "f") : (W(this, or, M9(A(this, lt, "f").params, t)), A(this, or, "f"));
};
async function M9(e, t = e.messages.at(-1)) {
  if (!t || t.role !== "assistant" || !t.content || typeof t.content == "string")
    return null;
  const n = t.content.filter((s) => s.type === "tool_use");
  return n.length === 0 ? null : {
    role: "user",
    content: await Promise.all(n.map(async (s) => {
      const i = e.tools.find((a) => ("name" in a ? a.name : a.mcp_server_name) === s.name);
      if (!i || !("run" in i))
        return {
          type: "tool_result",
          tool_use_id: s.id,
          content: `Error: Tool '${s.name}' not found`,
          is_error: !0
        };
      try {
        let a = s.input;
        "parse" in i && i.parse && (a = i.parse(a));
        const o = await i.run(a);
        return {
          type: "tool_result",
          tool_use_id: s.id,
          content: o
        };
      } catch (a) {
        return {
          type: "tool_result",
          tool_use_id: s.id,
          content: `Error: ${a instanceof Error ? a.message : String(a)}`,
          is_error: !0
        };
      }
    }))
  };
}
class ed {
  constructor(t, n) {
    this.iterator = t, this.controller = n;
  }
  async *decoder() {
    const t = new Zo();
    for await (const n of this.iterator)
      for (const r of t.decode(n))
        yield JSON.parse(r);
    for (const n of t.flush())
      yield JSON.parse(n);
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(t, n) {
    if (!t.body)
      throw n.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new Se("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new Se("Attempted to iterate over a response with no body");
    return new ed(ag(t.body), n);
  }
}
let fO = class extends zn {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.create({
   *     requests: [
   *       {
   *         custom_id: 'my-custom-id-1',
   *         params: {
   *           max_tokens: 1024,
   *           messages: [
   *             { content: 'Hello, world', role: 'user' },
   *           ],
   *           model: 'claude-sonnet-4-5-20250929',
   *         },
   *       },
   *     ],
   *   });
   * ```
   */
  create(t, n) {
    const { betas: r, ...s } = t;
    return this._client.post("/v1/messages/batches?beta=true", {
      body: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString() },
        n?.headers
      ])
    });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.retrieve(
   *     'message_batch_id',
   *   );
   * ```
   */
  retrieve(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.get(kt`/v1/messages/batches/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "message-batches-2024-09-24"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaMessageBatch of client.beta.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    const { betas: r, ...s } = t ?? {};
    return this._client.getAPIList("/v1/messages/batches?beta=true", Vo, {
      query: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString() },
        n?.headers
      ])
    });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaDeletedMessageBatch =
   *   await client.beta.messages.batches.delete(
   *     'message_batch_id',
   *   );
   * ```
   */
  delete(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.delete(kt`/v1/messages/batches/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "message-batches-2024-09-24"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.cancel(
   *     'message_batch_id',
   *   );
   * ```
   */
  cancel(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.post(kt`/v1/messages/batches/${t}/cancel?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "message-batches-2024-09-24"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatchIndividualResponse =
   *   await client.beta.messages.batches.results(
   *     'message_batch_id',
   *   );
   * ```
   */
  async results(t, n = {}, r) {
    const s = await this.retrieve(t);
    if (!s.results_url)
      throw new Se(`No batch \`results_url\`; Has it finished processing? ${s.processing_status} - ${s.id}`);
    const { betas: i } = n ?? {};
    return this._client.get(s.results_url, {
      ...r,
      headers: Ce([
        {
          "anthropic-beta": [...i ?? [], "message-batches-2024-09-24"].toString(),
          Accept: "application/binary"
        },
        r?.headers
      ]),
      stream: !0,
      __binaryResponse: !0
    })._thenUnwrap((a, o) => ed.fromResponse(o.response, o.controller));
  }
};
const $0 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-7-sonnet-latest": "February 19th, 2026",
  "claude-3-7-sonnet-20250219": "February 19th, 2026"
};
let td = class extends zn {
  constructor() {
    super(...arguments), this.batches = new fO(this._client);
  }
  create(t, n) {
    const { betas: r, ...s } = t;
    s.model in $0 && console.warn(`The model '${s.model}' is deprecated and will reach end-of-life on ${$0[s.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    let i = this._client._options.timeout;
    if (!s.stream && i == null) {
      const a = uO[s.model] ?? void 0;
      i = this._client.calculateNonstreamingTimeout(s.max_tokens, a);
    }
    return this._client.post("/v1/messages?beta=true", {
      body: s,
      timeout: i ?? 6e5,
      ...n,
      headers: Ce([
        { ...r?.toString() != null ? { "anthropic-beta": r?.toString() } : void 0 },
        n?.headers
      ]),
      stream: t.stream ?? !1
    });
  }
  /**
   * Send a structured list of input messages with text and/or image content, along with an expected `output_format` and
   * the response will be automatically parsed and available in the `parsed_output` property of the message.
   *
   * @example
   * ```ts
   * const message = await client.beta.messages.parse({
   *   model: 'claude-3-5-sonnet-20241022',
   *   max_tokens: 1024,
   *   messages: [{ role: 'user', content: 'What is 2+2?' }],
   *   output_format: zodOutputFormat(z.object({ answer: z.number() }), 'math'),
   * });
   *
   * console.log(message.parsed_output?.answer); // 4
   * ```
   */
  parse(t, n) {
    return n = {
      ...n,
      headers: Ce([
        { "anthropic-beta": [...t.betas ?? [], "structured-outputs-2025-11-13"].toString() },
        n?.headers
      ])
    }, this.create(t, n).then((r) => cO(r, t, { logger: this._client.logger ?? console }));
  }
  /**
   * Create a Message stream
   */
  stream(t, n) {
    return sl.createMessage(this, t, n);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const betaMessageTokensCount =
   *   await client.beta.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-opus-4-5-20251101',
   *   });
   * ```
   */
  countTokens(t, n) {
    const { betas: r, ...s } = t;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "token-counting-2024-11-01"].toString() },
        n?.headers
      ])
    });
  }
  toolRunner(t, n) {
    return new dO(this._client, t, n);
  }
};
td.Batches = fO;
td.BetaToolRunner = dO;
class hO extends zn {
  /**
   * Create Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.create(
   *   'skill_id',
   * );
   * ```
   */
  create(t, n = {}, r) {
    const { betas: s, ...i } = n ?? {};
    return this._client.post(kt`/v1/skills/${t}/versions?beta=true`, ug({
      body: i,
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "skills-2025-10-02"].toString() },
        r?.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.retrieve(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  retrieve(t, n, r) {
    const { skill_id: s, betas: i } = n;
    return this._client.get(kt`/v1/skills/${s}/versions/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...i ?? [], "skills-2025-10-02"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * List Skill Versions
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const versionListResponse of client.beta.skills.versions.list(
   *   'skill_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(t, n = {}, r) {
    const { betas: s, ...i } = n ?? {};
    return this._client.getAPIList(kt`/v1/skills/${t}/versions?beta=true`, eO, {
      query: i,
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "skills-2025-10-02"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * Delete Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.delete(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  delete(t, n, r) {
    const { skill_id: s, betas: i } = n;
    return this._client.delete(kt`/v1/skills/${s}/versions/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...i ?? [], "skills-2025-10-02"].toString() },
        r?.headers
      ])
    });
  }
}
class cg extends zn {
  constructor() {
    super(...arguments), this.versions = new hO(this._client);
  }
  /**
   * Create Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.create();
   * ```
   */
  create(t = {}, n) {
    const { betas: r, ...s } = t ?? {};
    return this._client.post("/v1/skills?beta=true", ug({
      body: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "skills-2025-10-02"].toString() },
        n?.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.retrieve('skill_id');
   * ```
   */
  retrieve(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.get(kt`/v1/skills/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "skills-2025-10-02"].toString() },
        r?.headers
      ])
    });
  }
  /**
   * List Skills
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const skillListResponse of client.beta.skills.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    const { betas: r, ...s } = t ?? {};
    return this._client.getAPIList("/v1/skills?beta=true", eO, {
      query: s,
      ...n,
      headers: Ce([
        { "anthropic-beta": [...r ?? [], "skills-2025-10-02"].toString() },
        n?.headers
      ])
    });
  }
  /**
   * Delete Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.delete('skill_id');
   * ```
   */
  delete(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.delete(kt`/v1/skills/${t}?beta=true`, {
      ...r,
      headers: Ce([
        { "anthropic-beta": [...s ?? [], "skills-2025-10-02"].toString() },
        r?.headers
      ])
    });
  }
}
cg.Versions = hO;
class Si extends zn {
  constructor() {
    super(...arguments), this.models = new oO(this._client), this.messages = new td(this._client), this.files = new aO(this._client), this.skills = new cg(this._client);
  }
}
Si.Models = oO;
Si.Messages = td;
Si.Files = aO;
Si.Skills = cg;
class pO extends zn {
  create(t, n) {
    const { betas: r, ...s } = t;
    return this._client.post("/v1/complete", {
      body: s,
      timeout: this._client._options.timeout ?? 6e5,
      ...n,
      headers: Ce([
        { ...r?.toString() != null ? { "anthropic-beta": r?.toString() } : void 0 },
        n?.headers
      ]),
      stream: t.stream ?? !1
    });
  }
}
var hn, Or, ha, zu, pa, ma, qu, ga, rr, _a, Bu, Zu, ns, Vu, Hu, gh, R0, _h, yh, wh, vh, P0;
const N0 = "__json_buf";
function M0(e) {
  return e.type === "tool_use" || e.type === "server_tool_use";
}
class il {
  constructor() {
    hn.add(this), this.messages = [], this.receivedMessages = [], Or.set(this, void 0), this.controller = new AbortController(), ha.set(this, void 0), zu.set(this, () => {
    }), pa.set(this, () => {
    }), ma.set(this, void 0), qu.set(this, () => {
    }), ga.set(this, () => {
    }), rr.set(this, {}), _a.set(this, !1), Bu.set(this, !1), Zu.set(this, !1), ns.set(this, !1), Vu.set(this, void 0), Hu.set(this, void 0), _h.set(this, (t) => {
      if (W(this, Bu, !0), To(t) && (t = new Pn()), t instanceof Pn)
        return W(this, Zu, !0), this._emit("abort", t);
      if (t instanceof Se)
        return this._emit("error", t);
      if (t instanceof Error) {
        const n = new Se(t.message);
        return n.cause = t, this._emit("error", n);
      }
      return this._emit("error", new Se(String(t)));
    }), W(this, ha, new Promise((t, n) => {
      W(this, zu, t, "f"), W(this, pa, n, "f");
    })), W(this, ma, new Promise((t, n) => {
      W(this, qu, t, "f"), W(this, ga, n, "f");
    })), A(this, ha, "f").catch(() => {
    }), A(this, ma, "f").catch(() => {
    });
  }
  get response() {
    return A(this, Vu, "f");
  }
  get request_id() {
    return A(this, Hu, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    W(this, ns, !0);
    const t = await A(this, ha, "f");
    if (!t)
      throw new Error("Could not resolve a `Response` object");
    return {
      data: this,
      response: t,
      request_id: t.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(t) {
    const n = new il();
    return n._run(() => n._fromReadableStream(t)), n;
  }
  static createMessage(t, n, r) {
    const s = new il();
    for (const i of n.messages)
      s._addMessageParam(i);
    return s._run(() => s._createMessage(t, { ...n, stream: !0 }, { ...r, headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" } })), s;
  }
  _run(t) {
    t().then(() => {
      this._emitFinal(), this._emit("end");
    }, A(this, _h, "f"));
  }
  _addMessageParam(t) {
    this.messages.push(t);
  }
  _addMessage(t, n = !0) {
    this.receivedMessages.push(t), n && this._emit("message", t);
  }
  async _createMessage(t, n, r) {
    const s = r?.signal;
    let i;
    s && (s.aborted && this.controller.abort(), i = this.controller.abort.bind(this.controller), s.addEventListener("abort", i));
    try {
      A(this, hn, "m", yh).call(this);
      const { response: a, data: o } = await t.create({ ...n, stream: !0 }, { ...r, signal: this.controller.signal }).withResponse();
      this._connected(a);
      for await (const u of o)
        A(this, hn, "m", wh).call(this, u);
      if (o.controller.signal?.aborted)
        throw new Pn();
      A(this, hn, "m", vh).call(this);
    } finally {
      s && i && s.removeEventListener("abort", i);
    }
  }
  _connected(t) {
    this.ended || (W(this, Vu, t), W(this, Hu, t?.headers.get("request-id")), A(this, zu, "f").call(this, t), this._emit("connect"));
  }
  get ended() {
    return A(this, _a, "f");
  }
  get errored() {
    return A(this, Bu, "f");
  }
  get aborted() {
    return A(this, Zu, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(t, n) {
    return (A(this, rr, "f")[t] || (A(this, rr, "f")[t] = [])).push({ listener: n }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(t, n) {
    const r = A(this, rr, "f")[t];
    if (!r)
      return this;
    const s = r.findIndex((i) => i.listener === n);
    return s >= 0 && r.splice(s, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(t, n) {
    return (A(this, rr, "f")[t] || (A(this, rr, "f")[t] = [])).push({ listener: n, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(t) {
    return new Promise((n, r) => {
      W(this, ns, !0), t !== "error" && this.once("error", r), this.once(t, n);
    });
  }
  async done() {
    W(this, ns, !0), await A(this, ma, "f");
  }
  get currentMessage() {
    return A(this, Or, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    return await this.done(), A(this, hn, "m", gh).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    return await this.done(), A(this, hn, "m", R0).call(this);
  }
  _emit(t, ...n) {
    if (A(this, _a, "f"))
      return;
    t === "end" && (W(this, _a, !0), A(this, qu, "f").call(this));
    const r = A(this, rr, "f")[t];
    if (r && (A(this, rr, "f")[t] = r.filter((s) => !s.once), r.forEach(({ listener: s }) => s(...n))), t === "abort") {
      const s = n[0];
      !A(this, ns, "f") && !r?.length && Promise.reject(s), A(this, pa, "f").call(this, s), A(this, ga, "f").call(this, s), this._emit("end");
      return;
    }
    if (t === "error") {
      const s = n[0];
      !A(this, ns, "f") && !r?.length && Promise.reject(s), A(this, pa, "f").call(this, s), A(this, ga, "f").call(this, s), this._emit("end");
    }
  }
  _emitFinal() {
    this.receivedMessages.at(-1) && this._emit("finalMessage", A(this, hn, "m", gh).call(this));
  }
  async _fromReadableStream(t, n) {
    const r = n?.signal;
    let s;
    r && (r.aborted && this.controller.abort(), s = this.controller.abort.bind(this.controller), r.addEventListener("abort", s));
    try {
      A(this, hn, "m", yh).call(this), this._connected(null);
      const i = Hn.fromReadableStream(t, this.controller);
      for await (const a of i)
        A(this, hn, "m", wh).call(this, a);
      if (i.controller.signal?.aborted)
        throw new Pn();
      A(this, hn, "m", vh).call(this);
    } finally {
      r && s && r.removeEventListener("abort", s);
    }
  }
  [(Or = /* @__PURE__ */ new WeakMap(), ha = /* @__PURE__ */ new WeakMap(), zu = /* @__PURE__ */ new WeakMap(), pa = /* @__PURE__ */ new WeakMap(), ma = /* @__PURE__ */ new WeakMap(), qu = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), rr = /* @__PURE__ */ new WeakMap(), _a = /* @__PURE__ */ new WeakMap(), Bu = /* @__PURE__ */ new WeakMap(), Zu = /* @__PURE__ */ new WeakMap(), ns = /* @__PURE__ */ new WeakMap(), Vu = /* @__PURE__ */ new WeakMap(), Hu = /* @__PURE__ */ new WeakMap(), _h = /* @__PURE__ */ new WeakMap(), hn = /* @__PURE__ */ new WeakSet(), gh = function() {
    if (this.receivedMessages.length === 0)
      throw new Se("stream ended without producing a Message with role=assistant");
    return this.receivedMessages.at(-1);
  }, R0 = function() {
    if (this.receivedMessages.length === 0)
      throw new Se("stream ended without producing a Message with role=assistant");
    const n = this.receivedMessages.at(-1).content.filter((r) => r.type === "text").map((r) => r.text);
    if (n.length === 0)
      throw new Se("stream ended without producing a content block with type=text");
    return n.join(" ");
  }, yh = function() {
    this.ended || W(this, Or, void 0);
  }, wh = function(n) {
    if (this.ended)
      return;
    const r = A(this, hn, "m", P0).call(this, n);
    switch (this._emit("streamEvent", n, r), n.type) {
      case "content_block_delta": {
        const s = r.content.at(-1);
        switch (n.delta.type) {
          case "text_delta": {
            s.type === "text" && this._emit("text", n.delta.text, s.text || "");
            break;
          }
          case "citations_delta": {
            s.type === "text" && this._emit("citation", n.delta.citation, s.citations ?? []);
            break;
          }
          case "input_json_delta": {
            M0(s) && s.input && this._emit("inputJson", n.delta.partial_json, s.input);
            break;
          }
          case "thinking_delta": {
            s.type === "thinking" && this._emit("thinking", n.delta.thinking, s.thinking);
            break;
          }
          case "signature_delta": {
            s.type === "thinking" && this._emit("signature", s.signature);
            break;
          }
          default:
            n.delta;
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(r), this._addMessage(r, !0);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", r.content.at(-1));
        break;
      }
      case "message_start": {
        W(this, Or, r);
        break;
      }
    }
  }, vh = function() {
    if (this.ended)
      throw new Se("stream has ended, this shouldn't happen");
    const n = A(this, Or, "f");
    if (!n)
      throw new Se("request ended without sending any chunks");
    return W(this, Or, void 0), n;
  }, P0 = function(n) {
    let r = A(this, Or, "f");
    if (n.type === "message_start") {
      if (r)
        throw new Se(`Unexpected event order, got ${n.type} before receiving "message_stop"`);
      return n.message;
    }
    if (!r)
      throw new Se(`Unexpected event order, got ${n.type} before "message_start"`);
    switch (n.type) {
      case "message_stop":
        return r;
      case "message_delta":
        return r.stop_reason = n.delta.stop_reason, r.stop_sequence = n.delta.stop_sequence, r.usage.output_tokens = n.usage.output_tokens, n.usage.input_tokens != null && (r.usage.input_tokens = n.usage.input_tokens), n.usage.cache_creation_input_tokens != null && (r.usage.cache_creation_input_tokens = n.usage.cache_creation_input_tokens), n.usage.cache_read_input_tokens != null && (r.usage.cache_read_input_tokens = n.usage.cache_read_input_tokens), n.usage.server_tool_use != null && (r.usage.server_tool_use = n.usage.server_tool_use), r;
      case "content_block_start":
        return r.content.push({ ...n.content_block }), r;
      case "content_block_delta": {
        const s = r.content.at(n.index);
        switch (n.delta.type) {
          case "text_delta": {
            s?.type === "text" && (r.content[n.index] = {
              ...s,
              text: (s.text || "") + n.delta.text
            });
            break;
          }
          case "citations_delta": {
            s?.type === "text" && (r.content[n.index] = {
              ...s,
              citations: [...s.citations ?? [], n.delta.citation]
            });
            break;
          }
          case "input_json_delta": {
            if (s && M0(s)) {
              let i = s[N0] || "";
              i += n.delta.partial_json;
              const a = { ...s };
              Object.defineProperty(a, N0, {
                value: i,
                enumerable: !1,
                writable: !0
              }), i && (a.input = lO(i)), r.content[n.index] = a;
            }
            break;
          }
          case "thinking_delta": {
            s?.type === "thinking" && (r.content[n.index] = {
              ...s,
              thinking: s.thinking + n.delta.thinking
            });
            break;
          }
          case "signature_delta": {
            s?.type === "thinking" && (r.content[n.index] = {
              ...s,
              signature: n.delta.signature
            });
            break;
          }
          default:
            n.delta;
        }
        return r;
      }
      case "content_block_stop":
        return r;
    }
  }, Symbol.asyncIterator)]() {
    const t = [], n = [];
    let r = !1;
    return this.on("streamEvent", (s) => {
      const i = n.shift();
      i ? i.resolve(s) : t.push(s);
    }), this.on("end", () => {
      r = !0;
      for (const s of n)
        s.resolve(void 0);
      n.length = 0;
    }), this.on("abort", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), this.on("error", (s) => {
      r = !0;
      for (const i of n)
        i.reject(s);
      n.length = 0;
    }), {
      next: async () => t.length ? { value: t.shift(), done: !1 } : r ? { value: void 0, done: !0 } : new Promise((i, a) => n.push({ resolve: i, reject: a })).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new Hn(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
class mO extends zn {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.create({
   *   requests: [
   *     {
   *       custom_id: 'my-custom-id-1',
   *       params: {
   *         max_tokens: 1024,
   *         messages: [
   *           { content: 'Hello, world', role: 'user' },
   *         ],
   *         model: 'claude-sonnet-4-5-20250929',
   *       },
   *     },
   *   ],
   * });
   * ```
   */
  create(t, n) {
    return this._client.post("/v1/messages/batches", { body: t, ...n });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.retrieve(
   *   'message_batch_id',
   * );
   * ```
   */
  retrieve(t, n) {
    return this._client.get(kt`/v1/messages/batches/${t}`, n);
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const messageBatch of client.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(t = {}, n) {
    return this._client.getAPIList("/v1/messages/batches", Vo, { query: t, ...n });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const deletedMessageBatch =
   *   await client.messages.batches.delete('message_batch_id');
   * ```
   */
  delete(t, n) {
    return this._client.delete(kt`/v1/messages/batches/${t}`, n);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.cancel(
   *   'message_batch_id',
   * );
   * ```
   */
  cancel(t, n) {
    return this._client.post(kt`/v1/messages/batches/${t}/cancel`, n);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatchIndividualResponse =
   *   await client.messages.batches.results('message_batch_id');
   * ```
   */
  async results(t, n) {
    const r = await this.retrieve(t);
    if (!r.results_url)
      throw new Se(`No batch \`results_url\`; Has it finished processing? ${r.processing_status} - ${r.id}`);
    return this._client.get(r.results_url, {
      ...n,
      headers: Ce([{ Accept: "application/binary" }, n?.headers]),
      stream: !0,
      __binaryResponse: !0
    })._thenUnwrap((s, i) => ed.fromResponse(i.response, i.controller));
  }
}
class lg extends zn {
  constructor() {
    super(...arguments), this.batches = new mO(this._client);
  }
  create(t, n) {
    t.model in j0 && console.warn(`The model '${t.model}' is deprecated and will reach end-of-life on ${j0[t.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    let r = this._client._options.timeout;
    if (!t.stream && r == null) {
      const s = uO[t.model] ?? void 0;
      r = this._client.calculateNonstreamingTimeout(t.max_tokens, s);
    }
    return this._client.post("/v1/messages", {
      body: t,
      timeout: r ?? 6e5,
      ...n,
      stream: t.stream ?? !1
    });
  }
  /**
   * Create a Message stream
   */
  stream(t, n) {
    return il.createMessage(this, t, n);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const messageTokensCount =
   *   await client.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-opus-4-5-20251101',
   *   });
   * ```
   */
  countTokens(t, n) {
    return this._client.post("/v1/messages/count_tokens", { body: t, ...n });
  }
}
const j0 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-7-sonnet-latest": "February 19th, 2026",
  "claude-3-7-sonnet-20250219": "February 19th, 2026"
};
lg.Batches = mO;
class gO extends zn {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(t, n = {}, r) {
    const { betas: s } = n ?? {};
    return this._client.get(kt`/v1/models/${t}`, {
      ...r,
      headers: Ce([
        { ...s?.toString() != null ? { "anthropic-beta": s?.toString() } : void 0 },
        r?.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   */
  list(t = {}, n) {
    const { betas: r, ...s } = t ?? {};
    return this._client.getAPIList("/v1/models", Vo, {
      query: s,
      ...n,
      headers: Ce([
        { ...r?.toString() != null ? { "anthropic-beta": r?.toString() } : void 0 },
        n?.headers
      ])
    });
  }
}
const Gu = (e) => {
  if (typeof globalThis.process < "u")
    return globalThis.process.env?.[e]?.trim() ?? void 0;
  if (typeof globalThis.Deno < "u")
    return globalThis.Deno.env?.get?.(e)?.trim();
};
var Pp, dg, mc, _O;
const j9 = "\\n\\nHuman:", L9 = "\\n\\nAssistant:";
class ut {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: t = Gu("ANTHROPIC_BASE_URL"), apiKey: n = Gu("ANTHROPIC_API_KEY") ?? null, authToken: r = Gu("ANTHROPIC_AUTH_TOKEN") ?? null, ...s } = {}) {
    Pp.add(this), mc.set(this, void 0);
    const i = {
      apiKey: n,
      authToken: r,
      ...s,
      baseURL: t || "https://api.anthropic.com"
    };
    if (!i.dangerouslyAllowBrowser && r9())
      throw new Se(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Anthropic({ apiKey, dangerouslyAllowBrowser: true });
`);
    this.baseURL = i.baseURL, this.timeout = i.timeout ?? dg.DEFAULT_TIMEOUT, this.logger = i.logger ?? console;
    const a = "warn";
    this.logLevel = a, this.logLevel = v0(i.logLevel, "ClientOptions.logLevel", this) ?? v0(Gu("ANTHROPIC_LOG"), "process.env['ANTHROPIC_LOG']", this) ?? a, this.fetchOptions = i.fetchOptions, this.maxRetries = i.maxRetries ?? 2, this.fetch = i.fetch ?? u9(), W(this, mc, l9), this._options = i, this.apiKey = typeof n == "string" ? n : null, this.authToken = r;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(t) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      authToken: this.authToken,
      ...t
    });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: t, nulls: n }) {
    if (!(t.get("x-api-key") || t.get("authorization")) && !(this.apiKey && t.get("x-api-key")) && !n.has("x-api-key") && !(this.authToken && t.get("authorization")) && !n.has("authorization"))
      throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  async authHeaders(t) {
    return Ce([await this.apiKeyAuth(t), await this.bearerAuth(t)]);
  }
  async apiKeyAuth(t) {
    if (this.apiKey != null)
      return Ce([{ "X-Api-Key": this.apiKey }]);
  }
  async bearerAuth(t) {
    if (this.authToken != null)
      return Ce([{ Authorization: `Bearer ${this.authToken}` }]);
  }
  /**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
  stringifyQuery(t) {
    return Object.entries(t).filter(([n, r]) => typeof r < "u").map(([n, r]) => {
      if (typeof r == "string" || typeof r == "number" || typeof r == "boolean")
        return `${encodeURIComponent(n)}=${encodeURIComponent(r)}`;
      if (r === null)
        return `${encodeURIComponent(n)}=`;
      throw new Se(`Cannot stringify type ${typeof r}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Gs}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${Dk()}`;
  }
  makeStatusError(t, n, r, s) {
    return Ct.generate(t, n, r, s);
  }
  buildURL(t, n, r) {
    const s = !A(this, Pp, "m", _O).call(this) && r || this.baseURL, i = Xz(t) ? new URL(t) : new URL(s + (s.endsWith("/") && t.startsWith("/") ? t.slice(1) : t)), a = this.defaultQuery();
    return Qz(a) || (n = { ...a, ...n }), typeof n == "object" && n && !Array.isArray(n) && (i.search = this.stringifyQuery(n)), i.toString();
  }
  _calculateNonstreamingTimeout(t) {
    if (3600 * t / 128e3 > 600)
      throw new Se("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details");
    return 600 * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(t) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(t, { url: n, options: r }) {
  }
  get(t, n) {
    return this.methodRequest("get", t, n);
  }
  post(t, n) {
    return this.methodRequest("post", t, n);
  }
  patch(t, n) {
    return this.methodRequest("patch", t, n);
  }
  put(t, n) {
    return this.methodRequest("put", t, n);
  }
  delete(t, n) {
    return this.methodRequest("delete", t, n);
  }
  methodRequest(t, n, r) {
    return this.request(Promise.resolve(r).then((s) => ({ method: t, path: n, ...s })));
  }
  request(t, n = null) {
    return new Ql(this, this.makeRequest(t, n, void 0));
  }
  async makeRequest(t, n, r) {
    const s = await t, i = s.maxRetries ?? this.maxRetries;
    n == null && (n = i), await this.prepareOptions(s);
    const { req: a, url: o, timeout: u } = await this.buildRequest(s, {
      retryCount: i - n
    });
    await this.prepareRequest(a, { url: o, options: s });
    const c = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0"), l = r === void 0 ? "" : `, retryOf: ${r}`, d = Date.now();
    if (Mt(this).debug(`[${c}] sending request`, us({
      retryOfRequestLogID: r,
      method: s.method,
      url: o,
      options: s,
      headers: a.headers
    })), s.signal?.aborted)
      throw new Pn();
    const f = new AbortController(), h = await this.fetchWithTimeout(o, a, u, f).catch(Op), p = Date.now();
    if (h instanceof globalThis.Error) {
      const _ = `retrying, ${n} attempts remaining`;
      if (s.signal?.aborted)
        throw new Pn();
      const y = To(h) || /timed? ?out/i.test(String(h) + ("cause" in h ? String(h.cause) : ""));
      if (n)
        return Mt(this).info(`[${c}] connection ${y ? "timed out" : "failed"} - ${_}`), Mt(this).debug(`[${c}] connection ${y ? "timed out" : "failed"} (${_})`, us({
          retryOfRequestLogID: r,
          url: o,
          durationMs: p - d,
          message: h.message
        })), this.retryRequest(s, n, r ?? c);
      throw Mt(this).info(`[${c}] connection ${y ? "timed out" : "failed"} - error; no more retries left`), Mt(this).debug(`[${c}] connection ${y ? "timed out" : "failed"} (error; no more retries left)`, us({
        retryOfRequestLogID: r,
        url: o,
        durationMs: p - d,
        message: h.message
      })), y ? new Uk() : new Xl({ cause: h });
    }
    const g = [...h.headers.entries()].filter(([_]) => _ === "request-id").map(([_, y]) => ", " + _ + ": " + JSON.stringify(y)).join(""), m = `[${c}${l}${g}] ${a.method} ${o} ${h.ok ? "succeeded" : "failed"} with status ${h.status} in ${p - d}ms`;
    if (!h.ok) {
      const _ = await this.shouldRetry(h);
      if (n && _) {
        const O = `retrying, ${n} attempts remaining`;
        return await c9(h.body), Mt(this).info(`${m} - ${O}`), Mt(this).debug(`[${c}] response error (${O})`, us({
          retryOfRequestLogID: r,
          url: h.url,
          status: h.status,
          headers: h.headers,
          durationMs: p - d
        })), this.retryRequest(s, n, r ?? c, h.headers);
      }
      const y = _ ? "error; no more retries left" : "error; not retryable";
      Mt(this).info(`${m} - ${y}`);
      const b = await h.text().catch((O) => Op(O).message), T = Wk(b), x = T ? void 0 : b;
      throw Mt(this).debug(`[${c}] response error (${y})`, us({
        retryOfRequestLogID: r,
        url: h.url,
        status: h.status,
        headers: h.headers,
        message: x,
        durationMs: Date.now() - d
      })), this.makeStatusError(h.status, T, x, h.headers);
    }
    return Mt(this).info(m), Mt(this).debug(`[${c}] response start`, us({
      retryOfRequestLogID: r,
      url: h.url,
      status: h.status,
      headers: h.headers,
      durationMs: p - d
    })), { response: h, options: s, controller: f, requestLogID: c, retryOfRequestLogID: r, startTime: d };
  }
  getAPIList(t, n, r) {
    return this.requestAPIList(n, { method: "get", path: t, ...r });
  }
  requestAPIList(t, n) {
    const r = this.makeRequest(n, null, void 0);
    return new w9(this, r, t);
  }
  async fetchWithTimeout(t, n, r, s) {
    const { signal: i, method: a, ...o } = n || {};
    i && i.addEventListener("abort", () => s.abort());
    const u = setTimeout(() => s.abort(), r), c = globalThis.ReadableStream && o.body instanceof globalThis.ReadableStream || typeof o.body == "object" && o.body !== null && Symbol.asyncIterator in o.body, l = {
      signal: s.signal,
      ...c ? { duplex: "half" } : {},
      method: "GET",
      ...o
    };
    a && (l.method = a.toUpperCase());
    try {
      return await this.fetch.call(void 0, t, l);
    } finally {
      clearTimeout(u);
    }
  }
  async shouldRetry(t) {
    const n = t.headers.get("x-should-retry");
    return n === "true" ? !0 : n === "false" ? !1 : t.status === 408 || t.status === 409 || t.status === 429 || t.status >= 500;
  }
  async retryRequest(t, n, r, s) {
    let i;
    const a = s?.get("retry-after-ms");
    if (a) {
      const u = parseFloat(a);
      Number.isNaN(u) || (i = u);
    }
    const o = s?.get("retry-after");
    if (o && !i) {
      const u = parseFloat(o);
      Number.isNaN(u) ? i = Date.parse(o) - Date.now() : i = u * 1e3;
    }
    if (!(i && 0 <= i && i < 60 * 1e3)) {
      const u = t.maxRetries ?? this.maxRetries;
      i = this.calculateDefaultRetryTimeoutMillis(n, u);
    }
    return await n9(i), this.makeRequest(t, n - 1, r);
  }
  calculateDefaultRetryTimeoutMillis(t, n) {
    const i = n - t, a = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;
    return a * o * 1e3;
  }
  calculateNonstreamingTimeout(t, n) {
    if (36e5 * t / 128e3 > 6e5 || n != null && t > n)
      throw new Se("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details");
    return 6e5;
  }
  async buildRequest(t, { retryCount: n = 0 } = {}) {
    const r = { ...t }, { method: s, path: i, query: a, defaultBaseURL: o } = r, u = this.buildURL(i, a, o);
    "timeout" in r && t9("timeout", r.timeout), r.timeout = r.timeout ?? this.timeout;
    const { bodyHeaders: c, body: l } = this.buildBody({ options: r }), d = await this.buildHeaders({ options: t, method: s, bodyHeaders: c, retryCount: n });
    return { req: {
      method: s,
      headers: d,
      ...r.signal && { signal: r.signal },
      ...globalThis.ReadableStream && l instanceof globalThis.ReadableStream && { duplex: "half" },
      ...l && { body: l },
      ...this.fetchOptions ?? {},
      ...r.fetchOptions ?? {}
    }, url: u, timeout: r.timeout };
  }
  async buildHeaders({ options: t, method: n, bodyHeaders: r, retryCount: s }) {
    let i = {};
    this.idempotencyHeader && n !== "get" && (t.idempotencyKey || (t.idempotencyKey = this.defaultIdempotencyKey()), i[this.idempotencyHeader] = t.idempotencyKey);
    const a = Ce([
      i,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(s),
        ...t.timeout ? { "X-Stainless-Timeout": String(Math.trunc(t.timeout / 1e3)) } : {},
        ...o9(),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
        "anthropic-version": "2023-06-01"
      },
      await this.authHeaders(t),
      this._options.defaultHeaders,
      r,
      t.headers
    ]);
    return this.validateHeaders(a), a.values;
  }
  buildBody({ options: { body: t, headers: n } }) {
    if (!t)
      return { bodyHeaders: void 0, body: void 0 };
    const r = Ce([n]);
    return (
      // Pass raw type verbatim
      ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof DataView || typeof t == "string" && // Preserve legacy string encoding behavior for now
      r.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && t instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      t instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      t instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && t instanceof globalThis.ReadableStream ? { bodyHeaders: void 0, body: t } : typeof t == "object" && (Symbol.asyncIterator in t || Symbol.iterator in t && "next" in t && typeof t.next == "function") ? { bodyHeaders: void 0, body: Kk(t) } : A(this, mc, "f").call(this, { body: t, headers: r })
    );
  }
}
dg = ut, mc = /* @__PURE__ */ new WeakMap(), Pp = /* @__PURE__ */ new WeakSet(), _O = function() {
  return this.baseURL !== "https://api.anthropic.com";
};
ut.Anthropic = dg;
ut.HUMAN_PROMPT = j9;
ut.AI_PROMPT = L9;
ut.DEFAULT_TIMEOUT = 6e5;
ut.AnthropicError = Se;
ut.APIError = Ct;
ut.APIConnectionError = Xl;
ut.APIConnectionTimeoutError = Uk;
ut.APIUserAbortError = Pn;
ut.NotFoundError = Bk;
ut.ConflictError = Zk;
ut.RateLimitError = Hk;
ut.BadRequestError = Fk;
ut.AuthenticationError = zk;
ut.InternalServerError = Gk;
ut.PermissionDeniedError = qk;
ut.UnprocessableEntityError = Vk;
ut.toFile = E9;
class Ho extends ut {
  constructor() {
    super(...arguments), this.completions = new pO(this), this.messages = new lg(this), this.models = new gO(this), this.beta = new Si(this);
  }
}
Ho.Completions = pO;
Ho.Messages = lg;
Ho.Models = gO;
Ho.Beta = Si;
const D9 = /* @__PURE__ */ new Set([
  "date-time",
  "time",
  "date",
  "duration",
  "email",
  "hostname",
  "uri",
  "ipv4",
  "ipv6",
  "uuid"
]);
function U9(e) {
  return JSON.parse(JSON.stringify(e));
}
function F9(e) {
  const t = U9(e);
  return cs(t);
}
function cs(e) {
  const t = {}, n = Ft(e, "$ref");
  if (n !== void 0)
    return t.$ref = n, t;
  const r = Ft(e, "$defs");
  if (r !== void 0) {
    const l = {};
    t.$defs = l;
    for (const [d, f] of Object.entries(r))
      l[d] = cs(f);
  }
  const s = Ft(e, "type"), i = Ft(e, "anyOf"), a = Ft(e, "oneOf"), o = Ft(e, "allOf");
  if (Array.isArray(i))
    t.anyOf = i.map((l) => cs(l));
  else if (Array.isArray(a))
    t.anyOf = a.map((l) => cs(l));
  else if (Array.isArray(o))
    t.allOf = o.map((l) => cs(l));
  else {
    if (s === void 0)
      throw new Error("JSON schema must have a type defined if anyOf/oneOf/allOf are not used");
    t.type = s;
  }
  const u = Ft(e, "description");
  u !== void 0 && (t.description = u);
  const c = Ft(e, "title");
  if (c !== void 0 && (t.title = c), s === "object") {
    const l = Ft(e, "properties") || {};
    t.properties = Object.fromEntries(Object.entries(l).map(([f, h]) => [
      f,
      cs(h)
    ])), Ft(e, "additionalProperties"), t.additionalProperties = !1;
    const d = Ft(e, "required");
    d !== void 0 && (t.required = d);
  } else if (s === "string") {
    const l = Ft(e, "format");
    l !== void 0 && D9.has(l) ? t.format = l : l !== void 0 && (e.format = l);
  } else if (s === "array") {
    const l = Ft(e, "items");
    l !== void 0 && (t.items = cs(l));
    const d = Ft(e, "minItems");
    d !== void 0 && (d === 0 || d === 1) ? t.minItems = d : d !== void 0 && (e.minItems = d);
  }
  if (Object.keys(e).length > 0) {
    const l = t.description;
    t.description = (l ? l + `

` : "") + "{" + Object.entries(e).map(([d, f]) => `${d}: ${JSON.stringify(f)}`).join(", ") + "}";
  }
  return t;
}
const z9 = {
  "claude-opus-4-1": 8192,
  "claude-opus-4": 8192,
  "claude-sonnet-4": 8192,
  "claude-sonnet-3-7-sonnet": 8192,
  "claude-3-5-sonnet": 4096,
  "claude-3-5-haiku": 4096,
  "claude-3-haiku": 2048
}, L0 = 2048;
function q9(e) {
  return e ? Object.entries(z9).find(([n]) => e.startsWith(n))?.[1] ?? L0 : L0;
}
function B9(e) {
  return !!(e.tools && e.tools.length > 0);
}
function Z9(e) {
  for (const t of e.messages ?? [])
    if (typeof t.content != "string") {
      for (const n of t.content ?? []) if (typeof n == "object" && n != null && n.type === "document" && typeof n.citations == "object" && n.citations?.enabled) return !0;
    }
  return !1;
}
function V9(e) {
  return !!(e.thinking && e.thinking.type === "enabled");
}
function H9(e) {
  return "input_schema" in e;
}
function G9(e) {
  const t = [
    "text_editor_",
    "computer_",
    "bash_",
    "web_search_",
    "web_fetch_",
    "str_replace_editor_",
    "str_replace_based_edit_tool_",
    "code_execution_",
    "memory_",
    "tool_search_",
    "mcp_toolset"
  ];
  return typeof e == "object" && e !== null && "type" in e && ("name" in e || "mcp_server_name" in e) && typeof e.type == "string" && t.some((n) => typeof e.type == "string" && e.type.startsWith(n));
}
function W9(e, t, ...n) {
  return Array.from(/* @__PURE__ */ new Set([
    ...e ?? [],
    ...t ?? [],
    ...n.flatMap((r) => Array.from(r))
  ]));
}
function J9(e) {
  if (typeof e.content == "string") return e.content;
  if (Array.isArray(e.content) && e.content.length >= 1 && "input" in e.content[0]) return typeof e.content[0].input == "string" ? e.content[0].input : JSON.stringify(e.content[0].input);
  if (Array.isArray(e.content) && e.content.length >= 1 && "text" in e.content[0] && typeof e.content[0].text == "string") return e.content[0].text;
}
var K9 = class extends bi {
  static lc_name() {
    return "ChatAnthropic";
  }
  get lc_secrets() {
    return {
      anthropicApiKey: "ANTHROPIC_API_KEY",
      apiKey: "ANTHROPIC_API_KEY"
    };
  }
  get lc_aliases() {
    return { modelName: "model" };
  }
  lc_serializable = !0;
  anthropicApiKey;
  apiKey;
  apiUrl;
  temperature;
  topK;
  topP;
  maxTokens;
  modelName = "claude-3-5-sonnet-latest";
  model = "claude-3-5-sonnet-latest";
  invocationKwargs;
  stopSequences;
  streaming = !1;
  clientOptions;
  thinking = { type: "disabled" };
  contextManagement;
  batchClient;
  streamingClient;
  streamUsage = !0;
  betas;
  /**
  * Optional method that returns an initialized underlying Anthropic client.
  * Useful for accessing Anthropic models hosted on other cloud services
  * such as Google Vertex.
  */
  createClient;
  constructor(e) {
    if (super(e ?? {}), this.anthropicApiKey = e?.apiKey ?? e?.anthropicApiKey ?? on("ANTHROPIC_API_KEY"), !this.anthropicApiKey && !e?.createClient) throw new Error("Anthropic API key not found");
    this.clientOptions = e?.clientOptions ?? {}, this.apiKey = this.anthropicApiKey, this.apiUrl = e?.anthropicApiUrl, this.modelName = e?.model ?? e?.modelName ?? this.model, this.model = this.modelName, this.invocationKwargs = e?.invocationKwargs ?? {}, this.topP = e?.topP ?? this.topP, this.temperature = e?.temperature ?? this.temperature, this.topK = e?.topK ?? this.topK, this.maxTokens = e?.maxTokens ?? q9(this.model), this.stopSequences = e?.stopSequences ?? this.stopSequences, this.streaming = e?.streaming ?? !1, this.streamUsage = e?.streamUsage ?? this.streamUsage, this.thinking = e?.thinking ?? this.thinking, this.contextManagement = e?.contextManagement ?? this.contextManagement, this.betas = e?.betas ?? this.betas, this.createClient = e?.createClient ?? ((t) => new Ho(t));
  }
  getLsParams(e) {
    const t = this.invocationParams(e);
    return {
      ls_provider: "anthropic",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: t.temperature ?? void 0,
      ls_max_tokens: t.max_tokens ?? void 0,
      ls_stop: e.stop
    };
  }
  /**
  * Formats LangChain StructuredTools to AnthropicTools.
  *
  * @param {ChatAnthropicCallOptions["tools"]} tools The tools to format
  * @returns {AnthropicTool[] | undefined} The formatted tools, or undefined if none are passed.
  */
  formatStructuredToolToAnthropic(e) {
    if (e)
      return e.map((t) => {
        if (Br(t) && t.extras?.providerToolDefinition) return t.extras.providerToolDefinition;
        if (G9(t) || H9(t)) return t;
        if (vi(t)) return {
          name: t.function.name,
          description: t.function.description,
          input_schema: t.function.parameters
        };
        if (Br(t)) return {
          name: t.name,
          description: t.description,
          input_schema: _t(t.schema) ? it(t.schema) : t.schema,
          ...t.extras ? Pz.parse(t.extras) : {}
        };
        throw new Error(`Unknown tool type passed to ChatAnthropic: ${JSON.stringify(t, null, 2)}`);
      });
  }
  bindTools(e, t) {
    return this.withConfig({
      tools: this.formatStructuredToolToAnthropic(e),
      ...t
    });
  }
  /**
  * Get the parameters used to invoke the model
  */
  invocationParams(e) {
    const t = Rz(e?.tool_choice), n = e?.tools?.reduce((s, i) => {
      if (typeof i == "object" && "type" in i && i.type in o0) {
        const a = o0[i.type];
        if (!s.includes(a)) return [...s, a];
      }
      return s;
    }, []), r = {
      model: this.model,
      stop_sequences: e?.stop ?? this.stopSequences,
      stream: this.streaming,
      max_tokens: this.maxTokens,
      tools: this.formatStructuredToolToAnthropic(e?.tools),
      tool_choice: t,
      thinking: this.thinking,
      context_management: this.contextManagement,
      ...this.invocationKwargs,
      container: e?.container,
      betas: W9(this.betas, e?.betas, n ?? []),
      output_format: e?.output_format,
      mcp_servers: e?.mcp_servers
    };
    if (this.thinking.type === "enabled") {
      if (this.topP !== void 0 && this.topK !== -1) throw new Error("topK is not supported when thinking is enabled");
      if (this.temperature !== void 0 && this.temperature !== 1) throw new Error("temperature is not supported when thinking is enabled");
    } else
      r.temperature = this.temperature, r.top_k = this.topK, r.top_p = this.topP;
    return r;
  }
  /** @ignore */
  _identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams()
    };
  }
  /**
  * Get the identifying parameters for the model
  */
  identifyingParams() {
    return {
      model_name: this.model,
      ...this.invocationParams()
    };
  }
  async *_streamResponseChunks(e, t, n) {
    const r = this.invocationParams(t), s = d0(e), i = {
      ...r,
      ...s,
      stream: !0
    }, a = !B9(i) && !Z9(i) && !V9(i), o = await this.createStreamWithRetry(i, { headers: t.headers });
    for await (const u of o) {
      if (t.signal?.aborted)
        throw o.controller.abort(), new Error("AbortError: User aborted the request.");
      const c = this.streamUsage ?? t.streamUsage, l = Gz(u, {
        streamUsage: c,
        coerceContentToString: a
      });
      if (!l) continue;
      const { chunk: d } = l, f = J9(d), h = new Xn({
        message: new We({
          content: d.content,
          additional_kwargs: d.additional_kwargs,
          tool_call_chunks: d.tool_call_chunks,
          usage_metadata: c ? d.usage_metadata : void 0,
          response_metadata: d.response_metadata,
          id: d.id
        }),
        text: f ?? ""
      });
      yield h, await n?.handleLLMNewToken(f ?? "", void 0, void 0, void 0, void 0, { chunk: h });
    }
  }
  /** @ignore */
  async _generateNonStreaming(e, t, n) {
    const r = await this.completionWithRetry({
      ...t,
      stream: !1,
      ...d0(e)
    }, n), { content: s, ...i } = r, a = Wz(s, i), { role: o, type: u, ...c } = i;
    return {
      generations: a,
      llmOutput: c
    };
  }
  /** @ignore */
  async _generate(e, t, n) {
    if (this.stopSequences && t.stop) throw new Error('"stopSequence" parameter found in input and default params');
    const r = this.invocationParams(t);
    if (r.stream) {
      let s;
      const i = this._streamResponseChunks(e, t, n);
      for await (const a of i) s === void 0 ? s = a : s = s.concat(a);
      if (s === void 0) throw new Error("No chunks returned from Anthropic API.");
      return { generations: [{
        text: s.text,
        message: s.message
      }] };
    } else return this._generateNonStreaming(e, r, {
      signal: t.signal,
      headers: t.headers
    });
  }
  /**
  * Creates a streaming request with retry.
  * @param request The parameters for creating a completion.
  * @param options
  * @returns A streaming request.
  */
  async createStreamWithRetry(e, t) {
    if (!this.streamingClient) {
      const i = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
      this.streamingClient = this.createClient({
        dangerouslyAllowBrowser: !0,
        ...this.clientOptions,
        ...i,
        apiKey: this.apiKey,
        maxRetries: 0
      });
    }
    const { betas: n, ...r } = e, s = async () => {
      try {
        return e?.betas?.length ? await this.streamingClient.beta.messages.create({
          ...r,
          betas: n,
          ...this.invocationKwargs,
          stream: !0
        }, t) : await this.streamingClient.messages.create({
          ...r,
          ...this.invocationKwargs,
          stream: !0
        }, t);
      } catch (i) {
        throw f0(i);
      }
    };
    return this.caller.call(s);
  }
  /** @ignore */
  async completionWithRetry(e, t) {
    if (!this.batchClient) {
      const i = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
      this.batchClient = this.createClient({
        dangerouslyAllowBrowser: !0,
        ...this.clientOptions,
        ...i,
        apiKey: this.apiKey,
        maxRetries: 0
      });
    }
    const { betas: n, ...r } = e, s = async () => {
      try {
        return e?.betas?.length ? await this.batchClient.beta.messages.create({
          ...r,
          ...this.invocationKwargs,
          betas: n
        }, t) : await this.batchClient.messages.create({
          ...r,
          ...this.invocationKwargs
        }, t);
      } catch (i) {
        throw f0(i);
      }
    };
    return this.caller.callWithOptions({ signal: t.signal ?? void 0 }, s);
  }
  _llmType() {
    return "anthropic";
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatAnthropic({ model: "claude-opus-4-0" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 200000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return Kz[this.model] ?? {};
  }
  withStructuredOutput(e, t) {
    let n, r;
    const { schema: s, name: i, includeRaw: a } = {
      ...t,
      schema: e
    };
    let o = t?.method ?? "functionCalling";
    if (o === "jsonMode" && (console.warn('"jsonMode" is not supported for Anthropic models. Falling back to "jsonSchema".'), o = "jsonSchema"), o === "jsonSchema") {
      r = _t(s) ? bs.fromZodSchema(s) : new Ss();
      const d = F9(it(s));
      n = this.withConfig({
        outputVersion: "v0",
        output_format: {
          type: "json_schema",
          schema: d
        },
        betas: ["structured-outputs-2025-11-13"],
        ls_structured_output_format: {
          kwargs: { method: "json_schema" },
          schema: d
        }
      });
    } else if (o === "functionCalling") {
      let d = i ?? "extract", f;
      if (_t(s)) {
        const h = it(s);
        f = [{
          name: d,
          description: h.description ?? "A function available to call.",
          input_schema: h
        }], r = new a0({
          returnSingle: !0,
          keyName: d,
          zodSchema: s
        });
      } else {
        let h;
        typeof s.name == "string" && typeof s.description == "string" && typeof s.input_schema == "object" && s.input_schema != null ? (h = s, d = s.name) : h = {
          name: d,
          description: s.description ?? "",
          input_schema: s
        }, f = [h], r = new a0({
          returnSingle: !0,
          keyName: d
        });
      }
      if (this.thinking?.type === "enabled") {
        const h = "Anthropic structured output relies on forced tool calling, which is not supported when `thinking` is enabled. This method will raise OutputParserException if tool calls are not generated. Consider disabling `thinking` or adjust your prompt to ensure the tool is called.";
        console.warn(h), n = this.withConfig({
          outputVersion: "v0",
          tools: f,
          ls_structured_output_format: {
            kwargs: { method: "functionCalling" },
            schema: it(s)
          }
        });
        const p = (g) => {
          if (!g.tool_calls || g.tool_calls.length === 0) throw new Error(h);
          return g;
        };
        n = n.pipe(p);
      } else n = this.withConfig({
        outputVersion: "v0",
        tools: f,
        tool_choice: {
          type: "tool",
          name: d
        },
        ls_structured_output_format: {
          kwargs: { method: "functionCalling" },
          schema: it(s)
        }
      });
    } else throw new TypeError(`Unrecognized structured output method '${o}'. Expected 'functionCalling' or 'jsonSchema'`);
    if (!a) return n.pipe(r).withConfig({ runName: "ChatAnthropicStructuredOutput" });
    const u = _n.assign({ parsed: (d, f) => r.invoke(d.raw, f) }), c = _n.assign({ parsed: () => null }), l = u.withFallbacks({ fallbacks: [c] });
    return Kr.from([{ raw: n }, l]).withConfig({ runName: "StructuredOutputRunnable" });
  }
}, Y9 = class extends K9 {
};
const X9 = we({
  command: Ee("view"),
  path: Ie()
}), Q9 = we({
  command: Ee("create"),
  path: Ie(),
  file_text: Ie()
}), e3 = we({
  command: Ee("str_replace"),
  path: Ie(),
  old_str: Ie(),
  new_str: Ie()
}), t3 = we({
  command: Ee("insert"),
  path: Ie(),
  insert_line: ze(),
  insert_text: Ie()
}), n3 = we({
  command: Ee("delete"),
  path: Ie()
}), r3 = we({
  command: Ee("rename"),
  old_path: Ie(),
  new_path: Ie()
});
As("command", [
  X9,
  Q9,
  e3,
  t3,
  n3,
  r3
]);
const s3 = we({
  command: Ee("view"),
  path: Ie(),
  view_range: eg([ze(), ze()]).optional()
}), i3 = we({
  command: Ee("str_replace"),
  path: Ie(),
  old_str: Ie(),
  new_str: Ie()
}), a3 = we({
  command: Ee("create"),
  path: Ie(),
  file_text: Ie()
}), o3 = we({
  command: Ee("insert"),
  path: Ie(),
  insert_line: ze(),
  new_str: Ie()
});
As("command", [
  s3,
  i3,
  a3,
  o3
]);
const Dn = eg([ze(), ze()]), yO = we({ action: Ee("screenshot") }), wO = we({
  action: Ee("left_click"),
  coordinate: Dn
}), vO = we({
  action: Ee("right_click"),
  coordinate: Dn
}), bO = we({
  action: Ee("middle_click"),
  coordinate: Dn
}), SO = we({
  action: Ee("double_click"),
  coordinate: Dn
}), TO = we({
  action: Ee("triple_click"),
  coordinate: Dn
}), xO = we({
  action: Ee("left_click_drag"),
  start_coordinate: Dn,
  end_coordinate: Dn
}), EO = we({
  action: Ee("left_mouse_down"),
  coordinate: Dn
}), kO = we({
  action: Ee("left_mouse_up"),
  coordinate: Dn
}), OO = we({
  action: Ee("scroll"),
  coordinate: Dn,
  scroll_direction: Vl([
    "up",
    "down",
    "left",
    "right"
  ]),
  scroll_amount: ze()
}), IO = we({
  action: Ee("type"),
  text: Ie()
}), AO = we({
  action: Ee("key"),
  key: Ie()
}), CO = we({
  action: Ee("mouse_move"),
  coordinate: Dn
}), $O = we({
  action: Ee("hold_key"),
  key: Ie()
}), RO = we({
  action: Ee("wait"),
  duration: ze().optional()
}), u3 = we({
  action: Ee("zoom"),
  region: eg([
    ze(),
    ze(),
    ze(),
    ze()
  ])
});
As("action", [
  yO,
  wO,
  vO,
  bO,
  SO,
  TO,
  xO,
  EO,
  kO,
  OO,
  IO,
  AO,
  CO,
  $O,
  RO
]);
As("action", [
  yO,
  wO,
  vO,
  bO,
  SO,
  TO,
  xO,
  EO,
  kO,
  OO,
  IO,
  AO,
  CO,
  $O,
  RO,
  u3
]);
const c3 = we({ command: Ie().describe("The bash command to run") }), l3 = we({ restart: Ee(!0).describe("Set to true to restart the bash session") });
ok([c3, l3]);
function Ts(e) {
  if (typeof e == "object" && e !== null) {
    const t = { ...e };
    "additionalProperties" in t && delete t.additionalProperties, "$schema" in t && delete t.$schema, "strict" in t && delete t.strict;
    for (const n in t) n in t && (Array.isArray(t[n]) ? t[n] = t[n].map(Ts) : typeof t[n] == "object" && t[n] !== null && (t[n] = Ts(t[n])));
    return t;
  }
  return e;
}
function Np(e) {
  const t = Ts(_t(e) ? it(e) : e), { $schema: n, ...r } = t;
  return r;
}
function d3(e) {
  const t = Ts(e), { $schema: n, ...r } = t;
  return r;
}
const vt = [];
for (let e = 0; e < 256; ++e)
  vt.push((e + 256).toString(16).slice(1));
function f3(e, t = 0) {
  return (vt[e[t + 0]] + vt[e[t + 1]] + vt[e[t + 2]] + vt[e[t + 3]] + "-" + vt[e[t + 4]] + vt[e[t + 5]] + "-" + vt[e[t + 6]] + vt[e[t + 7]] + "-" + vt[e[t + 8]] + vt[e[t + 9]] + "-" + vt[e[t + 10]] + vt[e[t + 11]] + vt[e[t + 12]] + vt[e[t + 13]] + vt[e[t + 14]] + vt[e[t + 15]]).toLowerCase();
}
const gc = new Uint8Array(256);
let Wu = gc.length;
function h3() {
  return Wu > gc.length - 16 && (aI(gc), Wu = 0), gc.slice(Wu, Wu += 16);
}
const D0 = { randomUUID: oI };
function PO(e, t, n) {
  if (D0.randomUUID && !e)
    return D0.randomUUID();
  e = e || {};
  const r = e.random ?? e.rng?.() ?? h3();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, f3(r);
}
const fg = "__gemini_function_call_thought_signatures__", p3 = "ErYCCrMCAdHtim9kOoOkrPiCNVsmlpMIKd7ZMxgiFbVQOkgp7nlLcDMzVsZwIzvuT7nQROivoXA72ccC2lSDvR0Gh7dkWaGuj7ctv6t7ZceHnecx0QYa+ix8tYpRfjhyWozQ49lWiws6+YGjCt10KRTyWsZ2h6O7iHTYJwKIRwGUHRKy/qK/6kFxJm5ML00gLq4D8s5Z6DBpp2ZlR+uF4G8jJgeWQgyHWVdx2wGYElaceVAc66tZdPQRdOHpWtgYSI1YdaXgVI8KHY3/EfNc2YqqMIulvkDBAnuMhkAjV9xmBa54Tq+ih3Im4+r3DzqhGqYdsSkhS0kZMwte4Hjs65dZzCw9lANxIqYi1DJ639WNPYihp/DCJCos7o+/EeSPJaio5sgWDyUnMGkY1atsJZ+m7pj7DD5tvQ==", m3 = (e) => e();
function g3(e) {
  return Hr.isInstance(e) ? e.role : e.type;
}
function _3(e) {
  switch (e) {
    case "supervisor":
    case "ai":
    case "model":
      return "model";
    case "system":
      return "system";
    case "human":
      return "user";
    case "tool":
    case "function":
      return "function";
    default:
      throw new Error(`Unknown / unsupported author: ${e}`);
  }
}
function y3(e) {
  if ("mimeType" in e && "data" in e) return { inlineData: {
    mimeType: e.mimeType,
    data: e.data
  } };
  if ("mimeType" in e && "fileUri" in e) return { fileData: {
    mimeType: e.mimeType,
    fileUri: e.fileUri
  } };
  throw new Error("Invalid media content");
}
function w3(e, t) {
  return t.map((n) => Dr(n) ? n.tool_calls ?? [] : []).flat().find((n) => n.id === e.tool_call_id)?.name;
}
function v3(e) {
  return {
    providerName: "Google Gemini",
    fromStandardTextBlock(n) {
      return { text: n.text };
    },
    fromStandardImageBlock(n) {
      if (!e) throw new Error("This model does not support images");
      if (n.source_type === "url") {
        const r = Gn({ dataUrl: n.url });
        return r ? { inlineData: {
          mimeType: r.mime_type,
          data: r.data
        } } : { fileData: {
          mimeType: n.mime_type ?? "",
          fileUri: n.url
        } };
      }
      if (n.source_type === "base64") return { inlineData: {
        mimeType: n.mime_type ?? "",
        data: n.data
      } };
      throw new Error(`Unsupported source type: ${n.source_type}`);
    },
    fromStandardAudioBlock(n) {
      if (!e) throw new Error("This model does not support audio");
      if (n.source_type === "url") {
        const r = Gn({ dataUrl: n.url });
        return r ? { inlineData: {
          mimeType: r.mime_type,
          data: r.data
        } } : { fileData: {
          mimeType: n.mime_type ?? "",
          fileUri: n.url
        } };
      }
      if (n.source_type === "base64") return { inlineData: {
        mimeType: n.mime_type ?? "",
        data: n.data
      } };
      throw new Error(`Unsupported source type: ${n.source_type}`);
    },
    fromStandardFileBlock(n) {
      if (!e) throw new Error("This model does not support files");
      if (n.source_type === "text") return { text: n.text };
      if (n.source_type === "url") {
        const r = Gn({ dataUrl: n.url });
        return r ? { inlineData: {
          mimeType: r.mime_type,
          data: r.data
        } } : { fileData: {
          mimeType: n.mime_type ?? "",
          fileUri: n.url
        } };
      }
      if (n.source_type === "base64") return { inlineData: {
        mimeType: n.mime_type ?? "",
        data: n.data
      } };
      throw new Error(`Unsupported source type: ${n.source_type}`);
    }
  };
}
function U0(e, t) {
  if (gn(e)) return Co(e, v3(t));
  if (e.type === "text") return { text: e.text };
  if (e.type === "executableCode") return { executableCode: e.executableCode };
  if (e.type === "codeExecutionResult") return { codeExecutionResult: e.codeExecutionResult };
  if (e.type === "image_url") {
    if (!t) throw new Error("This model does not support images");
    let n;
    if (typeof e.image_url == "string") n = e.image_url;
    else if (typeof e.image_url == "object" && "url" in e.image_url) n = e.image_url.url;
    else throw new Error("Please provide image as base64 encoded data URL");
    const [r, s] = n.split(",");
    if (!r.startsWith("data:")) throw new Error("Please provide image as base64 encoded data URL");
    const [i, a] = r.replace(/^data:/, "").split(";");
    if (a !== "base64") throw new Error("Please provide image as base64 encoded data URL");
    return { inlineData: {
      data: s,
      mimeType: i
    } };
  } else {
    if (e.type === "media") return y3(e);
    if (e.type === "tool_use") return { functionCall: {
      name: e.name,
      args: e.input
    } };
    if (e.type?.includes("/") && e.type.split("/").length === 2 && "data" in e && typeof e.data == "string") return { inlineData: {
      mimeType: e.type,
      data: e.data
    } };
    if ("functionCall" in e) return;
    throw "type" in e ? new Error(`Unknown content type ${e.type}`) : new Error(`Unknown content ${JSON.stringify(e)}`);
  }
}
function b3(e, t, n, r) {
  if (_m(e)) {
    const o = e.name ?? w3(e, n);
    if (o === void 0) throw new Error(`Google requires a tool name for each tool call response, and we could not infer a called tool name for ToolMessage "${e.id}" from your passed messages. Please populate a "name" field on that ToolMessage explicitly.`);
    const u = Array.isArray(e.content) ? e.content.map((c) => U0(c, t)).filter((c) => c !== void 0) : e.content;
    return e.status === "error" ? [{ functionResponse: {
      name: o,
      response: { error: { details: u } }
    } }] : [{ functionResponse: {
      name: o,
      response: { result: u }
    } }];
  }
  let s = [];
  const i = [];
  typeof e.content == "string" && e.content && i.push({ text: e.content }), Array.isArray(e.content) && i.push(...e.content.map((o) => U0(o, t)).filter((o) => o !== void 0));
  const a = e.additional_kwargs?.[fg];
  return Dr(e) && e.tool_calls?.length && (s = e.tool_calls.map((o) => {
    const u = m3(() => {
      if (o.id) {
        const c = a?.[o.id];
        if (c) return c;
      }
      return r?.includes("gemini-3") ? p3 : "";
    });
    return {
      functionCall: {
        name: o.name,
        args: o.args
      },
      ...u ? { thoughtSignature: u } : {}
    };
  })), [...i, ...s];
}
function F0(e, t, n = !1, r) {
  return e.reduce((s, i, a) => {
    if (!ur(i)) throw new Error("Unsupported message input");
    const o = g3(i);
    if (o === "system" && a !== 0) throw new Error("System message should be the first one");
    const u = _3(o), c = s.content[s.content.length];
    if (!s.mergeWithPreviousContent && c && c.role === u) throw new Error("Google Generative AI requires alternate messages between authors");
    const l = b3(i, t, e.slice(0, a), r);
    if (s.mergeWithPreviousContent) {
      const h = s.content[s.content.length - 1];
      if (!h) throw new Error("There was a problem parsing your system message. Please try a prompt without one.");
      return h.parts.push(...l), {
        mergeWithPreviousContent: !1,
        content: s.content
      };
    }
    let d = u;
    (d === "function" || d === "system" && !n) && (d = "user");
    const f = {
      role: d,
      parts: l
    };
    return {
      mergeWithPreviousContent: o === "system" && !n,
      content: [...s.content, f]
    };
  }, {
    content: [],
    mergeWithPreviousContent: !1
  }).content;
}
function S3(e, t) {
  if (!e.candidates || e.candidates.length === 0 || !e.candidates[0]) return {
    generations: [],
    llmOutput: { filters: e.promptFeedback }
  };
  const [n] = e.candidates, { content: r, ...s } = n, i = r.parts?.reduce((d, f) => ("functionCall" in f && f.functionCall && d.push({
    ...f,
    id: "id" in f.functionCall && typeof f.functionCall.id == "string" ? f.functionCall.id : PO()
  }), d), []);
  let a;
  const o = r?.parts;
  Array.isArray(o) && o.length === 1 && "text" in o[0] && o[0].text && !o[0].thought ? a = o[0].text : Array.isArray(o) && o.length > 0 ? a = o.map((d) => d.thought && "text" in d && d.text ? {
    type: "thinking",
    thinking: d.text,
    ...d.thoughtSignature ? { signature: d.thoughtSignature } : {}
  } : "text" in d ? {
    type: "text",
    text: d.text
  } : "inlineData" in d ? {
    type: "inlineData",
    inlineData: d.inlineData
  } : "functionCall" in d ? {
    type: "functionCall",
    functionCall: d.functionCall
  } : "functionResponse" in d ? {
    type: "functionResponse",
    functionResponse: d.functionResponse
  } : "fileData" in d ? {
    type: "fileData",
    fileData: d.fileData
  } : "executableCode" in d ? {
    type: "executableCode",
    executableCode: d.executableCode
  } : "codeExecutionResult" in d ? {
    type: "codeExecutionResult",
    codeExecutionResult: d.codeExecutionResult
  } : d) : a = [];
  const u = i?.reduce((d, f) => ("thoughtSignature" in f && typeof f.thoughtSignature == "string" && (d[f.id] = f.thoughtSignature), d), {});
  let c = "";
  return typeof a == "string" ? c = a : Array.isArray(a) && a.length > 0 && (c = a.find((f) => "text" in f)?.text ?? c), {
    generations: [{
      text: c,
      message: new rt({
        content: a ?? "",
        tool_calls: i?.map((d) => ({
          type: "tool_call",
          id: d.id,
          name: d.functionCall.name,
          args: d.functionCall.args
        })),
        additional_kwargs: {
          ...s,
          [fg]: u
        },
        usage_metadata: t?.usageMetadata
      }),
      generationInfo: s
    }],
    llmOutput: { tokenUsage: {
      promptTokens: t?.usageMetadata?.input_tokens,
      completionTokens: t?.usageMetadata?.output_tokens,
      totalTokens: t?.usageMetadata?.total_tokens
    } }
  };
}
function T3(e, t) {
  if (!e.candidates || e.candidates.length === 0) return null;
  const [n] = e.candidates, { content: r, ...s } = n, i = r.parts?.reduce((d, f) => ("functionCall" in f && f.functionCall && d.push({
    ...f,
    id: "id" in f.functionCall && typeof f.functionCall.id == "string" ? f.functionCall.id : PO()
  }), d), []);
  let a;
  const o = r?.parts;
  Array.isArray(o) && o.every((d) => "text" in d && !d.thought) ? a = o.map((d) => d.text).join("") : Array.isArray(o) ? a = o.map((d) => d.thought && "text" in d && d.text ? {
    type: "thinking",
    thinking: d.text,
    ...d.thoughtSignature ? { signature: d.thoughtSignature } : {}
  } : "text" in d ? {
    type: "text",
    text: d.text
  } : "inlineData" in d ? {
    type: "inlineData",
    inlineData: d.inlineData
  } : "functionCall" in d ? {
    type: "functionCall",
    functionCall: d.functionCall
  } : "functionResponse" in d ? {
    type: "functionResponse",
    functionResponse: d.functionResponse
  } : "fileData" in d ? {
    type: "fileData",
    fileData: d.fileData
  } : "executableCode" in d ? {
    type: "executableCode",
    executableCode: d.executableCode
  } : "codeExecutionResult" in d ? {
    type: "codeExecutionResult",
    codeExecutionResult: d.codeExecutionResult
  } : d) : a = [];
  let u = "";
  a && typeof a == "string" ? u = a : Array.isArray(a) && (u = a.find((f) => "text" in f)?.text ?? "");
  const c = [];
  i && c.push(...i.map((d) => ({
    type: "tool_call_chunk",
    id: d.id,
    name: d.functionCall.name,
    args: JSON.stringify(d.functionCall.args)
  })));
  const l = i?.reduce((d, f) => ("thoughtSignature" in f && typeof f.thoughtSignature == "string" && (d[f.id] = f.thoughtSignature), d), {});
  return new Xn({
    text: u,
    message: new We({
      content: a || "",
      name: r ? r.role : void 0,
      tool_call_chunks: c,
      additional_kwargs: { [fg]: l },
      response_metadata: { model_provider: "google-genai" },
      usage_metadata: t.usageMetadata
    }),
    generationInfo: s
  });
}
function x3(e) {
  return e.every((t) => "functionDeclarations" in t && Array.isArray(t.functionDeclarations)) ? e : [{ functionDeclarations: e.map((t) => {
    if (Br(t)) {
      const n = Np(t.schema);
      return n.type === "object" && "properties" in n && Object.keys(n.properties).length === 0 ? {
        name: t.name,
        description: t.description
      } : {
        name: t.name,
        description: t.description,
        parameters: n
      };
    }
    return vi(t) ? {
      name: t.function.name,
      description: t.function.description ?? "A function available to call.",
      parameters: d3(t.function.parameters)
    } : t;
  }) }];
}
function z0(e, t) {
  const n = {
    input_tokens: e?.promptTokenCount ?? 0,
    output_tokens: e?.candidatesTokenCount ?? 0,
    total_tokens: e?.totalTokenCount ?? 0
  };
  if (e?.cachedContentTokenCount && (n.input_token_details ??= {}, n.input_token_details.cache_read = e.cachedContentTokenCount), t === "gemini-3-pro-preview") {
    const r = Math.max(0, e?.promptTokenCount ?? -2e5), s = Math.max(0, e?.cachedContentTokenCount ?? -2e5);
    r && (n.input_token_details = {
      ...n.input_token_details,
      over_200k: r
    }), s && (n.input_token_details = {
      ...n.input_token_details,
      cache_read_over_200k: s
    });
  }
  return n;
}
var q0 = class extends Wl {
  static lc_name() {
    return "GoogleGenerativeAIToolsOutputParser";
  }
  lc_namespace = [
    "langchain",
    "google_genai",
    "output_parsers"
  ];
  returnId = !1;
  /** The type of tool calls to return. */
  keyName;
  /** Whether to return only the first tool call. */
  returnSingle = !1;
  zodSchema;
  constructor(e) {
    super(e), this.keyName = e.keyName, this.returnSingle = e.returnSingle ?? this.returnSingle, this.zodSchema = e.zodSchema;
  }
  async _validateResult(e) {
    if (this.zodSchema === void 0) return e;
    const t = await Ul(this.zodSchema, e);
    if (t.success) return t.data;
    throw new mn(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(t.error.issues)}`, JSON.stringify(e, null, 2));
  }
  async parseResult(e) {
    const t = e.flatMap((s) => {
      const { message: i } = s;
      return !("tool_calls" in i) || !Array.isArray(i.tool_calls) ? [] : i.tool_calls;
    });
    if (t[0] === void 0) throw new Error("No parseable tool calls provided to GoogleGenerativeAIToolsOutputParser.");
    const [n] = t;
    return await this._validateResult(n.args);
  }
}, B0;
(function(e) {
  e.STRING = "string", e.NUMBER = "number", e.INTEGER = "integer", e.BOOLEAN = "boolean", e.ARRAY = "array", e.OBJECT = "object";
})(B0 || (B0 = {}));
var Z0;
(function(e) {
  e.LANGUAGE_UNSPECIFIED = "language_unspecified", e.PYTHON = "python";
})(Z0 || (Z0 = {}));
var V0;
(function(e) {
  e.OUTCOME_UNSPECIFIED = "outcome_unspecified", e.OUTCOME_OK = "outcome_ok", e.OUTCOME_FAILED = "outcome_failed", e.OUTCOME_DEADLINE_EXCEEDED = "outcome_deadline_exceeded";
})(V0 || (V0 = {}));
const H0 = ["user", "model", "function", "system"];
var G0;
(function(e) {
  e.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", e.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", e.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", e.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", e.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", e.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(G0 || (G0 = {}));
var W0;
(function(e) {
  e.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", e.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", e.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", e.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", e.BLOCK_NONE = "BLOCK_NONE";
})(W0 || (W0 = {}));
var J0;
(function(e) {
  e.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", e.NEGLIGIBLE = "NEGLIGIBLE", e.LOW = "LOW", e.MEDIUM = "MEDIUM", e.HIGH = "HIGH";
})(J0 || (J0 = {}));
var K0;
(function(e) {
  e.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", e.SAFETY = "SAFETY", e.OTHER = "OTHER";
})(K0 || (K0 = {}));
var ao;
(function(e) {
  e.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", e.STOP = "STOP", e.MAX_TOKENS = "MAX_TOKENS", e.SAFETY = "SAFETY", e.RECITATION = "RECITATION", e.LANGUAGE = "LANGUAGE", e.BLOCKLIST = "BLOCKLIST", e.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", e.SPII = "SPII", e.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", e.OTHER = "OTHER";
})(ao || (ao = {}));
var Y0;
(function(e) {
  e.TASK_TYPE_UNSPECIFIED = "TASK_TYPE_UNSPECIFIED", e.RETRIEVAL_QUERY = "RETRIEVAL_QUERY", e.RETRIEVAL_DOCUMENT = "RETRIEVAL_DOCUMENT", e.SEMANTIC_SIMILARITY = "SEMANTIC_SIMILARITY", e.CLASSIFICATION = "CLASSIFICATION", e.CLUSTERING = "CLUSTERING";
})(Y0 || (Y0 = {}));
var ei;
(function(e) {
  e.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", e.AUTO = "AUTO", e.ANY = "ANY", e.NONE = "NONE";
})(ei || (ei = {}));
var X0;
(function(e) {
  e.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", e.MODE_DYNAMIC = "MODE_DYNAMIC";
})(X0 || (X0 = {}));
class It extends Error {
  constructor(t) {
    super(`[GoogleGenerativeAI Error]: ${t}`);
  }
}
class Fs extends It {
  constructor(t, n) {
    super(t), this.response = n;
  }
}
class NO extends It {
  constructor(t, n, r, s) {
    super(t), this.status = n, this.statusText = r, this.errorDetails = s;
  }
}
class jr extends It {
}
class MO extends It {
}
const E3 = "https://generativelanguage.googleapis.com", k3 = "v1beta", O3 = "0.24.1", I3 = "genai-js";
var xs;
(function(e) {
  e.GENERATE_CONTENT = "generateContent", e.STREAM_GENERATE_CONTENT = "streamGenerateContent", e.COUNT_TOKENS = "countTokens", e.EMBED_CONTENT = "embedContent", e.BATCH_EMBED_CONTENTS = "batchEmbedContents";
})(xs || (xs = {}));
class A3 {
  constructor(t, n, r, s, i) {
    this.model = t, this.task = n, this.apiKey = r, this.stream = s, this.requestOptions = i;
  }
  toString() {
    var t, n;
    const r = ((t = this.requestOptions) === null || t === void 0 ? void 0 : t.apiVersion) || k3;
    let i = `${((n = this.requestOptions) === null || n === void 0 ? void 0 : n.baseUrl) || E3}/${r}/${this.model}:${this.task}`;
    return this.stream && (i += "?alt=sse"), i;
  }
}
function C3(e) {
  const t = [];
  return e?.apiClient && t.push(e.apiClient), t.push(`${I3}/${O3}`), t.join(" ");
}
async function $3(e) {
  var t;
  const n = new Headers();
  n.append("Content-Type", "application/json"), n.append("x-goog-api-client", C3(e.requestOptions)), n.append("x-goog-api-key", e.apiKey);
  let r = (t = e.requestOptions) === null || t === void 0 ? void 0 : t.customHeaders;
  if (r) {
    if (!(r instanceof Headers))
      try {
        r = new Headers(r);
      } catch (s) {
        throw new jr(`unable to convert customHeaders value ${JSON.stringify(r)} to Headers: ${s.message}`);
      }
    for (const [s, i] of r.entries()) {
      if (s === "x-goog-api-key")
        throw new jr(`Cannot set reserved header name ${s}`);
      if (s === "x-goog-api-client")
        throw new jr(`Header name ${s} can only be set using the apiClient field`);
      n.append(s, i);
    }
  }
  return n;
}
async function R3(e, t, n, r, s, i) {
  const a = new A3(e, t, n, r, i);
  return {
    url: a.toString(),
    fetchOptions: Object.assign(Object.assign({}, j3(i)), { method: "POST", headers: await $3(a), body: s })
  };
}
async function Go(e, t, n, r, s, i = {}, a = fetch) {
  const { url: o, fetchOptions: u } = await R3(e, t, n, r, s, i);
  return P3(o, u, a);
}
async function P3(e, t, n = fetch) {
  let r;
  try {
    r = await n(e, t);
  } catch (s) {
    N3(s, e);
  }
  return r.ok || await M3(r, e), r;
}
function N3(e, t) {
  let n = e;
  throw n.name === "AbortError" ? (n = new MO(`Request aborted when fetching ${t.toString()}: ${e.message}`), n.stack = e.stack) : e instanceof NO || e instanceof jr || (n = new It(`Error fetching from ${t.toString()}: ${e.message}`), n.stack = e.stack), n;
}
async function M3(e, t) {
  let n = "", r;
  try {
    const s = await e.json();
    n = s.error.message, s.error.details && (n += ` ${JSON.stringify(s.error.details)}`, r = s.error.details);
  } catch {
  }
  throw new NO(`Error fetching from ${t.toString()}: [${e.status} ${e.statusText}] ${n}`, e.status, e.statusText, r);
}
function j3(e) {
  const t = {};
  if (e?.signal !== void 0 || e?.timeout >= 0) {
    const n = new AbortController();
    e?.timeout >= 0 && setTimeout(() => n.abort(), e.timeout), e?.signal && e.signal.addEventListener("abort", () => {
      n.abort();
    }), t.signal = n.signal;
  }
  return t;
}
function hg(e) {
  return e.text = () => {
    if (e.candidates && e.candidates.length > 0) {
      if (e.candidates.length > 1 && console.warn(`This response had ${e.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`), _c(e.candidates[0]))
        throw new Fs(`${Rr(e)}`, e);
      return L3(e);
    } else if (e.promptFeedback)
      throw new Fs(`Text not available. ${Rr(e)}`, e);
    return "";
  }, e.functionCall = () => {
    if (e.candidates && e.candidates.length > 0) {
      if (e.candidates.length > 1 && console.warn(`This response had ${e.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`), _c(e.candidates[0]))
        throw new Fs(`${Rr(e)}`, e);
      return console.warn("response.functionCall() is deprecated. Use response.functionCalls() instead."), Q0(e)[0];
    } else if (e.promptFeedback)
      throw new Fs(`Function call not available. ${Rr(e)}`, e);
  }, e.functionCalls = () => {
    if (e.candidates && e.candidates.length > 0) {
      if (e.candidates.length > 1 && console.warn(`This response had ${e.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`), _c(e.candidates[0]))
        throw new Fs(`${Rr(e)}`, e);
      return Q0(e);
    } else if (e.promptFeedback)
      throw new Fs(`Function call not available. ${Rr(e)}`, e);
  }, e;
}
function L3(e) {
  var t, n, r, s;
  const i = [];
  if (!((n = (t = e.candidates) === null || t === void 0 ? void 0 : t[0].content) === null || n === void 0) && n.parts)
    for (const a of (s = (r = e.candidates) === null || r === void 0 ? void 0 : r[0].content) === null || s === void 0 ? void 0 : s.parts)
      a.text && i.push(a.text), a.executableCode && i.push("\n```" + a.executableCode.language + `
` + a.executableCode.code + "\n```\n"), a.codeExecutionResult && i.push("\n```\n" + a.codeExecutionResult.output + "\n```\n");
  return i.length > 0 ? i.join("") : "";
}
function Q0(e) {
  var t, n, r, s;
  const i = [];
  if (!((n = (t = e.candidates) === null || t === void 0 ? void 0 : t[0].content) === null || n === void 0) && n.parts)
    for (const a of (s = (r = e.candidates) === null || r === void 0 ? void 0 : r[0].content) === null || s === void 0 ? void 0 : s.parts)
      a.functionCall && i.push(a.functionCall);
  if (i.length > 0)
    return i;
}
const D3 = [
  ao.RECITATION,
  ao.SAFETY,
  ao.LANGUAGE
];
function _c(e) {
  return !!e.finishReason && D3.includes(e.finishReason);
}
function Rr(e) {
  var t, n, r;
  let s = "";
  if ((!e.candidates || e.candidates.length === 0) && e.promptFeedback)
    s += "Response was blocked", !((t = e.promptFeedback) === null || t === void 0) && t.blockReason && (s += ` due to ${e.promptFeedback.blockReason}`), !((n = e.promptFeedback) === null || n === void 0) && n.blockReasonMessage && (s += `: ${e.promptFeedback.blockReasonMessage}`);
  else if (!((r = e.candidates) === null || r === void 0) && r[0]) {
    const i = e.candidates[0];
    _c(i) && (s += `Candidate was blocked due to ${i.finishReason}`, i.finishMessage && (s += `: ${i.finishMessage}`));
  }
  return s;
}
function xo(e) {
  return this instanceof xo ? (this.v = e, this) : new xo(e);
}
function U3(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), s, i = [];
  return s = {}, a("next"), a("throw"), a("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function a(f) {
    r[f] && (s[f] = function(h) {
      return new Promise(function(p, g) {
        i.push([f, h, p, g]) > 1 || o(f, h);
      });
    });
  }
  function o(f, h) {
    try {
      u(r[f](h));
    } catch (p) {
      d(i[0][3], p);
    }
  }
  function u(f) {
    f.value instanceof xo ? Promise.resolve(f.value.v).then(c, l) : d(i[0][2], f);
  }
  function c(f) {
    o("next", f);
  }
  function l(f) {
    o("throw", f);
  }
  function d(f, h) {
    f(h), i.shift(), i.length && o(i[0][0], i[0][1]);
  }
}
const eb = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function F3(e) {
  const t = e.body.pipeThrough(new TextDecoderStream("utf8", { fatal: !0 })), n = B3(t), [r, s] = n.tee();
  return {
    stream: q3(r),
    response: z3(s)
  };
}
async function z3(e) {
  const t = [], n = e.getReader();
  for (; ; ) {
    const { done: r, value: s } = await n.read();
    if (r)
      return hg(Z3(t));
    t.push(s);
  }
}
function q3(e) {
  return U3(this, arguments, function* () {
    const n = e.getReader();
    for (; ; ) {
      const { value: r, done: s } = yield xo(n.read());
      if (s)
        break;
      yield yield xo(hg(r));
    }
  });
}
function B3(e) {
  const t = e.getReader();
  return new ReadableStream({
    start(r) {
      let s = "";
      return i();
      function i() {
        return t.read().then(({ value: a, done: o }) => {
          if (o) {
            if (s.trim()) {
              r.error(new It("Failed to parse stream"));
              return;
            }
            r.close();
            return;
          }
          s += a;
          let u = s.match(eb), c;
          for (; u; ) {
            try {
              c = JSON.parse(u[1]);
            } catch {
              r.error(new It(`Error parsing JSON response: "${u[1]}"`));
              return;
            }
            r.enqueue(c), s = s.substring(u[0].length), u = s.match(eb);
          }
          return i();
        }).catch((a) => {
          let o = a;
          throw o.stack = a.stack, o.name === "AbortError" ? o = new MO("Request aborted when reading from the stream") : o = new It("Error reading from the stream"), o;
        });
      }
    }
  });
}
function Z3(e) {
  const t = e[e.length - 1], n = {
    promptFeedback: t?.promptFeedback
  };
  for (const r of e) {
    if (r.candidates) {
      let s = 0;
      for (const i of r.candidates)
        if (n.candidates || (n.candidates = []), n.candidates[s] || (n.candidates[s] = {
          index: s
        }), n.candidates[s].citationMetadata = i.citationMetadata, n.candidates[s].groundingMetadata = i.groundingMetadata, n.candidates[s].finishReason = i.finishReason, n.candidates[s].finishMessage = i.finishMessage, n.candidates[s].safetyRatings = i.safetyRatings, i.content && i.content.parts) {
          n.candidates[s].content || (n.candidates[s].content = {
            role: i.content.role || "user",
            parts: []
          });
          const a = {};
          for (const o of i.content.parts)
            o.text && (a.text = o.text), o.functionCall && (a.functionCall = o.functionCall), o.executableCode && (a.executableCode = o.executableCode), o.codeExecutionResult && (a.codeExecutionResult = o.codeExecutionResult), Object.keys(a).length === 0 && (a.text = ""), n.candidates[s].content.parts.push(a);
        }
      s++;
    }
    r.usageMetadata && (n.usageMetadata = r.usageMetadata);
  }
  return n;
}
async function jO(e, t, n, r) {
  const s = await Go(
    t,
    xs.STREAM_GENERATE_CONTENT,
    e,
    /* stream */
    !0,
    JSON.stringify(n),
    r
  );
  return F3(s);
}
async function LO(e, t, n, r) {
  const i = await (await Go(
    t,
    xs.GENERATE_CONTENT,
    e,
    /* stream */
    !1,
    JSON.stringify(n),
    r
  )).json();
  return {
    response: hg(i)
  };
}
function DO(e) {
  if (e != null) {
    if (typeof e == "string")
      return { role: "system", parts: [{ text: e }] };
    if (e.text)
      return { role: "system", parts: [e] };
    if (e.parts)
      return e.role ? e : { role: "system", parts: e.parts };
  }
}
function Eo(e) {
  let t = [];
  if (typeof e == "string")
    t = [{ text: e }];
  else
    for (const n of e)
      typeof n == "string" ? t.push({ text: n }) : t.push(n);
  return V3(t);
}
function V3(e) {
  const t = { role: "user", parts: [] }, n = { role: "function", parts: [] };
  let r = !1, s = !1;
  for (const i of e)
    "functionResponse" in i ? (n.parts.push(i), s = !0) : (t.parts.push(i), r = !0);
  if (r && s)
    throw new It("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  if (!r && !s)
    throw new It("No content is provided for sending chat message.");
  return r ? t : n;
}
function H3(e, t) {
  var n;
  let r = {
    model: t?.model,
    generationConfig: t?.generationConfig,
    safetySettings: t?.safetySettings,
    tools: t?.tools,
    toolConfig: t?.toolConfig,
    systemInstruction: t?.systemInstruction,
    cachedContent: (n = t?.cachedContent) === null || n === void 0 ? void 0 : n.name,
    contents: []
  };
  const s = e.generateContentRequest != null;
  if (e.contents) {
    if (s)
      throw new jr("CountTokensRequest must have one of contents or generateContentRequest, not both.");
    r.contents = e.contents;
  } else if (s)
    r = Object.assign(Object.assign({}, r), e.generateContentRequest);
  else {
    const i = Eo(e);
    r.contents = [i];
  }
  return { generateContentRequest: r };
}
function tb(e) {
  let t;
  return e.contents ? t = e : t = { contents: [Eo(e)] }, e.systemInstruction && (t.systemInstruction = DO(e.systemInstruction)), t;
}
function G3(e) {
  return typeof e == "string" || Array.isArray(e) ? { content: Eo(e) } : e;
}
const nb = [
  "text",
  "inlineData",
  "functionCall",
  "functionResponse",
  "executableCode",
  "codeExecutionResult"
], W3 = {
  user: ["text", "inlineData"],
  function: ["functionResponse"],
  model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
  // System instructions shouldn't be in history anyway.
  system: ["text"]
};
function J3(e) {
  let t = !1;
  for (const n of e) {
    const { role: r, parts: s } = n;
    if (!t && r !== "user")
      throw new It(`First content should be with role 'user', got ${r}`);
    if (!H0.includes(r))
      throw new It(`Each item should include role field. Got ${r} but valid roles are: ${JSON.stringify(H0)}`);
    if (!Array.isArray(s))
      throw new It("Content should have 'parts' property with an array of Parts");
    if (s.length === 0)
      throw new It("Each Content should have at least one part");
    const i = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0,
      executableCode: 0,
      codeExecutionResult: 0
    };
    for (const o of s)
      for (const u of nb)
        u in o && (i[u] += 1);
    const a = W3[r];
    for (const o of nb)
      if (!a.includes(o) && i[o] > 0)
        throw new It(`Content with role '${r}' can't contain '${o}' part`);
    t = !0;
  }
}
function rb(e) {
  var t;
  if (e.candidates === void 0 || e.candidates.length === 0)
    return !1;
  const n = (t = e.candidates[0]) === null || t === void 0 ? void 0 : t.content;
  if (n === void 0 || n.parts === void 0 || n.parts.length === 0)
    return !1;
  for (const r of n.parts)
    if (r === void 0 || Object.keys(r).length === 0 || r.text !== void 0 && r.text === "")
      return !1;
  return !0;
}
const sb = "SILENT_ERROR";
class K3 {
  constructor(t, n, r, s = {}) {
    this.model = n, this.params = r, this._requestOptions = s, this._history = [], this._sendPromise = Promise.resolve(), this._apiKey = t, r?.history && (J3(r.history), this._history = r.history);
  }
  /**
   * Gets the chat history so far. Blocked prompts are not added to history.
   * Blocked candidates are not added to history, nor are the prompts that
   * generated them.
   */
  async getHistory() {
    return await this._sendPromise, this._history;
  }
  /**
   * Sends a chat message and receives a non-streaming
   * {@link GenerateContentResult}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessage(t, n = {}) {
    var r, s, i, a, o, u;
    await this._sendPromise;
    const c = Eo(t), l = {
      safetySettings: (r = this.params) === null || r === void 0 ? void 0 : r.safetySettings,
      generationConfig: (s = this.params) === null || s === void 0 ? void 0 : s.generationConfig,
      tools: (i = this.params) === null || i === void 0 ? void 0 : i.tools,
      toolConfig: (a = this.params) === null || a === void 0 ? void 0 : a.toolConfig,
      systemInstruction: (o = this.params) === null || o === void 0 ? void 0 : o.systemInstruction,
      cachedContent: (u = this.params) === null || u === void 0 ? void 0 : u.cachedContent,
      contents: [...this._history, c]
    }, d = Object.assign(Object.assign({}, this._requestOptions), n);
    let f;
    return this._sendPromise = this._sendPromise.then(() => LO(this._apiKey, this.model, l, d)).then((h) => {
      var p;
      if (rb(h.response)) {
        this._history.push(c);
        const g = Object.assign({
          parts: [],
          // Response seems to come back without a role set.
          role: "model"
        }, (p = h.response.candidates) === null || p === void 0 ? void 0 : p[0].content);
        this._history.push(g);
      } else {
        const g = Rr(h.response);
        g && console.warn(`sendMessage() was unsuccessful. ${g}. Inspect response object for details.`);
      }
      f = h;
    }).catch((h) => {
      throw this._sendPromise = Promise.resolve(), h;
    }), await this._sendPromise, f;
  }
  /**
   * Sends a chat message and receives the response as a
   * {@link GenerateContentStreamResult} containing an iterable stream
   * and a response promise.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessageStream(t, n = {}) {
    var r, s, i, a, o, u;
    await this._sendPromise;
    const c = Eo(t), l = {
      safetySettings: (r = this.params) === null || r === void 0 ? void 0 : r.safetySettings,
      generationConfig: (s = this.params) === null || s === void 0 ? void 0 : s.generationConfig,
      tools: (i = this.params) === null || i === void 0 ? void 0 : i.tools,
      toolConfig: (a = this.params) === null || a === void 0 ? void 0 : a.toolConfig,
      systemInstruction: (o = this.params) === null || o === void 0 ? void 0 : o.systemInstruction,
      cachedContent: (u = this.params) === null || u === void 0 ? void 0 : u.cachedContent,
      contents: [...this._history, c]
    }, d = Object.assign(Object.assign({}, this._requestOptions), n), f = jO(this._apiKey, this.model, l, d);
    return this._sendPromise = this._sendPromise.then(() => f).catch((h) => {
      throw new Error(sb);
    }).then((h) => h.response).then((h) => {
      if (rb(h)) {
        this._history.push(c);
        const p = Object.assign({}, h.candidates[0].content);
        p.role || (p.role = "model"), this._history.push(p);
      } else {
        const p = Rr(h);
        p && console.warn(`sendMessageStream() was unsuccessful. ${p}. Inspect response object for details.`);
      }
    }).catch((h) => {
      h.message !== sb && console.error(h);
    }), f;
  }
}
async function Y3(e, t, n, r) {
  return (await Go(t, xs.COUNT_TOKENS, e, !1, JSON.stringify(n), r)).json();
}
async function X3(e, t, n, r) {
  return (await Go(t, xs.EMBED_CONTENT, e, !1, JSON.stringify(n), r)).json();
}
async function Q3(e, t, n, r) {
  const s = n.requests.map((a) => Object.assign(Object.assign({}, a), { model: t }));
  return (await Go(t, xs.BATCH_EMBED_CONTENTS, e, !1, JSON.stringify({ requests: s }), r)).json();
}
class ib {
  constructor(t, n, r = {}) {
    this.apiKey = t, this._requestOptions = r, n.model.includes("/") ? this.model = n.model : this.model = `models/${n.model}`, this.generationConfig = n.generationConfig || {}, this.safetySettings = n.safetySettings || [], this.tools = n.tools, this.toolConfig = n.toolConfig, this.systemInstruction = DO(n.systemInstruction), this.cachedContent = n.cachedContent;
  }
  /**
   * Makes a single non-streaming call to the model
   * and returns an object containing a single {@link GenerateContentResponse}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContent(t, n = {}) {
    var r;
    const s = tb(t), i = Object.assign(Object.assign({}, this._requestOptions), n);
    return LO(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (r = this.cachedContent) === null || r === void 0 ? void 0 : r.name }, s), i);
  }
  /**
   * Makes a single streaming call to the model and returns an object
   * containing an iterable stream that iterates over all chunks in the
   * streaming response as well as a promise that returns the final
   * aggregated response.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContentStream(t, n = {}) {
    var r;
    const s = tb(t), i = Object.assign(Object.assign({}, this._requestOptions), n);
    return jO(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (r = this.cachedContent) === null || r === void 0 ? void 0 : r.name }, s), i);
  }
  /**
   * Gets a new {@link ChatSession} instance which can be used for
   * multi-turn chats.
   */
  startChat(t) {
    var n;
    return new K3(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (n = this.cachedContent) === null || n === void 0 ? void 0 : n.name }, t), this._requestOptions);
  }
  /**
   * Counts the tokens in the provided request.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async countTokens(t, n = {}) {
    const r = H3(t, {
      model: this.model,
      generationConfig: this.generationConfig,
      safetySettings: this.safetySettings,
      tools: this.tools,
      toolConfig: this.toolConfig,
      systemInstruction: this.systemInstruction,
      cachedContent: this.cachedContent
    }), s = Object.assign(Object.assign({}, this._requestOptions), n);
    return Y3(this.apiKey, this.model, r, s);
  }
  /**
   * Embeds the provided content.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async embedContent(t, n = {}) {
    const r = G3(t), s = Object.assign(Object.assign({}, this._requestOptions), n);
    return X3(this.apiKey, this.model, r, s);
  }
  /**
   * Embeds an array of {@link EmbedContentRequest}s.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async batchEmbedContents(t, n = {}) {
    const r = Object.assign(Object.assign({}, this._requestOptions), n);
    return Q3(this.apiKey, this.model, t, r);
  }
}
class ab {
  constructor(t) {
    this.apiKey = t;
  }
  /**
   * Gets a {@link GenerativeModel} instance for the provided model name.
   */
  getGenerativeModel(t, n) {
    if (!t.model)
      throw new It("Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })");
    return new ib(this.apiKey, t, n);
  }
  /**
   * Creates a {@link GenerativeModel} instance from provided content cache.
   */
  getGenerativeModelFromCachedContent(t, n, r) {
    if (!t.name)
      throw new jr("Cached content must contain a `name` field.");
    if (!t.model)
      throw new jr("Cached content must contain a `model` field.");
    const s = ["model", "systemInstruction"];
    for (const a of s)
      if (n?.[a] && t[a] && n?.[a] !== t[a]) {
        if (a === "model") {
          const o = n.model.startsWith("models/") ? n.model.replace("models/", "") : n.model, u = t.model.startsWith("models/") ? t.model.replace("models/", "") : t.model;
          if (o === u)
            continue;
        }
        throw new jr(`Different value for "${a}" specified in modelParams (${n[a]}) and cachedContent (${t[a]})`);
      }
    const i = Object.assign(Object.assign({}, n), { model: t.model, tools: t.tools, toolConfig: t.toolConfig, systemInstruction: t.systemInstruction, cachedContent: t });
    return new ib(this.apiKey, i, r);
  }
}
function ob(e, t) {
  const n = eq(e), r = nq(n, t);
  return {
    tools: n,
    toolConfig: r
  };
}
function eq(e) {
  let t = [];
  const n = [];
  return e.forEach((s) => {
    if (Br(s)) {
      const [i] = x3([s]);
      i.functionDeclarations && t.push(...i.functionDeclarations);
    } else if (vi(s)) {
      const { functionDeclarations: i } = tq(s);
      if (i) t.push(...i);
      else throw new Error("Failed to convert OpenAI structured tool to GenerativeAI tool");
    } else n.push(s);
  }), n.find((s) => "functionDeclarations" in s) ? n.map((s) => {
    if (t?.length > 0 && "functionDeclarations" in s) {
      const i = { functionDeclarations: [...s.functionDeclarations || [], ...t] };
      return t = [], i;
    }
    return s;
  }) : [...n, ...t.length > 0 ? [{ functionDeclarations: t }] : []];
}
function tq(e) {
  return { functionDeclarations: [{
    name: e.function.name,
    description: e.function.description,
    parameters: Ts(e.function.parameters)
  }] };
}
function nq(e, t) {
  if (!e.length || !t) return;
  const { toolChoice: n, allowedFunctionNames: r } = t, s = {
    any: ei.ANY,
    auto: ei.AUTO,
    none: ei.NONE
  };
  if (n && [
    "any",
    "auto",
    "none"
  ].includes(n)) return { functionCallingConfig: {
    mode: s[n] ?? "MODE_UNSPECIFIED",
    allowedFunctionNames: r
  } };
  if (typeof n == "string" || r) return { functionCallingConfig: {
    mode: ei.ANY,
    allowedFunctionNames: [...r ?? [], ...n && typeof n == "string" ? [n] : []]
  } };
}
const rq = {
  "gemini-embedding-001": {
    maxInputTokens: 2048,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 3072,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1
  },
  "gemini-2.5-flash-image": {
    maxInputTokens: 32768,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !0,
    imageOutputs: !0,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1
  },
  "gemini-2.5-flash-preview-05-20": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-flash-lite-latest": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-2.5-flash": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-flash-latest": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-2.5-pro-preview-05-06": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-2.5-flash-preview-tts": {
    maxInputTokens: 8e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 16e3,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !0,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1
  },
  "gemini-2.0-flash-lite": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-live-2.5-flash-preview-native-audio": {
    maxInputTokens: 131072,
    imageInputs: !1,
    audioInputs: !0,
    pdfInputs: !1,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !0,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  },
  "gemini-2.0-flash": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-2.5-flash-lite": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-2.5-pro-preview-06-05": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-live-2.5-flash": {
    maxInputTokens: 128e3,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !1,
    videoInputs: !0,
    maxOutputTokens: 8e3,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !0,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  },
  "gemini-2.5-flash-lite-preview-06-17": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  },
  "gemini-2.5-flash-image-preview": {
    maxInputTokens: 32768,
    imageInputs: !0,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 32768,
    reasoningOutput: !0,
    imageOutputs: !0,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1
  },
  "gemini-2.5-flash-preview-09-2025": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-2.5-flash-preview-04-17": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  },
  "gemini-2.5-pro-preview-tts": {
    maxInputTokens: 8e3,
    imageInputs: !1,
    audioInputs: !1,
    pdfInputs: !1,
    videoInputs: !1,
    maxOutputTokens: 16e3,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !0,
    videoOutputs: !1,
    toolCalling: !1,
    structuredOutput: !1
  },
  "gemini-2.5-pro": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-1.5-flash": {
    maxInputTokens: 1e6,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !1,
    videoInputs: !0,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  },
  "gemini-1.5-flash-8b": {
    maxInputTokens: 1e6,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !1,
    videoInputs: !0,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  },
  "gemini-2.5-flash-lite-preview-09-2025": {
    maxInputTokens: 1048576,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !0,
    videoInputs: !0,
    maxOutputTokens: 65536,
    reasoningOutput: !0,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !0
  },
  "gemini-1.5-pro": {
    maxInputTokens: 1e6,
    imageInputs: !0,
    audioInputs: !0,
    pdfInputs: !1,
    videoInputs: !0,
    maxOutputTokens: 8192,
    reasoningOutput: !1,
    imageOutputs: !1,
    audioOutputs: !1,
    videoOutputs: !1,
    toolCalling: !0,
    structuredOutput: !1
  }
};
var sq = rq, iq = class extends bi {
  static lc_name() {
    return "ChatGoogleGenerativeAI";
  }
  lc_serializable = !0;
  get lc_secrets() {
    return { apiKey: "GOOGLE_API_KEY" };
  }
  lc_namespace = [
    "langchain",
    "chat_models",
    "google_genai"
  ];
  get lc_aliases() {
    return { apiKey: "google_api_key" };
  }
  model;
  temperature;
  maxOutputTokens;
  topP;
  topK;
  stopSequences = [];
  safetySettings;
  apiKey;
  streaming = !1;
  json;
  streamUsage = !0;
  convertSystemMessageToHumanContent;
  thinkingConfig;
  client;
  get _isMultimodalModel() {
    return this.model.includes("vision") || this.model.startsWith("gemini-1.5") || this.model.startsWith("gemini-2") || this.model.startsWith("gemma-3-") && !this.model.startsWith("gemma-3-1b") || this.model.startsWith("gemini-3");
  }
  constructor(e) {
    if (super(e), this.model = e.model.replace(/^models\//, ""), this.maxOutputTokens = e.maxOutputTokens ?? this.maxOutputTokens, this.maxOutputTokens && this.maxOutputTokens < 0) throw new Error("`maxOutputTokens` must be a positive integer");
    if (this.temperature = e.temperature ?? this.temperature, this.temperature && (this.temperature < 0 || this.temperature > 2)) throw new Error("`temperature` must be in the range of [0.0,2.0]");
    if (this.topP = e.topP ?? this.topP, this.topP && this.topP < 0) throw new Error("`topP` must be a positive integer");
    if (this.topP && this.topP > 1) throw new Error("`topP` must be below 1.");
    if (this.topK = e.topK ?? this.topK, this.topK && this.topK < 0) throw new Error("`topK` must be a positive integer");
    if (this.stopSequences = e.stopSequences ?? this.stopSequences, this.apiKey = e.apiKey ?? on("GOOGLE_API_KEY"), !this.apiKey) throw new Error("Please set an API key for Google GenerativeAI in the environment variable GOOGLE_API_KEY or in the `apiKey` field of the ChatGoogleGenerativeAI constructor");
    if (this.safetySettings = e.safetySettings ?? this.safetySettings, this.safetySettings && this.safetySettings.length > 0 && new Set(this.safetySettings.map((n) => n.category)).size !== this.safetySettings.length)
      throw new Error("The categories in `safetySettings` array must be unique");
    this.streaming = e.streaming ?? this.streaming, this.json = e.json, this.thinkingConfig = e.thinkingConfig ?? this.thinkingConfig, this.client = new ab(this.apiKey).getGenerativeModel({
      model: this.model,
      safetySettings: this.safetySettings,
      generationConfig: {
        stopSequences: this.stopSequences,
        maxOutputTokens: this.maxOutputTokens,
        temperature: this.temperature,
        topP: this.topP,
        topK: this.topK,
        ...this.json ? { responseMimeType: "application/json" } : {},
        ...this.thinkingConfig ? { thinkingConfig: this.thinkingConfig } : {}
      }
    }, {
      apiVersion: e.apiVersion,
      baseUrl: e.baseUrl,
      customHeaders: e.customHeaders
    }), this.streamUsage = e.streamUsage ?? this.streamUsage;
  }
  useCachedContent(e, t, n) {
    this.apiKey && (this.client = new ab(this.apiKey).getGenerativeModelFromCachedContent(e, t, n));
  }
  get useSystemInstruction() {
    return typeof this.convertSystemMessageToHumanContent == "boolean" ? !this.convertSystemMessageToHumanContent : this.computeUseSystemInstruction;
  }
  get computeUseSystemInstruction() {
    return this.model === "gemini-1.0-pro-001" || this.model.startsWith("gemini-pro-vision") || this.model.startsWith("gemini-1.0-pro-vision") ? !1 : this.model !== "gemini-pro";
  }
  getLsParams(e) {
    return {
      ls_provider: "google_genai",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: this.client.generationConfig.temperature,
      ls_max_tokens: this.client.generationConfig.maxOutputTokens,
      ls_stop: e.stop
    };
  }
  _combineLLMOutput() {
    return [];
  }
  _llmType() {
    return "googlegenerativeai";
  }
  bindTools(e, t) {
    return this.withConfig({
      tools: ob(e)?.tools,
      ...t
    });
  }
  invocationParams(e) {
    const t = e?.tools?.length ? ob(e.tools, {
      toolChoice: e.tool_choice,
      allowedFunctionNames: e.allowedFunctionNames
    }) : void 0;
    return e?.responseSchema ? (this.client.generationConfig.responseSchema = e.responseSchema, this.client.generationConfig.responseMimeType = "application/json") : (this.client.generationConfig.responseSchema = void 0, this.client.generationConfig.responseMimeType = this.json ? "application/json" : void 0), {
      ...t?.tools ? { tools: t.tools } : {},
      ...t?.toolConfig ? { toolConfig: t.toolConfig } : {}
    };
  }
  async _generate(e, t, n) {
    const r = F0(e, this._isMultimodalModel, this.useSystemInstruction, this.model);
    let s = r;
    if (r[0].role === "system") {
      const [c] = r;
      this.client.systemInstruction = c, s = r.slice(1);
    }
    const i = this.invocationParams(t);
    if (this.streaming) {
      const c = {}, l = this._streamResponseChunks(e, t, n), d = {};
      for await (const h of l) {
        const p = h.generationInfo?.completion ?? 0;
        d[p] === void 0 ? d[p] = h : d[p] = d[p].concat(h);
      }
      return {
        generations: Object.entries(d).sort(([h], [p]) => parseInt(h, 10) - parseInt(p, 10)).map(([h, p]) => p),
        llmOutput: { estimatedTokenUsage: c }
      };
    }
    const a = await this.completionWithRetry({
      ...i,
      contents: s
    });
    let o;
    "usageMetadata" in a.response && (o = z0(a.response.usageMetadata, this.model));
    const u = S3(a.response, { usageMetadata: o });
    return u.generations?.length > 0 && await n?.handleLLMNewToken(u.generations[0]?.text ?? ""), u;
  }
  async *_streamResponseChunks(e, t, n) {
    const r = F0(e, this._isMultimodalModel, this.useSystemInstruction, this.model);
    let s = r;
    if (r[0].role === "system") {
      const [f] = r;
      this.client.systemInstruction = f, s = r.slice(1);
    }
    const a = {
      ...this.invocationParams(t),
      contents: s
    }, o = await this.caller.callWithOptions({ signal: t?.signal }, async () => {
      const { stream: f } = await this.client.generateContentStream(a);
      return f;
    });
    let u, c = 0, l = 0, d = 0;
    for await (const f of o) {
      if ("usageMetadata" in f && f.usageMetadata !== void 0 && this.streamUsage !== !1 && t.streamUsage !== !1) {
        u = z0(f.usageMetadata, this.model);
        const p = f.usageMetadata.promptTokenCount ?? 0;
        u.input_tokens = Math.max(0, p - c), c = p;
        const g = f.usageMetadata.candidatesTokenCount ?? 0;
        u.output_tokens = Math.max(0, g - l), l = g;
        const m = f.usageMetadata.totalTokenCount ?? 0;
        u.total_tokens = Math.max(0, m - d), d = m;
      }
      const h = T3(f, {
        usageMetadata: u
      });
      h && (yield h, await n?.handleLLMNewToken(h.text ?? ""));
    }
  }
  async completionWithRetry(e, t) {
    return this.caller.callWithOptions({ signal: t?.signal }, async () => {
      try {
        return await this.client.generateContent(e);
      } catch (n) {
        throw n.message?.includes("400 Bad Request") && (n.status = 400), n;
      }
    });
  }
  /**
  * Return profiling information for the model.
  *
  * Provides information about the model's capabilities and constraints,
  * including token limits, multimodal support, and advanced features like
  * tool calling and structured output.
  *
  * @returns {ModelProfile} An object describing the model's capabilities and constraints
  *
  * @example
  * ```typescript
  * const model = new ChatGoogleGenerativeAI({ model: "gemini-1.5-flash" });
  * const profile = model.profile;
  * console.log(profile.maxInputTokens); // 2000000
  * console.log(profile.imageInputs); // true
  * ```
  */
  get profile() {
    return sq[this.model] ?? {};
  }
  withStructuredOutput(e, t) {
    const n = e, r = t?.name, s = t?.method, i = t?.includeRaw;
    if (s === "jsonMode") throw new Error('ChatGoogleGenerativeAI only supports "jsonSchema" or "functionCalling" as a method.');
    let a, o;
    if (s === "functionCalling") {
      let d = r ?? "extract", f;
      if (_t(n)) {
        const h = Np(n);
        f = [{ functionDeclarations: [{
          name: d,
          description: h.description ?? "A function available to call.",
          parameters: h
        }] }], o = new q0({
          returnSingle: !0,
          keyName: d,
          zodSchema: n
        });
      } else {
        let h;
        typeof n.name == "string" && typeof n.parameters == "object" && n.parameters != null ? (h = n, h.parameters = Ts(n.parameters), d = n.name) : h = {
          name: d,
          description: n.description ?? "",
          parameters: Ts(n)
        }, f = [{ functionDeclarations: [h] }], o = new q0({
          returnSingle: !0,
          keyName: d
        });
      }
      a = this.bindTools(f).withConfig({ allowedFunctionNames: [d] });
    } else {
      const d = Np(n);
      a = this.withConfig({ responseSchema: d }), o = new Ss();
    }
    if (!i) return a.pipe(o).withConfig({ runName: "ChatGoogleGenerativeAIStructuredOutput" });
    const u = _n.assign({ parsed: (d, f) => o.invoke(d.raw, f) }), c = _n.assign({ parsed: () => null }), l = u.withFallbacks({ fallbacks: [c] });
    return Kr.from([{ raw: a }, l]).withConfig({ runName: "StructuredOutputRunnable" });
  }
}, bh = {}, ya = {}, ub;
function aq() {
  return ub || (ub = 1, Object.defineProperty(ya, "__esModule", {
    value: !0
  }), ya.default = void 0, ya.default = "ffffffff-ffff-ffff-ffff-ffffffffffff"), ya;
}
var wa = {}, cb;
function oq() {
  return cb || (cb = 1, Object.defineProperty(wa, "__esModule", {
    value: !0
  }), wa.default = void 0, wa.default = "00000000-0000-0000-0000-000000000000"), wa;
}
var va = {}, ba = {}, Sa = {}, lb;
function uq() {
  return lb || (lb = 1, Object.defineProperty(Sa, "__esModule", {
    value: !0
  }), Sa.default = void 0, Sa.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i), Sa;
}
var db;
function nd() {
  if (db) return ba;
  db = 1, Object.defineProperty(ba, "__esModule", {
    value: !0
  }), ba.default = void 0;
  var e = t(/* @__PURE__ */ uq());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return typeof r == "string" && e.default.test(r);
  }
  return ba.default = n, ba;
}
var fb;
function rd() {
  if (fb) return va;
  fb = 1, Object.defineProperty(va, "__esModule", {
    value: !0
  }), va.default = void 0;
  var e = t(/* @__PURE__ */ nd());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    if (!(0, e.default)(r))
      throw TypeError("Invalid UUID");
    let s;
    const i = new Uint8Array(16);
    return i[0] = (s = parseInt(r.slice(0, 8), 16)) >>> 24, i[1] = s >>> 16 & 255, i[2] = s >>> 8 & 255, i[3] = s & 255, i[4] = (s = parseInt(r.slice(9, 13), 16)) >>> 8, i[5] = s & 255, i[6] = (s = parseInt(r.slice(14, 18), 16)) >>> 8, i[7] = s & 255, i[8] = (s = parseInt(r.slice(19, 23), 16)) >>> 8, i[9] = s & 255, i[10] = (s = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, i[11] = s / 4294967296 & 255, i[12] = s >>> 24 & 255, i[13] = s >>> 16 & 255, i[14] = s >>> 8 & 255, i[15] = s & 255, i;
  }
  return va.default = n, va;
}
var zs = {}, hb;
function Yr() {
  if (hb) return zs;
  hb = 1, Object.defineProperty(zs, "__esModule", {
    value: !0
  }), zs.default = void 0, zs.unsafeStringify = r;
  var e = t(/* @__PURE__ */ nd());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  const n = [];
  for (let i = 0; i < 256; ++i)
    n.push((i + 256).toString(16).slice(1));
  function r(i, a = 0) {
    return (n[i[a + 0]] + n[i[a + 1]] + n[i[a + 2]] + n[i[a + 3]] + "-" + n[i[a + 4]] + n[i[a + 5]] + "-" + n[i[a + 6]] + n[i[a + 7]] + "-" + n[i[a + 8]] + n[i[a + 9]] + "-" + n[i[a + 10]] + n[i[a + 11]] + n[i[a + 12]] + n[i[a + 13]] + n[i[a + 14]] + n[i[a + 15]]).toLowerCase();
  }
  function s(i, a = 0) {
    const o = r(i, a);
    if (!(0, e.default)(o))
      throw TypeError("Stringified UUID is invalid");
    return o;
  }
  return zs.default = s, zs;
}
var Ta = {}, Ju = {}, pb;
function pg() {
  if (pb) return Ju;
  pb = 1, Object.defineProperty(Ju, "__esModule", {
    value: !0
  }), Ju.default = s;
  var e = t(wn);
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  const n = new Uint8Array(256);
  let r = n.length;
  function s() {
    return r > n.length - 16 && (e.default.randomFillSync(n), r = 0), n.slice(r, r += 16);
  }
  return Ju;
}
var mb;
function UO() {
  if (mb) return Ta;
  mb = 1, Object.defineProperty(Ta, "__esModule", {
    value: !0
  }), Ta.default = void 0;
  var e = n(/* @__PURE__ */ pg()), t = /* @__PURE__ */ Yr();
  function n(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let r, s, i = 0, a = 0;
  function o(u, c, l) {
    let d = c && l || 0;
    const f = c || new Array(16);
    u = u || {};
    let h = u.node, p = u.clockseq;
    if (u._v6 || (h || (h = r), p == null && (p = s)), h == null || p == null) {
      const T = u.random || (u.rng || e.default)();
      h == null && (h = [T[0], T[1], T[2], T[3], T[4], T[5]], !r && !u._v6 && (h[0] |= 1, r = h)), p == null && (p = (T[6] << 8 | T[7]) & 16383, s === void 0 && !u._v6 && (s = p));
    }
    let g = u.msecs !== void 0 ? u.msecs : Date.now(), m = u.nsecs !== void 0 ? u.nsecs : a + 1;
    const _ = g - i + (m - a) / 1e4;
    if (_ < 0 && u.clockseq === void 0 && (p = p + 1 & 16383), (_ < 0 || g > i) && u.nsecs === void 0 && (m = 0), m >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    i = g, a = m, s = p, g += 122192928e5;
    const y = ((g & 268435455) * 1e4 + m) % 4294967296;
    f[d++] = y >>> 24 & 255, f[d++] = y >>> 16 & 255, f[d++] = y >>> 8 & 255, f[d++] = y & 255;
    const b = g / 4294967296 * 1e4 & 268435455;
    f[d++] = b >>> 8 & 255, f[d++] = b & 255, f[d++] = b >>> 24 & 15 | 16, f[d++] = b >>> 16 & 255, f[d++] = p >>> 8 | 128, f[d++] = p & 255;
    for (let T = 0; T < 6; ++T)
      f[d + T] = h[T];
    return c || (0, t.unsafeStringify)(f);
  }
  return Ta.default = o, Ta;
}
var Ku = {}, gb;
function FO() {
  if (gb) return Ku;
  gb = 1, Object.defineProperty(Ku, "__esModule", {
    value: !0
  }), Ku.default = r;
  var e = n(/* @__PURE__ */ rd()), t = /* @__PURE__ */ Yr();
  function n(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    const a = typeof i == "string" ? (0, e.default)(i) : i, o = s(a);
    return typeof i == "string" ? (0, t.unsafeStringify)(o) : o;
  }
  function s(i, a = !1) {
    return Uint8Array.of((i[6] & 15) << 4 | i[7] >> 4 & 15, (i[7] & 15) << 4 | (i[4] & 240) >> 4, (i[4] & 15) << 4 | (i[5] & 240) >> 4, (i[5] & 15) << 4 | (i[0] & 240) >> 4, (i[0] & 15) << 4 | (i[1] & 240) >> 4, (i[1] & 15) << 4 | (i[2] & 240) >> 4, 96 | i[2] & 15, i[3], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  }
  return Ku;
}
var xa = {}, Ir = {}, _b;
function zO() {
  if (_b) return Ir;
  _b = 1, Object.defineProperty(Ir, "__esModule", {
    value: !0
  }), Ir.URL = Ir.DNS = void 0, Ir.default = a;
  var e = /* @__PURE__ */ Yr(), t = n(/* @__PURE__ */ rd());
  function n(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function r(o) {
    o = unescape(encodeURIComponent(o));
    const u = [];
    for (let c = 0; c < o.length; ++c)
      u.push(o.charCodeAt(c));
    return u;
  }
  const s = Ir.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", i = Ir.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function a(o, u, c) {
    function l(d, f, h, p) {
      var g;
      if (typeof d == "string" && (d = r(d)), typeof f == "string" && (f = (0, t.default)(f)), ((g = f) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + d.length);
      if (m.set(f), m.set(d, f.length), m = c(m), m[6] = m[6] & 15 | u, m[8] = m[8] & 63 | 128, h) {
        p = p || 0;
        for (let _ = 0; _ < 16; ++_)
          h[p + _] = m[_];
        return h;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = o;
    } catch {
    }
    return l.DNS = s, l.URL = i, l;
  }
  return Ir;
}
var Ea = {}, yb;
function cq() {
  if (yb) return Ea;
  yb = 1, Object.defineProperty(Ea, "__esModule", {
    value: !0
  }), Ea.default = void 0;
  var e = t(wn);
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), e.default.createHash("md5").update(r).digest();
  }
  return Ea.default = n, Ea;
}
var wb;
function lq() {
  if (wb) return xa;
  wb = 1, Object.defineProperty(xa, "__esModule", {
    value: !0
  }), xa.default = void 0;
  var e = n(/* @__PURE__ */ zO()), t = n(/* @__PURE__ */ cq());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = (0, e.default)("v3", 48, t.default);
  return xa.default = r, xa;
}
var ka = {}, Oa = {}, vb;
function dq() {
  if (vb) return Oa;
  vb = 1, Object.defineProperty(Oa, "__esModule", {
    value: !0
  }), Oa.default = void 0;
  var e = t(wn);
  function t(n) {
    return n && n.__esModule ? n : { default: n };
  }
  return Oa.default = {
    randomUUID: e.default.randomUUID
  }, Oa;
}
var bb;
function fq() {
  if (bb) return ka;
  bb = 1, Object.defineProperty(ka, "__esModule", {
    value: !0
  }), ka.default = void 0;
  var e = r(/* @__PURE__ */ dq()), t = r(/* @__PURE__ */ pg()), n = /* @__PURE__ */ Yr();
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function s(i, a, o) {
    if (e.default.randomUUID && !a && !i)
      return e.default.randomUUID();
    i = i || {};
    const u = i.random || (i.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, a) {
      o = o || 0;
      for (let c = 0; c < 16; ++c)
        a[o + c] = u[c];
      return a;
    }
    return (0, n.unsafeStringify)(u);
  }
  return ka.default = s, ka;
}
var Ia = {}, Aa = {}, Sb;
function hq() {
  if (Sb) return Aa;
  Sb = 1, Object.defineProperty(Aa, "__esModule", {
    value: !0
  }), Aa.default = void 0;
  var e = t(wn);
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    return Array.isArray(r) ? r = Buffer.from(r) : typeof r == "string" && (r = Buffer.from(r, "utf8")), e.default.createHash("sha1").update(r).digest();
  }
  return Aa.default = n, Aa;
}
var Tb;
function pq() {
  if (Tb) return Ia;
  Tb = 1, Object.defineProperty(Ia, "__esModule", {
    value: !0
  }), Ia.default = void 0;
  var e = n(/* @__PURE__ */ zO()), t = n(/* @__PURE__ */ hq());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = (0, e.default)("v5", 80, t.default);
  return Ia.default = r, Ia;
}
var Yu = {}, xb;
function mq() {
  if (xb) return Yu;
  xb = 1, Object.defineProperty(Yu, "__esModule", {
    value: !0
  }), Yu.default = s;
  var e = /* @__PURE__ */ Yr(), t = r(/* @__PURE__ */ UO()), n = r(/* @__PURE__ */ FO());
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function s(i = {}, a, o = 0) {
    let u = (0, t.default)({
      ...i,
      _v6: !0
    }, new Uint8Array(16));
    if (u = (0, n.default)(u), a) {
      for (let c = 0; c < 16; c++)
        a[o + c] = u[c];
      return a;
    }
    return (0, e.unsafeStringify)(u);
  }
  return Yu;
}
var Xu = {}, Eb;
function gq() {
  if (Eb) return Xu;
  Eb = 1, Object.defineProperty(Xu, "__esModule", {
    value: !0
  }), Xu.default = r;
  var e = n(/* @__PURE__ */ rd()), t = /* @__PURE__ */ Yr();
  function n(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    const a = typeof i == "string" ? (0, e.default)(i) : i, o = s(a);
    return typeof i == "string" ? (0, t.unsafeStringify)(o) : o;
  }
  function s(i) {
    return Uint8Array.of((i[3] & 15) << 4 | i[4] >> 4 & 15, (i[4] & 15) << 4 | (i[5] & 240) >> 4, (i[5] & 15) << 4 | i[6] & 15, i[7], (i[1] & 15) << 4 | (i[2] & 240) >> 4, (i[2] & 15) << 4 | (i[3] & 240) >> 4, 16 | (i[0] & 240) >> 4, (i[0] & 15) << 4 | (i[1] & 240) >> 4, i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
  }
  return Xu;
}
var Ca = {}, kb;
function _q() {
  if (kb) return Ca;
  kb = 1, Object.defineProperty(Ca, "__esModule", {
    value: !0
  }), Ca.default = void 0;
  var e = n(/* @__PURE__ */ pg()), t = /* @__PURE__ */ Yr();
  function n(o) {
    return o && o.__esModule ? o : { default: o };
  }
  let r = null, s = null, i = 0;
  function a(o, u, c) {
    o = o || {};
    let l = u && c || 0;
    const d = u || new Uint8Array(16), f = o.random || (o.rng || e.default)(), h = o.msecs !== void 0 ? o.msecs : Date.now();
    let p = o.seq !== void 0 ? o.seq : null, g = s, m = r;
    return h > i && o.msecs === void 0 && (i = h, p !== null && (g = null, m = null)), p !== null && (p > 2147483647 && (p = 2147483647), g = p >>> 19 & 4095, m = p & 524287), (g === null || m === null) && (g = f[6] & 127, g = g << 8 | f[7], m = f[8] & 63, m = m << 8 | f[9], m = m << 5 | f[10] >>> 3), h + 1e4 > i && p === null ? ++m > 524287 && (m = 0, ++g > 4095 && (g = 0, i++)) : i = h, s = g, r = m, d[l++] = i / 1099511627776 & 255, d[l++] = i / 4294967296 & 255, d[l++] = i / 16777216 & 255, d[l++] = i / 65536 & 255, d[l++] = i / 256 & 255, d[l++] = i & 255, d[l++] = g >>> 4 & 15 | 112, d[l++] = g & 255, d[l++] = m >>> 13 & 63 | 128, d[l++] = m >>> 5 & 255, d[l++] = m << 3 & 255 | f[10] & 7, d[l++] = f[11], d[l++] = f[12], d[l++] = f[13], d[l++] = f[14], d[l++] = f[15], u || (0, t.unsafeStringify)(d);
  }
  return Ca.default = a, Ca;
}
var $a = {}, Ob;
function yq() {
  if (Ob) return $a;
  Ob = 1, Object.defineProperty($a, "__esModule", {
    value: !0
  }), $a.default = void 0;
  var e = t(/* @__PURE__ */ nd());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function n(r) {
    if (!(0, e.default)(r))
      throw TypeError("Invalid UUID");
    return parseInt(r.slice(14, 15), 16);
  }
  return $a.default = n, $a;
}
var Ib;
function wq() {
  return Ib || (Ib = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "MAX", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "v1ToV6", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v6", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "v6ToV1", {
      enumerable: !0,
      get: function() {
        return d.default;
      }
    }), Object.defineProperty(e, "v7", {
      enumerable: !0,
      get: function() {
        return f.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return h.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return p.default;
      }
    });
    var t = g(/* @__PURE__ */ aq()), n = g(/* @__PURE__ */ oq()), r = g(/* @__PURE__ */ rd()), s = g(/* @__PURE__ */ Yr()), i = g(/* @__PURE__ */ UO()), a = g(/* @__PURE__ */ FO()), o = g(/* @__PURE__ */ lq()), u = g(/* @__PURE__ */ fq()), c = g(/* @__PURE__ */ pq()), l = g(/* @__PURE__ */ mq()), d = g(/* @__PURE__ */ gq()), f = g(/* @__PURE__ */ _q()), h = g(/* @__PURE__ */ nd()), p = g(/* @__PURE__ */ yq());
    function g(m) {
      return m && m.__esModule ? m : { default: m };
    }
  })(bh)), bh;
}
var vq = /* @__PURE__ */ wq();
const Yt = /* @__PURE__ */ Zr(vq);
Yt.v1;
Yt.v1ToV6;
Yt.v3;
const bq = Yt.v4;
Yt.v5;
Yt.v6;
Yt.v6ToV1;
Yt.v7;
Yt.NIL;
Yt.MAX;
Yt.version;
Yt.validate;
Yt.stringify;
Yt.parse;
function Sq(e, t) {
  return new We({
    content: e.content ?? "",
    additional_kwargs: e.thinking && e.thinking !== "" ? { reasoning_content: e.thinking } : {},
    tool_call_chunks: e.tool_calls?.map((n) => ({
      name: n.function.name,
      args: JSON.stringify(n.function.arguments),
      type: "tool_call_chunk",
      index: 0,
      id: bq()
    })),
    response_metadata: {
      ...t?.responseMetadata,
      model_provider: "ollama"
    },
    usage_metadata: t?.usageMetadata
  });
}
function Ab(e) {
  const t = e.match(/^data:.*?;base64,(.*)$/);
  return t ? t[1] : "";
}
function Tq(e) {
  if (typeof e.content == "string") return [{
    role: "assistant",
    content: e.content
  }];
  const n = e.content.filter((s) => s.type === "text" && typeof s.text == "string").map((s) => ({
    role: "assistant",
    content: s.text
  }));
  let r;
  if (e.content.find((s) => s.type === "tool_use") && e.tool_calls?.length) {
    const s = e.tool_calls?.map((i) => ({
      id: i.id,
      type: "function",
      function: {
        name: i.name,
        arguments: i.args
      }
    }));
    s && (r = {
      role: "assistant",
      tool_calls: s,
      content: ""
    });
  } else if (e.content.find((s) => s.type === "tool_use") && !e.tool_calls?.length) throw new Error("'tool_use' content type is not supported without tool calls.");
  return [...n, ...r ? [r] : []];
}
function xq(e) {
  return typeof e.content == "string" ? [{
    role: "user",
    content: e.content
  }] : e.content.map((t) => {
    if (t.type === "text") return {
      role: "user",
      content: t.text
    };
    if (t.type === "image_url") {
      if (typeof t.image_url == "string") return {
        role: "user",
        content: "",
        images: [Ab(t.image_url)]
      };
      if (t.image_url.url && typeof t.image_url.url == "string") return {
        role: "user",
        content: "",
        images: [Ab(t.image_url.url)]
      };
    }
    throw new Error(`Unsupported content type: ${t.type}`);
  });
}
function Eq(e) {
  if (typeof e.content == "string") return [{
    role: "system",
    content: e.content
  }];
  if (e.content.every((t) => t.type === "text" && typeof t.text == "string")) return e.content.map((t) => ({
    role: "system",
    content: t.text
  }));
  throw new Error(`Unsupported content type(s): ${e.content.map((t) => t.type).join(", ")}`);
}
function kq(e) {
  if (typeof e.content != "string") throw new Error("Non string tool message content is not supported");
  return [{
    role: "tool",
    content: e.content
  }];
}
function Oq(e) {
  return e.flatMap((t) => {
    if (["human", "generic"].includes(t._getType())) return xq(t);
    if (t._getType() === "ai") return Tq(t);
    if (t._getType() === "system") return Eq(t);
    if (t._getType() === "tool") return kq(t);
    throw new Error(`Unsupported message type: ${t._getType()}`);
  });
}
var xt = typeof globalThis < "u" && globalThis || typeof self < "u" && self || // eslint-disable-next-line no-undef
typeof global < "u" && global || {}, jt = {
  searchParams: "URLSearchParams" in xt,
  iterable: "Symbol" in xt && "iterator" in Symbol,
  blob: "FileReader" in xt && "Blob" in xt && (function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  })(),
  formData: "FormData" in xt,
  arrayBuffer: "ArrayBuffer" in xt
};
function Iq(e) {
  return e && DataView.prototype.isPrototypeOf(e);
}
if (jt.arrayBuffer)
  var Aq = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], Cq = ArrayBuffer.isView || function(e) {
    return e && Aq.indexOf(Object.prototype.toString.call(e)) > -1;
  };
function Ti(e) {
  if (typeof e != "string" && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || e === "")
    throw new TypeError('Invalid character in header field name: "' + e + '"');
  return e.toLowerCase();
}
function mg(e) {
  return typeof e != "string" && (e = String(e)), e;
}
function gg(e) {
  var t = {
    next: function() {
      var n = e.shift();
      return { done: n === void 0, value: n };
    }
  };
  return jt.iterable && (t[Symbol.iterator] = function() {
    return t;
  }), t;
}
function ht(e) {
  this.map = {}, e instanceof ht ? e.forEach(function(t, n) {
    this.append(n, t);
  }, this) : Array.isArray(e) ? e.forEach(function(t) {
    if (t.length != 2)
      throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + t.length);
    this.append(t[0], t[1]);
  }, this) : e && Object.getOwnPropertyNames(e).forEach(function(t) {
    this.append(t, e[t]);
  }, this);
}
ht.prototype.append = function(e, t) {
  e = Ti(e), t = mg(t);
  var n = this.map[e];
  this.map[e] = n ? n + ", " + t : t;
};
ht.prototype.delete = function(e) {
  delete this.map[Ti(e)];
};
ht.prototype.get = function(e) {
  return e = Ti(e), this.has(e) ? this.map[e] : null;
};
ht.prototype.has = function(e) {
  return this.map.hasOwnProperty(Ti(e));
};
ht.prototype.set = function(e, t) {
  this.map[Ti(e)] = mg(t);
};
ht.prototype.forEach = function(e, t) {
  for (var n in this.map)
    this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this);
};
ht.prototype.keys = function() {
  var e = [];
  return this.forEach(function(t, n) {
    e.push(n);
  }), gg(e);
};
ht.prototype.values = function() {
  var e = [];
  return this.forEach(function(t) {
    e.push(t);
  }), gg(e);
};
ht.prototype.entries = function() {
  var e = [];
  return this.forEach(function(t, n) {
    e.push([n, t]);
  }), gg(e);
};
jt.iterable && (ht.prototype[Symbol.iterator] = ht.prototype.entries);
function Sh(e) {
  if (!e._noBody) {
    if (e.bodyUsed)
      return Promise.reject(new TypeError("Already read"));
    e.bodyUsed = !0;
  }
}
function qO(e) {
  return new Promise(function(t, n) {
    e.onload = function() {
      t(e.result);
    }, e.onerror = function() {
      n(e.error);
    };
  });
}
function $q(e) {
  var t = new FileReader(), n = qO(t);
  return t.readAsArrayBuffer(e), n;
}
function Rq(e) {
  var t = new FileReader(), n = qO(t), r = /charset=([A-Za-z0-9_-]+)/.exec(e.type), s = r ? r[1] : "utf-8";
  return t.readAsText(e, s), n;
}
function Pq(e) {
  for (var t = new Uint8Array(e), n = new Array(t.length), r = 0; r < t.length; r++)
    n[r] = String.fromCharCode(t[r]);
  return n.join("");
}
function Cb(e) {
  if (e.slice)
    return e.slice(0);
  var t = new Uint8Array(e.byteLength);
  return t.set(new Uint8Array(e)), t.buffer;
}
function BO() {
  return this.bodyUsed = !1, this._initBody = function(e) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? typeof e == "string" ? this._bodyText = e : jt.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : jt.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : jt.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : jt.arrayBuffer && jt.blob && Iq(e) ? (this._bodyArrayBuffer = Cb(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : jt.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || Cq(e)) ? this._bodyArrayBuffer = Cb(e) : this._bodyText = e = Object.prototype.toString.call(e) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof e == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : jt.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, jt.blob && (this.blob = function() {
    var e = Sh(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }), this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var e = Sh(this);
      return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else {
      if (jt.blob)
        return this.blob().then($q);
      throw new Error("could not read as ArrayBuffer");
    }
  }, this.text = function() {
    var e = Sh(this);
    if (e)
      return e;
    if (this._bodyBlob)
      return Rq(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(Pq(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, jt.formData && (this.formData = function() {
    return this.text().then(jq);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var Nq = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function Mq(e) {
  var t = e.toUpperCase();
  return Nq.indexOf(t) > -1 ? t : e;
}
function Es(e, t) {
  if (!(this instanceof Es))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  t = t || {};
  var n = t.body;
  if (e instanceof Es) {
    if (e.bodyUsed)
      throw new TypeError("Already read");
    this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new ht(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, !n && e._bodyInit != null && (n = e._bodyInit, e.bodyUsed = !0);
  } else
    this.url = String(e);
  if (this.credentials = t.credentials || this.credentials || "same-origin", (t.headers || !this.headers) && (this.headers = new ht(t.headers)), this.method = Mq(t.method || this.method || "GET"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal || (function() {
    if ("AbortController" in xt) {
      var i = new AbortController();
      return i.signal;
    }
  })(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && n)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(n), (this.method === "GET" || this.method === "HEAD") && (t.cache === "no-store" || t.cache === "no-cache")) {
    var r = /([?&])_=[^&]*/;
    if (r.test(this.url))
      this.url = this.url.replace(r, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var s = /\?/;
      this.url += (s.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
Es.prototype.clone = function() {
  return new Es(this, { body: this._bodyInit });
};
function jq(e) {
  var t = new FormData();
  return e.trim().split("&").forEach(function(n) {
    if (n) {
      var r = n.split("="), s = r.shift().replace(/\+/g, " "), i = r.join("=").replace(/\+/g, " ");
      t.append(decodeURIComponent(s), decodeURIComponent(i));
    }
  }), t;
}
function Lq(e) {
  var t = new ht(), n = e.replace(/\r?\n[\t ]+/g, " ");
  return n.split("\r").map(function(r) {
    return r.indexOf(`
`) === 0 ? r.substr(1, r.length) : r;
  }).forEach(function(r) {
    var s = r.split(":"), i = s.shift().trim();
    if (i) {
      var a = s.join(":").trim();
      try {
        t.append(i, a);
      } catch (o) {
        console.warn("Response " + o.message);
      }
    }
  }), t;
}
BO.call(Es.prototype);
function Qn(e, t) {
  if (!(this instanceof Qn))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  if (t || (t = {}), this.type = "default", this.status = t.status === void 0 ? 200 : t.status, this.status < 200 || this.status > 599)
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  this.ok = this.status >= 200 && this.status < 300, this.statusText = t.statusText === void 0 ? "" : "" + t.statusText, this.headers = new ht(t.headers), this.url = t.url || "", this._initBody(e);
}
BO.call(Qn.prototype);
Qn.prototype.clone = function() {
  return new Qn(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new ht(this.headers),
    url: this.url
  });
};
Qn.error = function() {
  var e = new Qn(null, { status: 200, statusText: "" });
  return e.ok = !1, e.status = 0, e.type = "error", e;
};
var Dq = [301, 302, 303, 307, 308];
Qn.redirect = function(e, t) {
  if (Dq.indexOf(t) === -1)
    throw new RangeError("Invalid status code");
  return new Qn(null, { status: t, headers: { location: e } });
};
var ds = xt.DOMException;
try {
  new ds();
} catch {
  ds = function(t, n) {
    this.message = t, this.name = n;
    var r = Error(t);
    this.stack = r.stack;
  }, ds.prototype = Object.create(Error.prototype), ds.prototype.constructor = ds;
}
function ZO(e, t) {
  return new Promise(function(n, r) {
    var s = new Es(e, t);
    if (s.signal && s.signal.aborted)
      return r(new ds("Aborted", "AbortError"));
    var i = new XMLHttpRequest();
    function a() {
      i.abort();
    }
    i.onload = function() {
      var c = {
        statusText: i.statusText,
        headers: Lq(i.getAllResponseHeaders() || "")
      };
      s.url.indexOf("file://") === 0 && (i.status < 200 || i.status > 599) ? c.status = 200 : c.status = i.status, c.url = "responseURL" in i ? i.responseURL : c.headers.get("X-Request-URL");
      var l = "response" in i ? i.response : i.responseText;
      setTimeout(function() {
        n(new Qn(l, c));
      }, 0);
    }, i.onerror = function() {
      setTimeout(function() {
        r(new TypeError("Network request failed"));
      }, 0);
    }, i.ontimeout = function() {
      setTimeout(function() {
        r(new TypeError("Network request timed out"));
      }, 0);
    }, i.onabort = function() {
      setTimeout(function() {
        r(new ds("Aborted", "AbortError"));
      }, 0);
    };
    function o(c) {
      try {
        return c === "" && xt.location.href ? xt.location.href : c;
      } catch {
        return c;
      }
    }
    if (i.open(s.method, o(s.url), !0), s.credentials === "include" ? i.withCredentials = !0 : s.credentials === "omit" && (i.withCredentials = !1), "responseType" in i && (jt.blob ? i.responseType = "blob" : jt.arrayBuffer && (i.responseType = "arraybuffer")), t && typeof t.headers == "object" && !(t.headers instanceof ht || xt.Headers && t.headers instanceof xt.Headers)) {
      var u = [];
      Object.getOwnPropertyNames(t.headers).forEach(function(c) {
        u.push(Ti(c)), i.setRequestHeader(c, mg(t.headers[c]));
      }), s.headers.forEach(function(c, l) {
        u.indexOf(l) === -1 && i.setRequestHeader(l, c);
      });
    } else
      s.headers.forEach(function(c, l) {
        i.setRequestHeader(l, c);
      });
    s.signal && (s.signal.addEventListener("abort", a), i.onreadystatechange = function() {
      i.readyState === 4 && s.signal.removeEventListener("abort", a);
    }), i.send(typeof s._bodyInit > "u" ? null : s._bodyInit);
  });
}
ZO.polyfill = !0;
xt.fetch || (xt.fetch = ZO, xt.Headers = ht, xt.Request = Es, xt.Response = Qn);
const VO = "11434", HO = `http://127.0.0.1:${VO}`, Uq = "0.6.3";
var Fq = Object.defineProperty, zq = (e, t, n) => t in e ? Fq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Th = (e, t, n) => (zq(e, typeof t != "symbol" ? t + "" : t, n), n);
class _g extends Error {
  constructor(t, n) {
    super(t), this.error = t, this.status_code = n, this.name = "ResponseError", Error.captureStackTrace && Error.captureStackTrace(this, _g);
  }
}
class qq {
  constructor(t, n, r) {
    Th(this, "abortController"), Th(this, "itr"), Th(this, "doneCallback"), this.abortController = t, this.itr = n, this.doneCallback = r;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const t of this.itr) {
      if ("error" in t)
        throw new Error(t.error);
      if (yield t, t.done || t.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
}
const yg = async (e) => {
  if (e.ok)
    return;
  let t = `Error ${e.status}: ${e.statusText}`, n = null;
  if (e.headers.get("content-type")?.includes("application/json"))
    try {
      n = await e.json(), t = n.error || t;
    } catch {
      console.log("Failed to parse error response as JSON");
    }
  else
    try {
      console.log("Getting text from response"), t = await e.text() || t;
    } catch {
      console.log("Failed to get text from error response");
    }
  throw new _g(t, e.status);
};
function Bq() {
  if (typeof window < "u" && window.navigator) {
    const e = navigator;
    return "userAgentData" in e && e.userAgentData?.platform ? `${e.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};` : navigator.platform ? `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};` : `unknown Browser/${navigator.userAgent};`;
  } else if (typeof process < "u")
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  return "";
}
function Zq(e) {
  if (e instanceof Headers) {
    const t = {};
    return e.forEach((n, r) => {
      t[r] = n;
    }), t;
  } else return Array.isArray(e) ? Object.fromEntries(e) : e || {};
}
const Vq = (e, t) => e[t], wg = async (e, t, n = {}) => {
  const r = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${Uq} (${Bq()})`
  };
  n.headers = Zq(n.headers);
  try {
    const i = new URL(t);
    if (i.protocol === "https:" && i.hostname === "ollama.com") {
      const a = typeof process == "object" && process !== null && typeof process.env == "object" && process.env !== null ? Vq(process.env, "OLLAMA_API_KEY") : void 0;
      !(n.headers.authorization || n.headers.Authorization) && a && (n.headers.Authorization = `Bearer ${a}`);
    }
  } catch (i) {
    console.error("error parsing url", i);
  }
  const s = Object.fromEntries(
    Object.entries(n.headers).filter(
      ([i]) => !Object.keys(r).some(
        (a) => a.toLowerCase() === i.toLowerCase()
      )
    )
  );
  return n.headers = {
    ...r,
    ...s
  }, e(t, n);
}, xh = async (e, t, n) => {
  const r = await wg(e, t, {
    headers: n?.headers
  });
  return await yg(r), r;
}, Ar = async (e, t, n, r) => {
  const i = ((o) => o !== null && typeof o == "object" && !Array.isArray(o))(n) ? JSON.stringify(n) : n, a = await wg(e, t, {
    method: "POST",
    body: i,
    signal: r?.signal,
    headers: r?.headers
  });
  return await yg(a), a;
}, Hq = async (e, t, n, r) => {
  const s = await wg(e, t, {
    method: "DELETE",
    body: JSON.stringify(n),
    headers: r?.headers
  });
  return await yg(s), s;
}, Gq = async function* (e) {
  const t = new TextDecoder("utf-8");
  let n = "";
  const r = e.getReader();
  for (; ; ) {
    const { done: s, value: i } = await r.read();
    if (s)
      break;
    n += t.decode(i, { stream: !0 });
    const a = n.split(`
`);
    n = a.pop() ?? "";
    for (const o of a)
      try {
        yield JSON.parse(o);
      } catch {
        console.warn("invalid json: ", o);
      }
  }
  n += t.decode();
  for (const s of n.split(`
`).filter((i) => i !== ""))
    try {
      yield JSON.parse(s);
    } catch {
      console.warn("invalid json: ", s);
    }
}, Wq = (e) => {
  if (!e)
    return HO;
  let t = e.includes("://");
  e.startsWith(":") && (e = `http://127.0.0.1${e}`, t = !0), t || (e = `http://${e}`);
  const n = new URL(e);
  let r = n.port;
  r || (t ? r = n.protocol === "https:" ? "443" : "80" : r = VO);
  let s = "";
  n.username && (s = n.username, n.password && (s += `:${n.password}`), s += "@");
  let i = `${n.protocol}//${s}${n.hostname}:${r}${n.pathname}`;
  return i.endsWith("/") && (i = i.slice(0, -1)), i;
};
var Jq = Object.defineProperty, Kq = (e, t, n) => t in e ? Jq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Eh = (e, t, n) => (Kq(e, typeof t != "symbol" ? t + "" : t, n), n);
let GO = class {
  constructor(t) {
    Eh(this, "config"), Eh(this, "fetch"), Eh(this, "ongoingStreamedRequests", []), this.config = {
      host: "",
      headers: t?.headers
    }, t?.proxy || (this.config.host = Wq(t?.host ?? HO)), this.fetch = t?.fetch ?? fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const t of this.ongoingStreamedRequests)
      t.abort();
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(t, n) {
    n.stream = n.stream ?? !1;
    const r = `${this.config.host}/api/${t}`;
    if (n.stream) {
      const i = new AbortController(), a = await Ar(this.fetch, r, n, {
        signal: i.signal,
        headers: this.config.headers
      });
      if (!a.body)
        throw new Error("Missing body");
      const o = Gq(a.body), u = new qq(
        i,
        o,
        () => {
          const c = this.ongoingStreamedRequests.indexOf(u);
          c > -1 && this.ongoingStreamedRequests.splice(c, 1);
        }
      );
      return this.ongoingStreamedRequests.push(u), u;
    }
    return await (await Ar(this.fetch, r, n, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(t) {
    if (typeof t != "string") {
      const n = new Uint8Array(t);
      let r = "";
      const s = n.byteLength;
      for (let i = 0; i < s; i++)
        r += String.fromCharCode(n[i]);
      return btoa(r);
    }
    return t;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(t) {
    return t.images && (t.images = await Promise.all(t.images.map(this.encodeImage.bind(this)))), this.processStreamableRequest("generate", t);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(t) {
    if (t.messages)
      for (const n of t.messages)
        n.images && (n.images = await Promise.all(
          n.images.map(this.encodeImage.bind(this))
        ));
    return this.processStreamableRequest("chat", t);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(t) {
    return this.processStreamableRequest("create", {
      ...t
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(t) {
    return this.processStreamableRequest("pull", {
      name: t.model,
      stream: t.stream,
      insecure: t.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(t) {
    return this.processStreamableRequest("push", {
      name: t.model,
      stream: t.stream,
      insecure: t.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(t) {
    return await Hq(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: t.model },
      { headers: this.config.headers }
    ), { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(t) {
    return await Ar(this.fetch, `${this.config.host}/api/copy`, { ...t }, {
      headers: this.config.headers
    }), { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    return await (await xh(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(t) {
    return await (await Ar(this.fetch, `${this.config.host}/api/show`, {
      ...t
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(t) {
    return await (await Ar(this.fetch, `${this.config.host}/api/embed`, {
      ...t
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(t) {
    return await (await Ar(this.fetch, `${this.config.host}/api/embeddings`, {
      ...t
    }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    return await (await xh(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Returns the Ollama server version.
   * @returns {Promise<VersionResponse>} - The server version object.
   */
  async version() {
    return await (await xh(this.fetch, `${this.config.host}/api/version`, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Performs web search using the Ollama web search API
   * @param request {WebSearchRequest} - The search request containing query and options
   * @returns {Promise<WebSearchResponse>} - The search results
   * @throws {Error} - If the request is invalid or the server returns an error
   */
  async webSearch(t) {
    if (!t.query || t.query.length === 0)
      throw new Error("Query is required");
    return await (await Ar(this.fetch, "https://ollama.com/api/web_search", { ...t }, {
      headers: this.config.headers
    })).json();
  }
  /**
   * Fetches a single page using the Ollama web fetch API
   * @param request {WebFetchRequest} - The fetch request containing a URL
   * @returns {Promise<WebFetchResponse>} - The fetch result
   * @throws {Error} - If the request is invalid or the server returns an error
   */
  async webFetch(t) {
    if (!t.url || t.url.length === 0)
      throw new Error("URL is required");
    return await (await Ar(this.fetch, "https://ollama.com/api/web_fetch", { ...t }, { headers: this.config.headers })).json();
  }
};
new GO();
var Yq = class extends bi {
  static lc_name() {
    return "ChatOllama";
  }
  model = "llama3";
  numa;
  numCtx;
  numBatch;
  numGpu;
  mainGpu;
  lowVram;
  f16Kv;
  logitsAll;
  vocabOnly;
  useMmap;
  useMlock;
  embeddingOnly;
  numThread;
  numKeep;
  seed;
  numPredict;
  topK;
  topP;
  tfsZ;
  typicalP;
  repeatLastN;
  temperature;
  repeatPenalty;
  presencePenalty;
  frequencyPenalty;
  mirostat;
  mirostatTau;
  mirostatEta;
  penalizeNewline;
  streaming;
  format;
  keepAlive;
  client;
  checkOrPullModel = !1;
  baseUrl = "http://127.0.0.1:11434";
  think;
  constructor(e) {
    super(e ?? {}), this.baseUrl = e?.baseUrl ?? on("OLLAMA_BASE_URL") ?? this.baseUrl, this.client = new GO({
      fetch: e?.fetch,
      host: this.baseUrl,
      headers: e?.headers
    }), this.model = e?.model ?? this.model, this.numa = e?.numa, this.numCtx = e?.numCtx, this.numBatch = e?.numBatch, this.numGpu = e?.numGpu, this.mainGpu = e?.mainGpu, this.lowVram = e?.lowVram, this.f16Kv = e?.f16Kv, this.logitsAll = e?.logitsAll, this.vocabOnly = e?.vocabOnly, this.useMmap = e?.useMmap, this.useMlock = e?.useMlock, this.embeddingOnly = e?.embeddingOnly, this.numThread = e?.numThread, this.numKeep = e?.numKeep, this.seed = e?.seed, this.numPredict = e?.numPredict, this.topK = e?.topK, this.topP = e?.topP, this.tfsZ = e?.tfsZ, this.typicalP = e?.typicalP, this.repeatLastN = e?.repeatLastN, this.temperature = e?.temperature, this.repeatPenalty = e?.repeatPenalty, this.presencePenalty = e?.presencePenalty, this.frequencyPenalty = e?.frequencyPenalty, this.mirostat = e?.mirostat, this.mirostatTau = e?.mirostatTau, this.mirostatEta = e?.mirostatEta, this.penalizeNewline = e?.penalizeNewline, this.streaming = e?.streaming, this.format = e?.format, this.keepAlive = e?.keepAlive, this.think = e?.think, this.checkOrPullModel = e?.checkOrPullModel ?? this.checkOrPullModel;
  }
  _llmType() {
    return "ollama";
  }
  /**
  * Download a model onto the local machine.
  *
  * @param {string} model The name of the model to download.
  * @param {PullModelOptions | undefined} options Options for pulling the model.
  * @returns {Promise<void>}
  */
  async pull(e, t) {
    const { stream: n, insecure: r, logProgress: s } = {
      stream: !0,
      ...t
    };
    if (n)
      for await (const i of await this.client.pull({
        model: e,
        insecure: r,
        stream: n
      })) s && console.log(i);
    else {
      const i = await this.client.pull({
        model: e,
        insecure: r
      });
      s && console.log(i);
    }
  }
  bindTools(e, t) {
    return this.withConfig({
      tools: e.map((n) => Yc(n)),
      ...t
    });
  }
  getLsParams(e) {
    const t = this.invocationParams(e);
    return {
      ls_provider: "ollama",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: t.options?.temperature ?? void 0,
      ls_max_tokens: t.options?.num_predict ?? void 0,
      ls_stop: e.stop
    };
  }
  invocationParams(e) {
    return {
      model: this.model,
      format: e?.format ?? this.format,
      keep_alive: this.keepAlive,
      think: this.think,
      options: {
        numa: this.numa,
        num_ctx: this.numCtx,
        num_batch: this.numBatch,
        num_gpu: this.numGpu,
        main_gpu: this.mainGpu,
        low_vram: this.lowVram,
        f16_kv: this.f16Kv,
        logits_all: this.logitsAll,
        vocab_only: this.vocabOnly,
        use_mmap: this.useMmap,
        use_mlock: this.useMlock,
        embedding_only: this.embeddingOnly,
        num_thread: this.numThread,
        num_keep: this.numKeep,
        seed: this.seed,
        num_predict: this.numPredict,
        top_k: this.topK,
        top_p: this.topP,
        tfs_z: this.tfsZ,
        typical_p: this.typicalP,
        repeat_last_n: this.repeatLastN,
        temperature: this.temperature,
        repeat_penalty: this.repeatPenalty,
        presence_penalty: this.presencePenalty,
        frequency_penalty: this.frequencyPenalty,
        mirostat: this.mirostat,
        mirostat_tau: this.mirostatTau,
        mirostat_eta: this.mirostatEta,
        penalize_newline: this.penalizeNewline,
        stop: e?.stop
      },
      tools: e?.tools?.length ? e.tools.map((t) => Yc(t)) : void 0
    };
  }
  /**
  * Check if a model exists on the local machine.
  *
  * @param {string} model The name of the model to check.
  * @returns {Promise<boolean>} Whether or not the model exists.
  */
  async checkModelExistsOnMachine(e) {
    const { models: t } = await this.client.list();
    return !!t.find((n) => n.name === e || n.name === `${e}:latest`);
  }
  async _generate(e, t, n) {
    this.checkOrPullModel && (await this.checkModelExistsOnMachine(this.model) || await this.pull(this.model, { logProgress: !0 }));
    let r;
    for await (const i of this._streamResponseChunks(e, t, n)) r ? r = hr(r, i.message) : r = i.message;
    const s = new rt({
      id: r?.id,
      content: r?.content ?? "",
      additional_kwargs: r?.additional_kwargs,
      tool_calls: r?.tool_calls,
      response_metadata: r?.response_metadata,
      usage_metadata: r?.usage_metadata
    });
    return { generations: [{
      text: typeof s.content == "string" ? s.content : "",
      message: s
    }] };
  }
  async *_streamResponseChunks(e, t, n) {
    this.checkOrPullModel && (await this.checkModelExistsOnMachine(this.model) || await this.pull(this.model, { logProgress: !0 }));
    const r = this.invocationParams(t), s = Oq(e), i = {
      input_tokens: 0,
      output_tokens: 0,
      total_tokens: 0
    }, a = await this.client.chat({
      ...r,
      messages: s,
      stream: !0
    });
    let o;
    for await (const u of a) {
      t.signal?.aborted && this.client.abort();
      const { message: c, ...l } = u;
      i.input_tokens += l.prompt_eval_count ?? 0, i.output_tokens += l.eval_count ?? 0, i.total_tokens = i.input_tokens + i.output_tokens, o = l;
      const d = this.think ? c.thinking ?? c.content ?? "" : c.content ?? "";
      yield new Xn({
        text: d,
        message: Sq(c)
      }), await n?.handleLLMNewToken(d);
    }
    yield new Xn({
      text: "",
      message: new We({
        content: "",
        response_metadata: {
          ...o,
          model_provider: "ollama"
        },
        usage_metadata: i
      })
    });
  }
  withStructuredOutput(e, t) {
    let n, r;
    const { schema: s, name: i, includeRaw: a } = {
      ...t,
      schema: e
    }, o = t?.method ?? "jsonSchema";
    if (o === "functionCalling") {
      let d = i ?? "extract";
      if (_t(s)) {
        const f = it(s);
        n = this.bindTools([{
          type: "function",
          function: {
            name: d,
            description: f.description,
            parameters: f
          }
        }]).withConfig({ ls_structured_output_format: {
          kwargs: { method: o },
          schema: f
        } }), r = new So({
          returnSingle: !0,
          keyName: d,
          zodSchema: s
        });
      } else {
        let f;
        typeof s.name == "string" && typeof s.parameters == "object" && s.parameters != null ? (f = s, d = s.name) : f = {
          name: d,
          description: s.description ?? "",
          parameters: s
        }, n = this.bindTools([{
          type: "function",
          function: f
        }]).withConfig({ ls_structured_output_format: {
          kwargs: { method: o },
          schema: s
        } }), r = new So({
          returnSingle: !0,
          keyName: d
        });
      }
    } else if (o === "jsonMode") {
      r = _t(s) ? bs.fromZodSchema(s) : new Ss();
      const d = it(s);
      n = this.withConfig({
        format: "json",
        ls_structured_output_format: {
          kwargs: { method: o },
          schema: d
        }
      });
    } else if (o === "jsonSchema") {
      r = _t(s) ? bs.fromZodSchema(s) : new Ss();
      const d = it(s);
      n = this.withConfig({
        format: d,
        ls_structured_output_format: {
          kwargs: { method: o },
          schema: d
        }
      });
    } else throw new TypeError(`Unrecognized structured output method '${o}'. Expected one of 'functionCalling', 'jsonMode', or 'jsonSchema'`);
    if (!a) return n.pipe(r).withConfig({ runName: "ChatOllamaStructuredOutput" });
    const u = _n.assign({ parsed: (d, f) => r.invoke(d.raw, f) }), c = _n.assign({ parsed: () => null }), l = u.withFallbacks({ fallbacks: [c] });
    return Kr.from([{ raw: n }, l]).withConfig({ runName: "StructuredOutputRunnable" });
  }
};
class WO {
  model = null;
  currentProvider = null;
  constructor() {
  }
  /**
   * Configures the active LLM Model
   */
  configure(t, n, r) {
    switch (this.currentProvider = t, t) {
      case "openai":
        this.model = new az({
          openAIApiKey: r,
          modelName: n
        });
        break;
      case "anthropic":
        this.model = new Y9({
          anthropicApiKey: r,
          model: n
        });
        break;
      case "google":
        this.model = new iq({
          apiKey: r,
          model: n,
          maxRetries: 1
          // Prevent infinite retry loops on free tier
        });
        break;
      case "ollama":
        this.model = new Yq({
          baseUrl: "http://localhost:11434",
          // Default
          model: n
        });
        break;
    }
    console.log(`LLMService: Configured for ${t} with model ${n}`);
  }
  async chat(t) {
    if (!this.model)
      return console.warn("LLMService: No Provider Configured. Using Mock response."), `[MOCK AI - No Provider Set] I heard: "${t[t.length - 1].content.toString()}". 

Please configure a provider (OpenAI, Anthropic, Google, or Ollama) to continue.`;
    try {
      console.log(`LLMService: Sending chat request to ${this.currentProvider}`);
      let n = t;
      this.currentProvider === "google" && (console.log("LLMService: Preprocessing messages for Google..."), n = this.preprocessForGoogle(t), console.log("LLMService: Google Messages structure:", JSON.stringify(n.map((a) => ({ type: a.getType(), contentLength: a.content.toString().length })), null, 2))), console.log("LLMService: Invoking model (STREAMING MODE)...");
      const r = new Promise(
        (a, o) => setTimeout(() => o(new Error("Request timed out after 60 seconds")), 6e4)
      ), s = (async () => {
        const a = await this.model.stream(n);
        let o = "", u = 0;
        for await (const c of a) {
          const l = c.content.toString();
          o += l, u++, u <= 3 && console.log(`LLMService: Received chunk ${u}:`, l.substring(0, 20) + "...");
        }
        return console.log(`LLMService: Stream complete. Total chunks: ${u}`), o;
      })();
      return await Promise.race([s, r]);
    } catch (n) {
      return console.error("LLM Execution Error:", n), `Error connecting to ${this.currentProvider}: ${n.message}`;
    }
  }
  /**
   * Google Gemini has strict message ordering requirements:
   * - System message must be first (if present)
   * - Only one system message is allowed
   * - After system, must be alternating Human/AI messages
   */
  preprocessForGoogle(t) {
    const n = [], r = [];
    for (const a of t)
      a.getType() === "system" ? n.push(a) : r.push(a);
    let s = n.map((a) => a.content).join(`

`);
    const i = [];
    s && i.push(new Kn(s));
    for (const a of r) {
      const o = a.getType();
      o === "human" ? i.push(a) : o === "ai" || o === "system" ? i.push(new rt(a.content.toString())) : i.push(a);
    }
    return i;
  }
  /**
   * Fetches available models from the specified provider API
   */
  async getAvailableModels(t, n) {
    const r = [];
    try {
      switch (t) {
        case "openai": {
          if (!n) throw new Error("API Key required for OpenAI");
          const s = await fetch("https://api.openai.com/v1/models", {
            headers: { Authorization: `Bearer ${n}` }
          });
          if (!s.ok) throw new Error(`OpenAI API Error: ${s.statusText}`);
          (await s.json()).data.forEach((a) => {
            a.id.includes("gpt") && r.push({ id: a.id, name: a.id, provider: "openai" });
          });
          break;
        }
        case "anthropic": {
          if (!n) throw new Error("API Key required for Anthropic");
          const s = await fetch("https://api.anthropic.com/v1/models", {
            headers: {
              "x-api-key": n,
              "anthropic-version": "2023-06-01"
            }
          });
          if (!s.ok) throw new Error(`Anthropic API Error: ${s.statusText}`);
          (await s.json()).data.forEach((a) => {
            r.push({ id: a.id, name: a.display_name || a.id, provider: "anthropic" });
          });
          break;
        }
        case "google": {
          if (!n) throw new Error("API Key required for Google");
          const s = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${n}`);
          if (!s.ok) throw new Error(`Google API Error: ${s.statusText}`);
          const i = await s.json();
          i.models && i.models.forEach((a) => {
            const o = a.name.replace("models/", "");
            r.push({ id: o, name: a.displayName || o, provider: "google" });
          });
          break;
        }
        case "ollama": {
          const s = await fetch("http://localhost:11434/api/tags");
          if (!s.ok) throw new Error(`Ollama API Error: ${s.statusText}`);
          (await s.json()).models.forEach((a) => {
            r.push({ id: a.name, name: a.name, provider: "ollama" });
          });
          break;
        }
      }
    } catch (s) {
      throw console.error(`Failed to fetch models for ${t}:`, s), s;
    }
    return r;
  }
}
class Xq {
  llm;
  fs;
  currentStep = 1;
  context;
  isDecomposing = !1;
  constructor(t) {
    this.fs = t, this.llm = new WO(), this.context = {
      name: "Untitled Project",
      description: "",
      requirements: [],
      chatHistory: []
    };
  }
  getLLM() {
    return this.llm;
  }
  async processMessage(t) {
    this.context.chatHistory.push(new Zt(t));
    let n = "";
    switch (this.currentStep) {
      case 1:
        n = await this.handleInitiationStep();
        break;
      case 2:
        n = "I am generating the initial task list...";
        break;
      case 3:
        n = await this.handleDecompositionStep();
        break;
      default:
        n = "I am not ready for step " + this.currentStep + " yet.";
    }
    return this.context.chatHistory.push(new rt(n)), this.saveContext(), n;
  }
  async handleInitiationStep() {
    const t = this.context.chatHistory[this.context.chatHistory.length - 1].content.toString().toLowerCase();
    if (t.includes("yes") || t.includes("proceed") || t.includes("looks good"))
      return this.currentStep = 2, await this.generateHighLevelTasks();
    const n = `You are an **Agentic Project Manager AI** guiding the user through a multi-step autonomous project planning process.

## The 7-Step Process (You Are on Step 1)
1. **Initiation** (CURRENT) - Interview the user about their project.
2. **Task Generation** - Convert requirements into high-level tasks.
3. **Decomposition** - Break tasks into actionable sub-tasks.
4. **Analysis** - Evaluate dependencies and complexity.
5. **Coordination** - Plan parallel execution opportunities.
6. **Planning** - Generate implementation steps for each task.
7. **Execution** - (Future) The agent autonomously writes code.

## Your Role (Step 1: Initiation)
- Ask clarifying questions about the user's **project idea**.
- Focus on:
  - What is the goal of the project?
  - What technologies or platforms are involved (if any)?
  - What are the core features or components?
- **DO NOT** ask about implementation details, formatting, file structures, or code specifics. Those will be addressed automatically in later steps.

## Current Knowledge
- Project Name: ${this.context.name}
- Description: ${this.context.description || "Not yet defined"}

## Instructions
- Use **Markdown formatting** (**bold**, lists) for readability.
- Keep responses concise (2-4 sentences max per point).
- When you have enough information (project goal, scope, and key features), **summarize** and ask:
  > "I have a good understanding. Ready to proceed to **Step 2: Task Generation**?"
- When the user confirms (e.g., "yes", "proceed"), end the conversation.`, r = [
      new Kn(n),
      ...this.context.chatHistory.slice(-10)
    ];
    return this.llm.chat(r);
  }
  async generateHighLevelTasks() {
    const t = `Based on our conversation, generate a JSON structure for the project tasks.
        
        Project Context:
        ${this.context.chatHistory.map((s) => s.getType() + ": " + s.content).join(`
`)}

        
        Output MUST be a valid JSON object matching this interface:
        {
            "id": "root",
            "title": "Project Name",
            "type": "project",
            "status": "pending",
            "children": [
                { "id": "1", "title": "Main Task 1", "type": "main-task", "status": "pending", "children": [] }
            ]
        }
        
        Create high-level "main-task" items, which are purely large scale and broad in scope, meant to act more like categories or sections of tasks and task types. Do not go deeper than main-task levels yet.
        Return ONLY valid JSON. No markdown formatting.`, n = [new Zt(t)], r = await this.llm.chat(n);
    try {
      const s = r.replace(/```json/g, "").replace(/```/g, "").trim(), i = JSON.parse(s);
      return await this.fs.writeSafe("tasks.json", JSON.stringify(i, null, 2)), this.currentStep = 3, `**Step 2 Complete!** I've generated the initial project structure.

**Project:** ${i.title}
**Tasks Created:** ${i.children?.length || 0} high-level tasks

Check the **Task Tree** view to see the structure.

---

**Ready for Step 3: Decomposition?**
This will break each task into actionable sub-tasks. Type **"decompose"** or **"yes"** to begin.`;
    } catch (s) {
      return console.error("Failed to parse task JSON", s), "I tried to generate tasks but failed to parse the output. Let's try again.";
    }
  }
  // ============================================
  // STEP 3: DECOMPOSITION
  // ============================================
  async handleDecompositionStep() {
    const t = this.context.chatHistory[this.context.chatHistory.length - 1].content.toString().toLowerCase();
    return t.includes("decompose") || t.includes("yes") || t.includes("proceed") || t.includes("break") ? this.isDecomposing ? "Decomposition is already in progress. Please wait..." : await this.runDecomposition() : t.includes("skip") || t.includes("next") ? (this.currentStep = 4, "Skipping decomposition. Moving to **Step 4: Analysis**.") : `We're now in **Step 3: Decomposition**.

I will analyze each high-level task and break it down into actionable sub-tasks.

**Options:**
- Type **"decompose"** or **"yes"** to start automatic decomposition
- Type **"skip"** to move to the next step

What would you like to do?`;
  }
  async runDecomposition() {
    this.isDecomposing = !0;
    try {
      const t = await this.fs.readFile("tasks.json");
      if (!t)
        return "No tasks.json found. Please complete Step 2 first.";
      const n = JSON.parse(t), r = this.findTasksToDecompose(n);
      if (r.length === 0)
        return this.currentStep = 4, "All tasks are already decomposed! Moving to **Step 4: Analysis**.";
      let s = 0;
      const i = [];
      for (let a = 0; a < r.length; a++) {
        const o = r[a];
        a > 0 && await this.sleep(1500);
        try {
          console.log(`Decomposing task ${a + 1}/${r.length}: ${o.title}`);
          const u = await this.decomposeTask(o, n.title);
          u.length > 0 && (o.children = u, o.decomposed = !0, s++, i.push(` **${o.title}**  ${u.length} sub-tasks`));
        } catch (u) {
          console.error(`Failed to decompose ${o.title}:`, u), i.push(` **${o.title}** - Failed: ${u.message}`);
        }
      }
      return await this.fs.writeSafe("tasks.json", JSON.stringify(n, null, 2)), this.isDecomposing = !1, this.currentStep = 4, `**Decomposition Complete!**

${i.join(`
`)}

---

**${s}** tasks were broken down into sub-tasks. Check the **Task Tree** to see the updated structure.

Moving to **Step 4: Analysis**. Type **"analyze"** to continue.`;
    } catch (t) {
      return this.isDecomposing = !1, console.error("Decomposition error:", t), `Error during decomposition: ${t.message}`;
    }
  }
  findTasksToDecompose(t, n = []) {
    if (t.type === "main-task" && !t.decomposed && (!t.children || t.children.length === 0) && n.push(t), t.children)
      for (const r of t.children)
        this.findTasksToDecompose(r, n);
    return n;
  }
  async decomposeTask(t, n) {
    const r = `You are decomposing a task into actionable sub-tasks.

**Project:** ${n}
**Task to Decompose:** ${t.title}

Break this task into 2-5 specific, actionable sub-tasks. Each sub-task should be something a developer could complete in a focused work session.

Output ONLY a valid JSON array of sub-tasks:
[
    { "id": "${t.id}-1", "title": "Sub-task title", "type": "sub-task", "status": "pending", "children": [] }
]

Rules:
- Each sub-task should be specific and actionable
- Use descriptive titles that explain what needs to be done
- Keep the "type" as "sub-task"
- All "status" should be "pending"
- Return ONLY valid JSON, no markdown`, s = [new Zt(r)], i = await this.llm.chat(s);
    try {
      const a = i.replace(/```json/g, "").replace(/```/g, "").trim();
      return JSON.parse(a);
    } catch (a) {
      throw console.error(`Failed to parse sub-tasks for ${t.title}:`, a), new Error("Failed to parse LLM response");
    }
  }
  async saveContext() {
  }
  sleep(t) {
    return new Promise((n) => setTimeout(n, t));
  }
}
class Qq {
  fileSystem = null;
  workflow = null;
  projectPath = null;
  // State to track if agent loop is active
  isRunning = !1;
  constructor() {
    this.setupIPC();
  }
  setupIPC() {
    console.log("AgentManager: Setting up IPC listeners"), yr.handle("agent:select-directory", async () => {
      const t = await XO.showOpenDialog({
        properties: ["openDirectory", "createDirectory"]
      });
      return t.canceled ? null : t.filePaths[0];
    }), yr.handle("agent:init-project", async (t, n) => (console.log(`AgentManager: Initializing project at ${n}`), this.initializeProject(n))), yr.handle("agent:run-step", async (t, n, r) => (console.log(`AgentManager: Running step ${n}`), this.runStep(n, r))), yr.handle("agent:get-tasks", async () => {
      if (this.projectPath) {
        const t = tt.join(this.projectPath, "tasks.json");
        if (await Tt.pathExists(t))
          return Tt.readJSON(t);
      }
      return null;
    }), yr.handle("agent:get-status", () => ({ isRunning: this.isRunning, projectPath: this.projectPath })), yr.handle("agent:chat", async (t, n) => {
      if (console.log(`AgentManager: Chat received: ${n}`), !this.workflow)
        return {
          id: Date.now().toString(),
          role: "agent",
          content: "Error: Project not initialized. Please open a project first.",
          timestamp: Date.now()
        };
      try {
        const r = await this.workflow.processMessage(n);
        return {
          id: Date.now().toString(),
          role: "agent",
          content: r,
          timestamp: Date.now()
        };
      } catch (r) {
        return console.error("Workflow Error:", r), {
          id: Date.now().toString(),
          role: "agent",
          content: "I encountered an error processing your request: " + r.message,
          timestamp: Date.now()
        };
      }
    }), yr.handle("agent:get-models", async (t, n, r) => this.workflow ? this.workflow.getLLM().getAvailableModels(n, r) : new WO().getAvailableModels(n, r)), yr.handle("agent:configure-llm", async (t, n) => {
      if (this.workflow && this.projectPath) {
        this.workflow.getLLM().configure(n.provider, n.modelId, n.apiKey);
        try {
          const r = tt.join(this.projectPath, ".agent_workspace", "settings.json"), s = await Tt.readJSON(r).catch(() => ({}));
          return await Tt.writeJSON(r, {
            ...s,
            llm: n
          }, { spaces: 2 }), { success: !0 };
        } catch (r) {
          return { success: !1, error: "Failed to save settings: " + r.message };
        }
      }
      return { success: !1, error: "Project not initialized" };
    });
  }
  async initializeProject(t) {
    try {
      this.projectPath = t, this.fileSystem = new DI(t), await this.fileSystem.initialize(), this.workflow = new Xq(this.fileSystem);
      const n = tt.join(t, ".agent_workspace");
      await Tt.ensureDir(tt.join(n, "history")), await Tt.ensureDir(tt.join(n, "snapshots"));
      const r = tt.join(n, "settings.json");
      if (!await Tt.pathExists(r))
        await Tt.writeJSON(r, {
          created: Date.now(),
          agentMode: "default"
        }, { spaces: 2 });
      else
        try {
          const s = await Tt.readJSON(r);
          s.llm && (console.log("Restoring LLM Config from settings"), this.workflow.getLLM().configure(
            s.llm.provider,
            s.llm.modelId,
            s.llm.apiKey
          ));
        } catch (s) {
          console.error("Error loading settings:", s);
        }
      return { success: !0 };
    } catch (n) {
      return console.error("Failed to initialize project:", n), { success: !1, error: n.message };
    }
  }
  async runStep(t, n) {
    if (!this.fileSystem)
      throw new Error("Project not initialized");
    this.isRunning = !0;
    try {
      return await new Promise((r) => setTimeout(r, 1e3)), { success: !0, message: `Step ${t} executed` };
    } catch (r) {
      return { success: !1, error: r.message };
    } finally {
      this.isRunning = !1;
    }
  }
}
new Qq();
const JO = tt.dirname(uI(import.meta.url));
process.env.APP_ROOT = tt.join(JO, "..");
const Mp = process.env.VITE_DEV_SERVER_URL, dB = tt.join(process.env.APP_ROOT, "dist-electron"), KO = tt.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Mp ? tt.join(process.env.APP_ROOT, "public") : KO;
let Js;
function YO() {
  Js = new $b({
    icon: tt.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: tt.join(JO, "preload.mjs")
    }
  }), Js.webContents.on("did-finish-load", () => {
    Js?.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  }), Mp ? Js.loadURL(Mp) : Js.loadFile(tt.join(KO, "index.html"));
}
yc.on("window-all-closed", () => {
  process.platform !== "darwin" && (yc.quit(), Js = null);
});
yc.on("activate", () => {
  $b.getAllWindows().length === 0 && YO();
});
yc.whenReady().then(YO);
export {
  dB as MAIN_DIST,
  KO as RENDERER_DIST,
  Mp as VITE_DEV_SERVER_URL
};
